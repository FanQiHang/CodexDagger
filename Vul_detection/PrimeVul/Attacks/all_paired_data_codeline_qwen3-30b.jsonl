{
  "idx": 0,
  "target": 1,
  "vul": "long ssl_get_algorithm2(SSL *s) \n { \n long alg2 = s->s3->tmp.new_cipher->algorithm2; \n if (TLS1_get_version(s) >= TLS1_2_VERSION && \n alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF)) \n return SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256; \n return alg2; \n }",
  "no_vul": "long ssl_get_algorithm2(SSL *s) \n { \n long alg2 = s->s3->tmp.new_cipher->algorithm2; \n if (s->method->version == TLS1_2_VERSION && \n alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF)) \n return SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256; \n return alg2; \n }",
  "cwe": "CWE-310",
  "codeline": "if (TLS1_get_version(s) >= TLS1_2_VERSION && \n alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))"
}
{
  "idx": 1,
  "target": 1,
  "vul": "void red_channel_pipes_add_empty_msg(RedChannel *channel, int msg_type) \n { \n RingItem *link; \n RING_FOREACH(link, &channel->clients) { \n red_channel_client_pipe_add_empty_msg( \n SPICE_CONTAINEROF(link, RedChannelClient, channel_link), \n msg_type); \n } \n }",
  "no_vul": "void red_channel_pipes_add_empty_msg(RedChannel *channel, int msg_type) \n { \n RingItem *link, *next; \n RING_FOREACH_SAFE(link, next, &channel->clients) { \n red_channel_client_pipe_add_empty_msg( \n SPICE_CONTAINEROF(link, RedChannelClient, channel_link), \n msg_type); \n } \n }",
  "cwe": "CWE-399",
  "codeline": "RING_FOREACH(link, &channel->clients) {"
}
{
  "idx": 2,
  "target": 1,
  "vul": "void red_channel_pipes_add_type(RedChannel *channel, int pipe_item_type) \n { \n RingItem *link; \n RING_FOREACH(link, &channel->clients) { \n red_channel_client_pipe_add_type( \n SPICE_CONTAINEROF(link, RedChannelClient, channel_link), \n pipe_item_type); \n } \n }",
  "no_vul": "void red_channel_pipes_add_type(RedChannel *channel, int pipe_item_type) \n { \n RingItem *link, *next; \n RING_FOREACH_SAFE(link, next, &channel->clients) { \n red_channel_client_pipe_add_type( \n SPICE_CONTAINEROF(link, RedChannelClient, channel_link), \n pipe_item_type); \n } \n }",
  "cwe": "CWE-399",
  "codeline": "RING_FOREACH(link, &channel->clients) {"
}
{
  "idx": 3,
  "target": 1,
  "vul": "x11_open_helper(Buffer *b) \n { \n u_char *ucp; \n u_int proto_len, data_len; \n u_char *ucp; \n u_int proto_len, data_len; \n if (buffer_len(b) < 12) \n return 0; \n debug2(\"Initial X11 packet contains bad byte order byte: 0x%x\", \n ucp[0]); \n return -1; \n }",
  "no_vul": "x11_open_helper(Buffer *b) \n { \n u_char *ucp; \n u_int proto_len, data_len; \n u_char *ucp; \n u_int proto_len, data_len; \n if (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) { \n verbose(\"Rejected X11 connection after ForwardX11Timeout \" \n \"expired\"); \n return -1; \n } \n if (buffer_len(b) < 12) \n return 0; \n debug2(\"Initial X11 packet contains bad byte order byte: 0x%x\", \n ucp[0]); \n return -1; \n }",
  "cwe": "CWE-264",
  "codeline": "debug2(\"Initial X11 packet contains bad byte order byte: 0x%x\", \n ucp[0]);"
}
{
  "idx": 4,
  "target": 1,
  "vul": "_dbus_header_byteswap (DBusHeader *header, \n int new_order) \n { \n if (header->byte_order == new_order) \n return; \n _dbus_marshal_byteswap (&_dbus_header_signature_str, \n 0, header->byte_order, \n new_order, \n &header->data, 0); \n header->byte_order = new_order; \n }",
  "no_vul": "_dbus_header_byteswap (DBusHeader *header, \n int new_order) \n { \n unsigned char byte_order; \n if (header->byte_order == new_order) \n return; \n byte_order = _dbus_string_get_byte (&header->data, BYTE_ORDER_OFFSET); \n _dbus_assert (header->byte_order == byte_order); \n _dbus_marshal_byteswap (&_dbus_header_signature_str, \n 0, header->byte_order, \n new_order, \n &header->data, 0); \n _dbus_string_set_byte (&header->data, BYTE_ORDER_OFFSET, new_order); \n header->byte_order = new_order; \n }",
  "cwe": "CWE-20",
  "codeline": "_dbus_marshal_byteswap (&_dbus_header_signature_str, \n 0, header->byte_order, \n new_order, \n &header->data, 0);"
}
{
  "idx": 5,
  "target": 1,
  "vul": "destroy_one_secret (gpointer data) \n { \n char *secret = (char *) data; \n g_message (\"%s: destroying %s\", __func__, secret); \n memset (secret, 0, strlen (secret)); \n g_free (secret); \n }",
  "no_vul": "destroy_one_secret (gpointer data) \n { \n char *secret = (char *) data; \n memset (secret, 0, strlen (secret)); \n g_free (secret); \n }",
  "cwe": "CWE-200",
  "codeline": "g_message (\"%s: destroying %s\", __func__, secret);"
}
{
  "idx": 6,
  "target": 1,
  "vul": "new_msg_register_event (u_int32_t seqnum, struct lsa_filter_type *filter) \n { \n u_char buf[OSPF_API_MAX_MSG_SIZE]; \n struct msg_register_event *emsg; \n int len; \n emsg = (struct msg_register_event *) buf; \n len = sizeof (struct msg_register_event) + \n filter->num_areas * sizeof (struct in_addr); \n emsg->filter.typemask = htons (filter->typemask); \n emsg->filter.origin = filter->origin; \n emsg->filter.num_areas = filter->num_areas; \n return msg_new (MSG_REGISTER_EVENT, emsg, seqnum, len); \n }",
  "no_vul": "new_msg_register_event (u_int32_t seqnum, struct lsa_filter_type *filter) \n { \n u_char buf[OSPF_API_MAX_MSG_SIZE]; \n struct msg_register_event *emsg; \n int len; \n emsg = (struct msg_register_event *) buf; \n len = sizeof (struct msg_register_event) + \n filter->num_areas * sizeof (struct in_addr); \n emsg->filter.typemask = htons (filter->typemask); \n emsg->filter.origin = filter->origin; \n emsg->filter.num_areas = filter->num_areas; \n if (len > sizeof (buf)) \n len = sizeof(buf); \n return msg_new (MSG_REGISTER_EVENT, emsg, seqnum, len); \n }",
  "cwe": "CWE-119",
  "codeline": "len = sizeof (struct msg_register_event) + \n filter->num_areas * sizeof (struct in_addr);"
}
{
  "idx": 7,
  "target": 1,
  "vul": "static X509_ALGOR *rsa_mgf1_decode(X509_ALGOR *alg) \n { \n const unsigned char *p; \n int plen; \n if (alg == NULL) \n return NULL; \n if (OBJ_obj2nid(alg->algorithm) != NID_mgf1) \n return NULL; \n if (alg->parameter->type != V_ASN1_SEQUENCE) \n return NULL; \n p = alg->parameter->value.sequence->data; \n plen = alg->parameter->value.sequence->length; \n return d2i_X509_ALGOR(NULL, &p, plen); \n }",
  "no_vul": "static X509_ALGOR *rsa_mgf1_decode(X509_ALGOR *alg) \n { \n const unsigned char *p; \n int plen; \n if (alg == NULL || alg->parameter == NULL) \n return NULL; \n if (OBJ_obj2nid(alg->algorithm) != NID_mgf1) \n return NULL; \n if (alg->parameter->type != V_ASN1_SEQUENCE) \n return NULL; \n p = alg->parameter->value.sequence->data; \n plen = alg->parameter->value.sequence->length; \n return d2i_X509_ALGOR(NULL, &p, plen); \n }",
  "cwe": "CWE-476",
  "codeline": "if (alg == NULL) \nreturn NULL;"
}
{
  "idx": 8,
  "target": 1,
  "vul": "static NTSTATUS fd_open_atomic(struct connection_struct *conn, \n files_struct *fsp, \n int flags, \n mode_t mode, \n bool *file_created) \n { \n NTSTATUS status = NT_STATUS_UNSUCCESSFUL; \n bool file_existed = VALID_STAT(fsp->fsp_name->st); \n *file_created = false; \n * We're not creating the file, just pass through. \n */ \n return fd_open(conn, fsp, flags, mode); \n }",
  "no_vul": "static NTSTATUS fd_open_atomic(struct connection_struct *conn, \n files_struct *fsp, \n int flags, \n mode_t mode, \n bool *file_created) \n { \n NTSTATUS status = NT_STATUS_UNSUCCESSFUL; \n NTSTATUS retry_status; \n bool file_existed = VALID_STAT(fsp->fsp_name->st); \n int curr_flags; \n *file_created = false; \n * We're not creating the file, just pass through. \n */ \n return fd_open(conn, fsp, flags, mode); \n }",
  "cwe": "CWE-835",
  "codeline": "return fd_open(conn, fsp, flags, mode);"
}
{
  "idx": 9,
  "target": 1,
  "vul": "void vrend_renderer_context_destroy(uint32_t handle) \n { \n struct vrend_decode_ctx *ctx; \n bool ret; \n if (handle >= VREND_MAX_CTX) \n return; \n ctx = dec_ctx[handle]; \n if (!ctx) \n return; \n vrend_hw_switch_context(dec_ctx[0]->grctx, true); \n }",
  "no_vul": "void vrend_renderer_context_destroy(uint32_t handle) \n { \n struct vrend_decode_ctx *ctx; \n bool ret; \n if (handle >= VREND_MAX_CTX) \n return; \n if (handle == 0) { \n return; \n } \n ctx = dec_ctx[handle]; \n if (!ctx) \n return; \n vrend_hw_switch_context(dec_ctx[0]->grctx, true); \n }",
  "cwe": "CWE-476",
  "codeline": "ctx = dec_ctx[handle];"
}
{
  "idx": 10,
  "target": 1,
  "vul": "XvQueryAdaptors( \n Display *dpy, \n Window window, \n unsigned int *p_nAdaptors, \n XvAdaptorInfo **p_pAdaptors) \n { \n XExtDisplayInfo *info = xv_find_display(dpy); \n xvQueryAdaptorsReq *req; \n xvQueryAdaptorsReply rep; \n size_t size; \n unsigned int ii, jj; \n char *name; \n XvAdaptorInfo *pas = NULL, *pa; \n XvFormat *pfs, *pf; \n char *buffer = NULL; \n char *buffer; \n char *string; \n xvAdaptorInfo *pa; \n xvFormat *pf; \n } u;",
  "no_vul": "XvQueryAdaptors( \n Display *dpy, \n Window window, \n unsigned int *p_nAdaptors, \n XvAdaptorInfo **p_pAdaptors) \n { \n XExtDisplayInfo *info = xv_find_display(dpy); \n xvQueryAdaptorsReq *req; \n xvQueryAdaptorsReply rep; \n size_t size; \n unsigned int ii, jj; \n char *name; \n char *end; \n XvAdaptorInfo *pas = NULL, *pa; \n XvFormat *pfs, *pf; \n char *buffer = NULL; \n char *buffer; \n char *string; \n xvAdaptorInfo *pa; \n xvFormat *pf; \n } u;",
  "cwe": "CWE-125",
  "codeline": "char *buffer = NULL; \nchar *buffer;"
}
{
  "idx": 11,
  "target": 1,
  "vul": "void DelayedExecutor::delayedExecute(const QString &udi) \n { \n Solid::Device device(udi); \n QString exec = m_service.exec(); \n MacroExpander mx(device); \n mx.expandMacros(exec); \n KRun::runCommand(exec, QString(), m_service.icon(), 0); \n deleteLater(); \n }",
  "no_vul": "void DelayedExecutor::delayedExecute(const QString &udi) \n { \n Solid::Device device(udi); \n QString exec = m_service.exec(); \n MacroExpander mx(device); \n mx.expandMacrosShellQuote(exec); \n KRun::runCommand(exec, QString(), m_service.icon(), 0); \n deleteLater(); \n }",
  "cwe": "CWE-78",
  "codeline": "mx.expandMacros(exec);"
}
{
  "idx": 12,
  "target": 1,
  "vul": "cf2_initGlobalRegionBuffer( CFF_Decoder* decoder, \n CF2_UInt idx, \n CF2_Buffer buf ) \n { \n FT_ASSERT( decoder && decoder->globals ); \n FT_ZERO( buf ); \n idx += decoder->globals_bias; \n if ( idx >= decoder->num_globals ) \n return TRUE; \n buf->start = \n buf->ptr = decoder->globals[idx]; \n buf->end = decoder->globals[idx + 1]; \n }",
  "no_vul": "cf2_initGlobalRegionBuffer( CFF_Decoder* decoder, \n CF2_UInt idx, \n CF2_Buffer buf ) \n { \n FT_ASSERT( decoder ); \n FT_ZERO( buf ); \n idx += decoder->globals_bias; \n if ( idx >= decoder->num_globals ) \n return TRUE; \n FT_ASSERT( decoder->globals ); \n buf->start = \n buf->ptr = decoder->globals[idx]; \n buf->end = decoder->globals[idx + 1]; \n }",
  "cwe": "CWE-20",
  "codeline": "FT_ASSERT( decoder && decoder->globals );"
}
{
  "idx": 13,
  "target": 1,
  "vul": "validGlxScreen(ClientPtr client, int screen, __GLXscreen **pGlxScreen, int *err) \n { \n if (screen >= screenInfo.numScreens) { \n client->errorValue = screen; \n *err = BadValue; \n return FALSE; \n } \n *pGlxScreen = glxGetScreen(screenInfo.screens[screen]); \n return TRUE; \n }",
  "no_vul": "validGlxScreen(ClientPtr client, int screen, __GLXscreen **pGlxScreen, int *err) \n { \n if (screen < 0 || screen >= screenInfo.numScreens) { \n client->errorValue = screen; \n *err = BadValue; \n return FALSE; \n } \n *pGlxScreen = glxGetScreen(screenInfo.screens[screen]); \n return TRUE; \n }",
  "cwe": "CWE-20",
  "codeline": "if (screen >= screenInfo.numScreens) {"
}
{
  "idx": 14,
  "target": 1,
  "vul": "int __glXDisp_CreateContext(__GLXclientState *cl, GLbyte *pc) \n { \n xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc; \n __GLXconfig *config; \n __GLXscreen *pGlxScreen; \n int err; \n if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err)) \n return err; \n if (!validGlxVisual(cl->client, pGlxScreen, req->visual, &config, &err)) \n config, pGlxScreen, req->isDirect); \n }",
  "no_vul": "int __glXDisp_CreateContext(__GLXclientState *cl, GLbyte *pc) \n { \n ClientPtr client = cl->client; \n xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc; \n __GLXconfig *config; \n __GLXscreen *pGlxScreen; \n int err; \n REQUEST_SIZE_MATCH(xGLXCreateContextReq); \n if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err)) \n return err; \n if (!validGlxVisual(cl->client, pGlxScreen, req->visual, &config, &err)) \n config, pGlxScreen, req->isDirect); \n }",
  "cwe": "CWE-20",
  "codeline": "if (!validGlxVisual(cl->client, pGlxScreen, req->visual, &config, &err))"
}
{
  "idx": 15,
  "target": 1,
  "vul": "static int generate_key(DH *dh) \n { \n int ok = 0; \n int generate_new_key = 0; \n unsigned l; \n BN_CTX *ctx; \n BN_MONT_CTX *mont = NULL; \n BIGNUM *pub_key = NULL, *priv_key = NULL; \n ctx = BN_CTX_new(); \n if (ctx == NULL) \n goto err; \n generate_new_key = 1; \n } else",
  "no_vul": "static int generate_key(DH *dh) \n { \n int ok = 0; \n int generate_new_key = 0; \n unsigned l; \n BN_CTX *ctx = NULL; \n BN_MONT_CTX *mont = NULL; \n BIGNUM *pub_key = NULL, *priv_key = NULL; \n if (BN_num_bits(dh->p) > OPENSSL_DH_MAX_MODULUS_BITS) { \n DHerr(DH_F_GENERATE_KEY, DH_R_MODULUS_TOO_LARGE); \n return 0; \n } \n ctx = BN_CTX_new(); \n if (ctx == NULL) \n goto err; \n generate_new_key = 1; \n } else",
  "cwe": "CWE-320",
  "codeline": "if (ctx == NULL) \n goto err;"
}
{
  "idx": 16,
  "target": 1,
  "vul": "static void ssl3_take_mac(SSL *s) \n { \n const char *sender; \n int slen; \n if (s->state & SSL_ST_CONNECT) \n { \n sender=s->method->ssl3_enc->server_finished_label; \n sender=s->method->ssl3_enc->client_finished_label; \n slen=s->method->ssl3_enc->client_finished_label_len; \n } \n s->s3->tmp.peer_finish_md_len = s->method->ssl3_enc->final_finish_mac(s, \n sender,slen,s->s3->tmp.peer_finish_md); \n }",
  "no_vul": "static void ssl3_take_mac(SSL *s) \n { \n const char *sender; \n int slen; \n if (s->s3->tmp.new_cipher == NULL) \n return; \n if (s->state & SSL_ST_CONNECT) \n { \n sender=s->method->ssl3_enc->server_finished_label; \n sender=s->method->ssl3_enc->client_finished_label; \n slen=s->method->ssl3_enc->client_finished_label_len; \n } \n s->s3->tmp.peer_finish_md_len = s->method->ssl3_enc->final_finish_mac(s, \n sender,slen,s->s3->tmp.peer_finish_md); \n }",
  "cwe": "CWE-20",
  "codeline": "sender=s->method->ssl3_enc->client_finished_label;"
}
{
  "idx": 17,
  "target": 1,
  "vul": "static void add_probe(const char *name) \n { \n struct module_entry *m; \n m = get_or_add_modentry(name); \n if (!(option_mask32 & (OPT_REMOVE | OPT_SHOW_DEPS)) \n && (m->flags & MODULE_FLAG_LOADED) \n && strncmp(m->modname, \"symbol:\", 7) == 0 \n ) { \n G.need_symbols = 1; \n } \n }",
  "no_vul": "static void add_probe(const char *name) \n { \n struct module_entry *m; \n if (strchr(name, '/')) \n bb_error_msg_and_die(\"malformed module name '%s'\", name); \n m = get_or_add_modentry(name); \n if (!(option_mask32 & (OPT_REMOVE | OPT_SHOW_DEPS)) \n && (m->flags & MODULE_FLAG_LOADED) \n && strncmp(m->modname, \"symbol:\", 7) == 0 \n ) { \n G.need_symbols = 1; \n } \n }",
  "cwe": "CWE-20",
  "codeline": "m = get_or_add_modentry(name);"
}
{
  "idx": 18,
  "target": 1,
  "vul": "SProcXIBarrierReleasePointer(ClientPtr client) \n { \n xXIBarrierReleasePointerInfo *info; \n REQUEST(xXIBarrierReleasePointerReq); \n int i; \n swaps(&stuff->length); \n REQUEST_AT_LEAST_SIZE(xXIBarrierReleasePointerReq); \n swapl(&stuff->num_barriers); \n REQUEST_FIXED_SIZE(xXIBarrierReleasePointerReq, stuff->num_barriers * sizeof(xXIBarrierReleasePointerInfo)); \n info = (xXIBarrierReleasePointerInfo*) &stuff[1]; \n swapl(&info->barrier); \n swapl(&info->eventid); \n }",
  "no_vul": "SProcXIBarrierReleasePointer(ClientPtr client) \n { \n xXIBarrierReleasePointerInfo *info; \n REQUEST(xXIBarrierReleasePointerReq); \n int i; \n swaps(&stuff->length); \n REQUEST_AT_LEAST_SIZE(xXIBarrierReleasePointerReq); \n swapl(&stuff->num_barriers); \n if (stuff->num_barriers > UINT32_MAX / sizeof(xXIBarrierReleasePointerInfo)) \n return BadLength; \n REQUEST_FIXED_SIZE(xXIBarrierReleasePointerReq, stuff->num_barriers * sizeof(xXIBarrierReleasePointerInfo)); \n info = (xXIBarrierReleasePointerInfo*) &stuff[1]; \n swapl(&info->barrier); \n swapl(&info->eventid); \n }",
  "cwe": "CWE-190",
  "codeline": "REQUEST_FIXED_SIZE(xXIBarrierReleasePointerReq, stuff->num_barriers * sizeof(xXIBarrierReleasePointerInfo));"
}
{
  "idx": 19,
  "target": 1,
  "vul": "XdmcpGenerateKey (XdmAuthKeyPtr key) \n { \n #ifndef HAVE_ARC4RANDOM_BUF \n long lowbits, highbits; \n srandom ((int)getpid() ^ time((Time_t *)0)); \n highbits = random (); \n highbits = random (); \n getbits (lowbits, key->data); \n getbits (highbits, key->data + 4); \n #else \n arc4random_buf(key->data, 8); \n #endif \n }",
  "no_vul": "XdmcpGenerateKey (XdmAuthKeyPtr key) \n #ifndef HAVE_ARC4RANDOM_BUF \n static void \n emulate_getrandom_buf (char *auth, int len) \n { \n long lowbits, highbits; \n srandom ((int)getpid() ^ time((Time_t *)0)); \n highbits = random (); \n highbits = random (); \n getbits (lowbits, key->data); \n getbits (highbits, key->data + 4); \n } \n static void \n arc4random_buf (void *auth, int len) \n { \n int ret; \n #if HAVE_GETENTROPY \n ret = getentropy (auth, len); \n if (ret == 0) \n return; \n #endif \n emulate_getrandom_buf (auth, len); \n } \n #endif \n void \n XdmcpGenerateKey (XdmAuthKeyPtr key) \n { \n arc4random_buf(key->data, 8); \n }",
  "cwe": "CWE-320",
  "codeline": "highbits = random (); \nhighbits = random ();"
}
{
  "idx": 20,
  "target": 1,
  "vul": "pch_write_line (lin line, FILE *file) \n { \n bool after_newline = p_line[line][p_len[line] - 1] == '\\n'; \n if (! fwrite (p_line[line], sizeof (*p_line[line]), p_len[line], file)) \n write_fatal (); \n return after_newline; \n }",
  "no_vul": "pch_write_line (lin line, FILE *file) \n { \n bool after_newline = (p_len[line] > 0) && (p_line[line][p_len[line] - 1] == '\\n'); \n if (! fwrite (p_line[line], sizeof (*p_line[line]), p_len[line], file)) \n write_fatal (); \n return after_newline; \n }",
  "cwe": "CWE-119",
  "codeline": "bool after_newline = p_line[line][p_len[line] - 1] == '\\n';"
}
{
  "idx": 21,
  "target": 1,
  "vul": "void EC_GROUP_clear_free(EC_GROUP *group) \n { \n if (!group) return; \n if (group->meth->group_clear_finish != 0) \n group->meth->group_clear_finish(group); \n else if (group->meth->group_finish != 0) \n group->meth->group_finish(group); \n EC_EX_DATA_clear_free_all_data(&group->extra_data); \n if (group->generator != NULL) \n EC_EX_DATA_clear_free_all_data(&group->extra_data); \n if (group->generator != NULL) \n EC_POINT_clear_free(group->generator); \n BN_clear_free(&group->order); \n OPENSSL_cleanse(group, sizeof *group); \n OPENSSL_free(group); \n }",
  "no_vul": "void EC_GROUP_clear_free(EC_GROUP *group) \n { \n if (!group) return; \n if (group->meth->group_clear_finish != 0) \n group->meth->group_clear_finish(group); \n else if (group->meth->group_finish != 0) \n group->meth->group_finish(group); \n EC_EX_DATA_clear_free_all_data(&group->extra_data); \n if (group->generator != NULL) \n EC_EX_DATA_clear_free_all_data(&group->extra_data); \n if (group->mont_data) \n BN_MONT_CTX_free(group->mont_data); \n if (group->generator != NULL) \n EC_POINT_clear_free(group->generator); \n BN_clear_free(&group->order); \n OPENSSL_cleanse(group, sizeof *group); \n OPENSSL_free(group); \n }",
  "cwe": "CWE-320",
  "codeline": "if (group->generator != NULL) \n EC_EX_DATA_clear_free_all_data(&group->extra_data);"
}
{
  "idx": 22,
  "target": 1,
  "vul": "create_response(const char *nurl, const char *method, unsigned int *rp_code) \n { \n char *page, *fpath; \n struct MHD_Response *resp = NULL; \n if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) { \n resp = create_response_api(nurl, method, rp_code); \n } else { \n fpath = get_path(nurl, server_data.www_dir); \n resp = create_response_file(nurl, method, rp_code, fpath); \n free(fpath); \n } \n }",
  "no_vul": "create_response(const char *nurl, const char *method, unsigned int *rp_code) \n { \n char *page, *fpath, *rpath; \n struct MHD_Response *resp = NULL; \n int n; \n if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) { \n resp = create_response_api(nurl, method, rp_code); \n } else { \n fpath = get_path(nurl, server_data.www_dir); \n rpath = realpath(fpath, NULL); \n if (rpath) { \n n = strlen(server_data.www_dir); \n if (!strncmp(server_data.www_dir, rpath, n)) \n resp = create_response_file(nurl, \n method, \n rp_code, \n fpath); \n free(rpath); \n } \n free(fpath); \n } \n }",
  "cwe": "CWE-22",
  "codeline": "fpath = get_path(nurl, server_data.www_dir);"
}
{
  "idx": 23,
  "target": 1,
  "vul": "static int do_siocgstamp(struct net *net, struct socket *sock, \n unsigned int cmd, void __user *up) \n { \n mm_segment_t old_fs = get_fs(); \n struct timeval ktv; \n int err; \n set_fs(KERNEL_DS); \n err = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv); \n set_fs(old_fs); \n if (!err) \n err = compat_put_timeval(up, &ktv); \n return err; \n }",
  "no_vul": "static int do_siocgstampns(struct net *net, struct socket *sock, \n unsigned int cmd, void __user *up) \n { \n mm_segment_t old_fs = get_fs(); \n struct timespec kts; \n int err; \n set_fs(KERNEL_DS); \n err = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts); \n set_fs(old_fs); \n if (!err) \n err = compat_put_timespec(&kts, up); \n return err; \n }",
  "cwe": "CWE-399",
  "codeline": "err = compat_put_timeval(up, &ktv);"
}
{
  "idx": 24,
  "target": 1,
  "vul": "static int do_siocgstampns(struct net *net, struct socket *sock, \n unsigned int cmd, void __user *up) \n { \n mm_segment_t old_fs = get_fs(); \n struct timespec kts; \n int err; \n set_fs(KERNEL_DS); \n err = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts); \n set_fs(old_fs); \n if (!err) \n err = compat_put_timespec(up, &kts); \n return err; \n }",
  "no_vul": "static int do_siocgstampns(struct net *net, struct socket *sock, \n unsigned int cmd, void __user *up) \n { \n mm_segment_t old_fs = get_fs(); \n struct timespec kts; \n int err; \n set_fs(KERNEL_DS); \n err = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts); \n set_fs(old_fs); \n if (!err) \n err = compat_put_timespec(&kts, up); \n return err; \n }",
  "cwe": "CWE-399",
  "codeline": "err = compat_put_timespec(up, &kts);"
}
{
  "idx": 25,
  "target": 1,
  "vul": "static int xfrm6_tunnel_rcv(struct sk_buff *skb) \n { \n struct ipv6hdr *iph = ipv6_hdr(skb); \n __be32 spi; \n spi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr); \n return xfrm6_rcv_spi(skb, spi); \n }",
  "no_vul": "static int xfrm6_tunnel_rcv(struct sk_buff *skb) \n { \n struct ipv6hdr *iph = ipv6_hdr(skb); \n __be32 spi; \n spi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr); \n return xfrm6_rcv_spi(skb, spi) > 0 ? : 0; \n }",
  "cwe": "CWE-399",
  "codeline": "return xfrm6_rcv_spi(skb, spi);"
}
{
  "idx": 26,
  "target": 1,
  "vul": "static void kiocb_batch_free(struct kiocb_batch *batch) \n { \n struct kiocb *req, *n; \n list_for_each_entry_safe(req, n, &batch->head, ki_batch) { \n list_del(&req->ki_batch); \n kmem_cache_free(kiocb_cachep, req); \n } \n }",
  "no_vul": "static void kiocb_batch_free(struct kiocb_batch *batch) \n static void kiocb_batch_free(struct kioctx *ctx, struct kiocb_batch *batch) \n { \n struct kiocb *req, *n; \n if (list_empty(&batch->head)) \n return; \n spin_lock_irq(&ctx->ctx_lock); \n list_for_each_entry_safe(req, n, &batch->head, ki_batch) { \n list_del(&req->ki_batch); \n list_del(&req->ki_list); \n kmem_cache_free(kiocb_cachep, req); \n ctx->reqs_active--; \n } \n spin_unlock_irq(&ctx->ctx_lock); \n }",
  "cwe": "CWE-399",
  "codeline": "list_del(&req->ki_batch);"
}
{
  "idx": 27,
  "target": 1,
  "vul": "static void encode_share_access(struct xdr_stream *xdr, int open_flags) \n { \n __be32 *p; \n RESERVE_SPACE(8); \n switch (open_flags & (FMODE_READ|FMODE_WRITE)) { \n case FMODE_READ: \n WRITE32(NFS4_SHARE_ACCESS_READ); \n break; \n case FMODE_WRITE: \n WRITE32(NFS4_SHARE_ACCESS_WRITE); \n break; \n case FMODE_READ|FMODE_WRITE: \n WRITE32(NFS4_SHARE_ACCESS_BOTH); \n break; \n default: \n BUG(); \n } \n WRITE32(0); \n }",
  "no_vul": "static void encode_share_access(struct xdr_stream *xdr, int open_flags) \n static void encode_share_access(struct xdr_stream *xdr, fmode_t fmode) \n { \n __be32 *p; \n RESERVE_SPACE(8); \n switch (fmode & (FMODE_READ|FMODE_WRITE)) { \n case FMODE_READ: \n WRITE32(NFS4_SHARE_ACCESS_READ); \n break; \n case FMODE_WRITE: \n WRITE32(NFS4_SHARE_ACCESS_WRITE); \n break; \n case FMODE_READ|FMODE_WRITE: \n WRITE32(NFS4_SHARE_ACCESS_BOTH); \n break; \n default: \n WRITE32(0); \n } \n WRITE32(0); \n }",
  "cwe": "CWE-703",
  "codeline": "BUG();"
}
{
  "idx": 28,
  "target": 1,
  "vul": "static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry, \n char *args, int lsm_rule, int audit_type) \n { \n int result; \n if (entry->lsm[lsm_rule].rule) \n return -EINVAL; \n entry->lsm[lsm_rule].type = audit_type; \n result = security_filter_rule_init(entry->lsm[lsm_rule].type, \n Audit_equal, args, \n &entry->lsm[lsm_rule].rule); \n return result; \n }",
  "no_vul": "static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry, \n char *args, int lsm_rule, int audit_type) \n { \n int result; \n if (entry->lsm[lsm_rule].rule) \n return -EINVAL; \n entry->lsm[lsm_rule].type = audit_type; \n result = security_filter_rule_init(entry->lsm[lsm_rule].type, \n Audit_equal, args, \n &entry->lsm[lsm_rule].rule); \n if (!entry->lsm[lsm_rule].rule) \n return -EINVAL; \n return result; \n }",
  "cwe": "CWE-264",
  "codeline": "if (entry->lsm[lsm_rule].rule) \n return -EINVAL;"
}
{
  "idx": 29,
  "target": 1,
  "vul": "setup_server_realm(krb5_principal sprinc) \n { \n krb5_error_code kret; \n kdc_realm_t *newrealm; \n kret = 0; \n if (kdc_numrealms > 1) { \n if (!(newrealm = find_realm_data(sprinc->realm.data, \n (krb5_ui_4) sprinc->realm.length))) \n kret = ENOENT; \n else \n kdc_active_realm = newrealm; \n } \n else \n kdc_active_realm = kdc_realmlist[0]; \n return(kret); \n }",
  "no_vul": "setup_server_realm(krb5_principal sprinc) \n { \n krb5_error_code kret; \n kdc_realm_t *newrealm; \n kret = 0; \n if (sprinc == NULL) \n return NULL; \n if (kdc_numrealms > 1) { \n if (!(newrealm = find_realm_data(sprinc->realm.data, \n (krb5_ui_4) sprinc->realm.length))) \n kret = ENOENT; \n else \n kdc_active_realm = newrealm; \n } \n else \n kdc_active_realm = kdc_realmlist[0]; \n return(kret); \n }",
  "cwe": "CWE-703",
  "codeline": "if (!(newrealm = find_realm_data(sprinc->realm.data, \n (krb5_ui_4) sprinc->realm.length)))"
}
{
  "idx": 30,
  "target": 1,
  "vul": "static int uio_mmap_physical(struct vm_area_struct *vma) \n { \n struct uio_device *idev = vma->vm_private_data; \n int mi = uio_find_mem_index(vma); \n if (mi < 0) \n return -EINVAL; \n vma->vm_ops = &uio_physical_vm_ops; \n vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot); \n return remap_pfn_range(vma, \n vma->vm_start, \n idev->info->mem[mi].addr >> PAGE_SHIFT, \n vma->vm_end - vma->vm_start, \n vma->vm_page_prot); \n }",
  "no_vul": "static int uio_mmap_physical(struct vm_area_struct *vma) \n { \n struct uio_device *idev = vma->vm_private_data; \n int mi = uio_find_mem_index(vma); \n struct uio_mem *mem; \n if (mi < 0) \n return -EINVAL; \n mem = idev->info->mem + mi; \n if (vma->vm_end - vma->vm_start > mem->size) \n return -EINVAL; \n vma->vm_ops = &uio_physical_vm_ops; \n vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot); \n return remap_pfn_range(vma, \n vma->vm_start, \n mem->addr >> PAGE_SHIFT, \n vma->vm_end - vma->vm_start, \n vma->vm_page_prot); \n }",
  "cwe": "CWE-119",
  "codeline": "vma->vm_end - vma->vm_start, \nvma->vm_page_prot);"
}
{
  "idx": 31,
  "target": 1,
  "vul": "static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg) \n { \n struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata; \n return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg); \n }",
  "no_vul": "static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg) \n { \n struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata; \n if (!capable(CAP_SYS_RAWIO)) \n return -EPERM; \n return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg); \n }",
  "cwe": "CWE-264",
  "codeline": "return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);"
}
{
  "idx": 32,
  "target": 1,
  "vul": "void ipc_rcu_putref(void *ptr) \n { \n if (--container_of(ptr, struct ipc_rcu_hdr, data)->refcount > 0) \n return; \n if (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) { \n call_rcu(&container_of(ptr, struct ipc_rcu_grace, data)->rcu, \n ipc_schedule_free); \n } else { \n kfree_rcu(container_of(ptr, struct ipc_rcu_grace, data), rcu); \n } \n }",
  "no_vul": "void ipc_rcu_putref(void *ptr) \n { \n if (!atomic_dec_and_test(&container_of(ptr, struct ipc_rcu_hdr, data)->refcount)) \n return; \n if (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) { \n call_rcu(&container_of(ptr, struct ipc_rcu_grace, data)->rcu, \n ipc_schedule_free); \n } else { \n kfree_rcu(container_of(ptr, struct ipc_rcu_grace, data), rcu); \n } \n }",
  "cwe": "CWE-189",
  "codeline": "if (--container_of(ptr, struct ipc_rcu_hdr, data)->refcount > 0)"
}
{
  "idx": 33,
  "target": 1,
  "vul": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size) \n { \n void **ptrptr = ptr; \n *ptrptr = av_realloc_f(*ptrptr, nmemb, size); \n if (!*ptrptr && !(nmemb && size)) \n return AVERROR(ENOMEM); \n return 0; \n }",
  "no_vul": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size) \n { \n void **ptrptr = ptr; \n *ptrptr = av_realloc_f(*ptrptr, nmemb, size); \n if (!*ptrptr && nmemb && size) \n return AVERROR(ENOMEM); \n return 0; \n }",
  "cwe": "CWE-476",
  "codeline": "if (!*ptrptr && !(nmemb && size))"
}
{
  "idx": 34,
  "target": 1,
  "vul": "validate_event(struct pmu_hw_events *hw_events, \n struct perf_event *event) \n { \n struct arm_pmu *armpmu = to_arm_pmu(event->pmu); \n struct pmu *leader_pmu = event->group_leader->pmu; \n if (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF) \n return 1; \n if (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec) \n return 1; \n return armpmu->get_event_idx(hw_events, event) >= 0; \n }",
  "no_vul": "validate_event(struct pmu_hw_events *hw_events, \n struct perf_event *event) \n { \n struct arm_pmu *armpmu = to_arm_pmu(event->pmu); \n struct pmu *leader_pmu = event->group_leader->pmu; \n if (is_software_event(event)) \n return 1; \n if (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF) \n return 1; \n if (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec) \n return 1; \n return armpmu->get_event_idx(hw_events, event) >= 0; \n }",
  "cwe": "CWE-20",
  "codeline": "if (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF) \n return 1;"
}
{
  "idx": 35,
  "target": 1,
  "vul": "asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr) \n { \n console_verbose(); \n pr_crit(\"Bad mode in %s handler detected, code 0x%08x\\n\", \n handler[reason], esr); \n die(\"Oops - bad mode\", regs, 0); \n local_irq_disable(); \n panic(\"bad mode\"); \n }",
  "no_vul": "asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr) \n { \n siginfo_t info; \n void __user *pc = (void __user *)instruction_pointer(regs); \n console_verbose(); \n pr_crit(\"Bad mode in %s handler detected, code 0x%08x\\n\", \n handler[reason], esr); \n __show_regs(regs); \n info.si_signo = SIGILL; \n info.si_errno = 0; \n info.si_code = ILL_ILLOPC; \n info.si_addr = pc; \n arm64_notify_die(\"Oops - bad mode\", regs, &info, 0); \n }",
  "cwe": "CWE-703",
  "codeline": "panic(\"bad mode\");"
}
{
  "idx": 36,
  "target": 1,
  "vul": "ftrace_regex_lseek(struct file *file, loff_t offset, int whence) \n { \n loff_t ret; \n if (file->f_mode & FMODE_READ) \n ret = seq_lseek(file, offset, whence); \n else \n file->f_pos = ret = 1; \n return ret; \n }",
  "no_vul": "ftrace_regex_lseek(struct file *file, loff_t offset, int whence) \n ftrace_filter_lseek(struct file *file, loff_t offset, int whence) \n { \n loff_t ret; \n if (file->f_mode & FMODE_READ) \n ret = seq_lseek(file, offset, whence); \n else \n file->f_pos = ret = 1; \n return ret; \n }",
  "cwe": "CWE-703",
  "codeline": "file->f_pos = ret = 1;"
}
{
  "idx": 37,
  "target": 1,
  "vul": "static int do_tkill(pid_t tgid, pid_t pid, int sig) \n { \n struct siginfo info; \n info.si_signo = sig; \n info.si_errno = 0; \n info.si_code = SI_TKILL; \n info.si_pid = task_tgid_vnr(current); \n info.si_uid = from_kuid_munged(current_user_ns(), current_uid()); \n return do_send_specific(tgid, pid, sig, &info); \n }",
  "no_vul": "SYSCALL_DEFINE2(kill, pid_t, pid, int, sig) \n { \n struct siginfo info; \n info.si_signo = sig; \n info.si_errno = 0; \n info.si_code = SI_USER; \n info.si_pid = task_tgid_vnr(current); \n info.si_uid = from_kuid_munged(current_user_ns(), current_uid()); \n return kill_something_info(sig, &info, pid); \n }",
  "cwe": "CWE-399",
  "codeline": "info.si_code = SI_TKILL;"
}
{
  "idx": 38,
  "target": 1,
  "vul": "static struct sk_buff *xfrm_state_netlink(struct sk_buff *in_skb, \n struct xfrm_state *x, u32 seq) \n { \n struct xfrm_dump_info info; \n struct sk_buff *skb; \n skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC); \n if (!skb) \n return ERR_PTR(-ENOMEM); \n info.in_skb = in_skb; \n info.out_skb = skb; \n info.nlmsg_seq = seq; \n info.nlmsg_flags = 0; \n if (dump_one_state(x, 0, &info)) { \n kfree_skb(skb); \n return NULL; \n } \n return skb; \n }",
  "no_vul": "static struct sk_buff *xfrm_policy_netlink(struct sk_buff *in_skb, \n struct xfrm_policy *xp, \n int dir, u32 seq) \n { \n struct xfrm_dump_info info; \n struct sk_buff *skb; \n skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL); \n if (!skb) \n return ERR_PTR(-ENOMEM); \n info.in_skb = in_skb; \n info.out_skb = skb; \n info.nlmsg_seq = seq; \n info.nlmsg_flags = 0; \n if (dump_one_policy(xp, dir, 0, &info) < 0) { \n kfree_skb(skb); \n return NULL; \n } \n return skb; \n }",
  "cwe": "CWE-703",
  "codeline": "if (dump_one_state(x, 0, &info)) {"
}
{
  "idx": 39,
  "target": 1,
  "vul": "void receive_tcppacket(connection_t *c, const char *buffer, int len) { \n vpn_packet_t outpkt; \n outpkt.len = len; \n if(c->options & OPTION_TCPONLY) \n outpkt.priority = 0; \n else \n outpkt.priority = -1; \n memcpy(outpkt.data, buffer, len); \n receive_packet(c->node, &outpkt); \n }",
  "no_vul": "void receive_tcppacket(connection_t *c, const char *buffer, int len) { \n vpn_packet_t outpkt; \n if(len > sizeof outpkt.data) \n return; \n outpkt.len = len; \n if(c->options & OPTION_TCPONLY) \n outpkt.priority = 0; \n else \n outpkt.priority = -1; \n memcpy(outpkt.data, buffer, len); \n receive_packet(c->node, &outpkt); \n }",
  "cwe": "CWE-119",
  "codeline": "memcpy(outpkt.data, buffer, len);"
}
{
  "idx": 40,
  "target": 1,
  "vul": "flush_signal_handlers(struct task_struct *t, int force_default) \n { \n int i; \n struct k_sigaction *ka = &t->sighand->action[0]; \n for (i = _NSIG ; i != 0 ; i--) { \n if (force_default || ka->sa.sa_handler != SIG_IGN) \n ka->sa.sa_handler = SIG_DFL; \n ka->sa.sa_flags = 0; \n sigemptyset(&ka->sa.sa_mask); \n ka++; \n } \n }",
  "no_vul": "flush_signal_handlers(struct task_struct *t, int force_default) \n { \n int i; \n struct k_sigaction *ka = &t->sighand->action[0]; \n for (i = _NSIG ; i != 0 ; i--) { \n if (force_default || ka->sa.sa_handler != SIG_IGN) \n ka->sa.sa_handler = SIG_DFL; \n ka->sa.sa_flags = 0; \n #ifdef SA_RESTORER \n ka->sa.sa_restorer = NULL; \n #endif \n sigemptyset(&ka->sa.sa_mask); \n ka++; \n } \n }",
  "cwe": "CWE-264",
  "codeline": "ka->sa.sa_restorer = NULL;"
}
{
  "idx": 41,
  "target": 1,
  "vul": "static int msr_open(struct inode *inode, struct file *file) \n { \n unsigned int cpu; \n struct cpuinfo_x86 *c; \n cpu = iminor(file->f_path.dentry->d_inode); \n if (cpu >= nr_cpu_ids || !cpu_online(cpu)) \n return -ENXIO; \n c = &cpu_data(cpu); \n if (!cpu_has(c, X86_FEATURE_MSR)) \n return -EIO; \n return 0; \n }",
  "no_vul": "static int msr_open(struct inode *inode, struct file *file) \n { \n unsigned int cpu; \n struct cpuinfo_x86 *c; \n if (!capable(CAP_SYS_RAWIO)) \n return -EPERM; \n cpu = iminor(file->f_path.dentry->d_inode); \n if (cpu >= nr_cpu_ids || !cpu_online(cpu)) \n return -ENXIO; \n c = &cpu_data(cpu); \n if (!cpu_has(c, X86_FEATURE_MSR)) \n return -EIO; \n return 0; \n }",
  "cwe": "CWE-264",
  "codeline": "if (cpu >= nr_cpu_ids || !cpu_online(cpu)) \n return -ENXIO;"
}
{
  "idx": 42,
  "target": 1,
  "vul": "_archive_write_data(struct archive *_a, const void *buff, size_t s) \n { \n struct archive_write *a = (struct archive_write *)_a; \n archive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC, \n ARCHIVE_STATE_DATA, \"archive_write_data\"); \n archive_clear_error(&a->archive); \n return ((a->format_write_data)(a, buff, s)); \n }",
  "no_vul": "_archive_write_data(struct archive *_a, const void *buff, size_t s) \n { \n struct archive_write *a = (struct archive_write *)_a; \n const size_t max_write = INT_MAX; \n archive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC, \n ARCHIVE_STATE_DATA, \"archive_write_data\"); \n if (s > max_write) \n s = max_write; \n archive_clear_error(&a->archive); \n return ((a->format_write_data)(a, buff, s)); \n }",
  "cwe": "CWE-189",
  "codeline": "if (s > max_write) \ns = max_write;"
}
{
  "idx": 43,
  "target": 1,
  "vul": "static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p) \n { \n memcpy(&p->id, &x->id, sizeof(p->id)); \n memcpy(&p->sel, &x->sel, sizeof(p->sel)); \n memcpy(&p->lft, &x->lft, sizeof(p->lft)); \n memcpy(&p->curlft, &x->curlft, sizeof(p->curlft)); \n memcpy(&p->stats, &x->stats, sizeof(p->stats)); \n memcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr)); \n p->mode = x->props.mode; \n p->replay_window = x->props.replay_window; \n p->reqid = x->props.reqid; \n p->family = x->props.family; \n p->flags = x->props.flags; \n p->seq = x->km.seq; \n }",
  "no_vul": "static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p) \n { \n memset(p, 0, sizeof(*p)); \n memcpy(&p->id, &x->id, sizeof(p->id)); \n memcpy(&p->sel, &x->sel, sizeof(p->sel)); \n memcpy(&p->lft, &x->lft, sizeof(p->lft)); \n memcpy(&p->curlft, &x->curlft, sizeof(p->curlft)); \n memcpy(&p->stats, &x->stats, sizeof(p->stats)); \n memcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr)); \n p->mode = x->props.mode; \n p->replay_window = x->props.replay_window; \n p->reqid = x->props.reqid; \n p->family = x->props.family; \n p->flags = x->props.flags; \n p->seq = x->km.seq; \n }",
  "cwe": "CWE-200",
  "codeline": "memcpy(&p->id, &x->id, sizeof(p->id));"
}
{
  "idx": 44,
  "target": 1,
  "vul": "void dev_load(struct net *net, const char *name) \n { \n struct net_device *dev; \n rcu_read_lock(); \n dev = dev_get_by_name_rcu(net, name); \n rcu_read_unlock(); \n if (!dev && capable(CAP_NET_ADMIN)) \n request_module(\"%s\", name); \n }",
  "no_vul": "void dev_load(struct net *net, const char *name) \n { \n struct net_device *dev; \n int no_module; \n rcu_read_lock(); \n dev = dev_get_by_name_rcu(net, name); \n rcu_read_unlock(); \n no_module = !dev; \n if (no_module && capable(CAP_NET_ADMIN)) \n no_module = request_module(\"netdev-%s\", name); \n if (no_module && capable(CAP_SYS_MODULE)) { \n if (!request_module(\"%s\", name)) \n pr_err(\"Loading kernel module for a network device \" \n \"with CAP_SYS_MODULE (deprecated). Use CAP_NET_ADMIN and alias netdev-%s \" \n \"instead\\n\", name); \n } \n }",
  "cwe": "CWE-264",
  "codeline": "if (!dev && capable(CAP_NET_ADMIN)) \nrequest_module(\"%s\", name);"
}
{
  "idx": 45,
  "target": 1,
  "vul": "static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd) \n { \n struct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv; \n u8 b[] = { 0x00, 0xff, 0x00, 0x00, \n 0x00, 0x00, 0x00, 0x00, \n 0x00, 0x00 }; \n memcpy(&b[4], cmd->msg, cmd->msg_len); \n state->config->send_command(fe, 0x72, \n sizeof(b) - (6 - cmd->msg_len), b, \n NULL, NULL); \n return 0; \n }",
  "no_vul": "static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd) \n { \n struct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv; \n u8 b[] = { 0x00, 0xff, 0x00, 0x00, \n 0x00, 0x00, 0x00, 0x00, \n 0x00, 0x00 }; \n if (cmd->msg_len > sizeof(b) - 4) \n return -EINVAL; \n memcpy(&b[4], cmd->msg, cmd->msg_len); \n state->config->send_command(fe, 0x72, \n sizeof(b) - (6 - cmd->msg_len), b, \n NULL, NULL); \n return 0; \n }",
  "cwe": "CWE-119",
  "codeline": "memcpy(&b[4], cmd->msg, cmd->msg_len);"
}
{
  "idx": 46,
  "target": 1,
  "vul": "static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc, \n unsigned int *rsize) \n { \n if (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) { \n hid_info(hdev, \"fixing up Cherry Cymotion report descriptor\\n\"); \n rdesc[11] = rdesc[16] = 0xff; \n rdesc[12] = rdesc[17] = 0x03; \n } \n return rdesc; \n }",
  "no_vul": "static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc, \n unsigned int *rsize) \n { \n if (*rsize >= 18 && rdesc[11] == 0x3c && rdesc[12] == 0x02) { \n hid_info(hdev, \"fixing up Cherry Cymotion report descriptor\\n\"); \n rdesc[11] = rdesc[16] = 0xff; \n rdesc[12] = rdesc[17] = 0x03; \n } \n return rdesc; \n }",
  "cwe": "CWE-119",
  "codeline": "if (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {"
}
{
  "idx": 47,
  "target": 1,
  "vul": "static __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc, \n unsigned int *rsize) \n { \n if (*rsize >= 30 && rdesc[29] == 0x05 && rdesc[30] == 0x09) { \n hid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\"); \n rdesc[30] = 0x0c; \n } \n return rdesc; \n }",
  "no_vul": "static __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc, \n unsigned int *rsize) \n { \n if (*rsize >= 31 && rdesc[29] == 0x05 && rdesc[30] == 0x09) { \n hid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\"); \n rdesc[30] = 0x0c; \n } \n return rdesc; \n }",
  "cwe": "CWE-119",
  "codeline": "if (*rsize >= 30 && rdesc[29] == 0x05 && rdesc[30] == 0x09) {"
}
{
  "idx": 48,
  "target": 1,
  "vul": "static __u8 *sp_report_fixup(struct hid_device *hdev, __u8 *rdesc, \n unsigned int *rsize) \n { \n if (*rsize >= 107 && rdesc[104] == 0x26 && rdesc[105] == 0x80 && \n rdesc[106] == 0x03) { \n hid_info(hdev, \"fixing up Sunplus Wireless Desktop report descriptor\\n\"); \n rdesc[105] = rdesc[110] = 0x03; \n rdesc[106] = rdesc[111] = 0x21; \n } \n return rdesc; \n }",
  "no_vul": "static __u8 *sp_report_fixup(struct hid_device *hdev, __u8 *rdesc, \n unsigned int *rsize) \n { \n if (*rsize >= 112 && rdesc[104] == 0x26 && rdesc[105] == 0x80 && \n rdesc[106] == 0x03) { \n hid_info(hdev, \"fixing up Sunplus Wireless Desktop report descriptor\\n\"); \n rdesc[105] = rdesc[110] = 0x03; \n rdesc[106] = rdesc[111] = 0x21; \n } \n return rdesc; \n }",
  "cwe": "CWE-119",
  "codeline": "if (*rsize >= 107 && rdesc[104] == 0x26 && rdesc[105] == 0x80 && \n rdesc[106] == 0x03) {"
}
{
  "idx": 49,
  "target": 1,
  "vul": "int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src) \n { \n flush_fp_to_thread(src); \n flush_altivec_to_thread(src); \n flush_vsx_to_thread(src); \n flush_spe_to_thread(src); \n *dst = *src; \n clear_task_ebb(dst); \n return 0; \n }",
  "no_vul": "int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src) \n { \n flush_fp_to_thread(src); \n flush_altivec_to_thread(src); \n flush_vsx_to_thread(src); \n flush_spe_to_thread(src); \n __switch_to_tm(src); \n tm_recheckpoint_new_task(src); \n *dst = *src; \n clear_task_ebb(dst); \n return 0; \n }",
  "cwe": "CWE-20",
  "codeline": "*dst = *src;"
}
{
  "idx": 50,
  "target": 1,
  "vul": "static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode) \n { \n if (file->f_flags & O_DSYNC) \n return 0; \n if (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE)) \n return 1; \n if (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL || \n (inode->i_flock->fl_start == 0 && \n inode->i_flock->fl_end == OFFSET_MAX && \n inode->i_flock->fl_type != F_RDLCK))) \n return 1; \n return 0; \n }",
  "no_vul": "static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode) \n { \n if (file->f_flags & O_DSYNC) \n return 0; \n if (!nfs_write_pageuptodate(page, inode)) \n return 0; \n if (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE)) \n return 1; \n if (inode->i_flock == NULL || (inode->i_flock->fl_start == 0 && \n inode->i_flock->fl_end == OFFSET_MAX && \n inode->i_flock->fl_type != F_RDLCK)) \n return 1; \n return 0; \n }",
  "cwe": "CWE-20",
  "codeline": "if (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL || \n (inode->i_flock->fl_start == 0 && \n inode->i_flock->fl_end == OFFSET_MAX && \n inode->i_flock->fl_type != F_RDLCK))) \n return 1;"
}
{
  "idx": 51,
  "target": 1,
  "vul": "int ovl_setattr(struct dentry *dentry, struct iattr *attr) \n { \n int err; \n struct dentry *upperdentry; \n err = ovl_want_write(dentry); \n if (err) \n goto out; \n upperdentry = ovl_dentry_upper(dentry); \n if (upperdentry) { \n mutex_lock(&upperdentry->d_inode->i_mutex); \n err = notify_change(upperdentry, attr, NULL); \n mutex_unlock(&upperdentry->d_inode->i_mutex); \n } else { \n err = ovl_copy_up_last(dentry, attr, false); \n } \n ovl_drop_write(dentry); \n out: \n return err; \n }",
  "no_vul": "int ovl_setattr(struct dentry *dentry, struct iattr *attr) \n { \n int err; \n struct dentry *upperdentry; \n err = ovl_want_write(dentry); \n if (err) \n goto out; \n err = ovl_copy_up(dentry); \n if (!err) { \n upperdentry = ovl_dentry_upper(dentry); \n mutex_lock(&upperdentry->d_inode->i_mutex); \n err = notify_change(upperdentry, attr, NULL); \n mutex_unlock(&upperdentry->d_inode->i_mutex); \n } \n ovl_drop_write(dentry); \n out: \n return err; \n }",
  "cwe": "CWE-264",
  "codeline": "if (upperdentry) { \n mutex_lock(&upperdentry->d_inode->i_mutex); \n err = notify_change(upperdentry, attr, NULL); \n mutex_unlock(&upperdentry->d_inode->i_mutex); \n } else { \n err = ovl_copy_up_last(dentry, attr, false); \n }"
}
{
  "idx": 52,
  "target": 1,
  "vul": "mm_answer_pam_free_ctx(int sock, Buffer *m) \n { \n debug3(\"%s\", __func__); \n (sshpam_device.free_ctx)(sshpam_ctxt); \n buffer_clear(m); \n mm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m); \n auth_method = \"keyboard-interactive\"; \n auth_submethod = \"pam\"; \n return (sshpam_authok == sshpam_ctxt); \n }",
  "no_vul": "mm_answer_pam_free_ctx(int sock, Buffer *m) \n { \n int r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt; \n debug3(\"%s\", __func__); \n (sshpam_device.free_ctx)(sshpam_ctxt); \n sshpam_ctxt = sshpam_authok = NULL; \n buffer_clear(m); \n mm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m); \n auth_method = \"keyboard-interactive\"; \n auth_submethod = \"pam\"; \n return r; \n }",
  "cwe": "CWE-264",
  "codeline": "return (sshpam_authok == sshpam_ctxt);"
}
{
  "idx": 53,
  "target": 1,
  "vul": "mm_sshpam_init_ctx(Authctxt *authctxt) \n { \n Buffer m; \n int success; \n debug3(\"%s\", __func__); \n buffer_init(&m); \n buffer_put_cstring(&m, authctxt->user); \n mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_INIT_CTX, &m); \n debug3(\"%s: waiting for MONITOR_ANS_PAM_INIT_CTX\", __func__); \n mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PAM_INIT_CTX, &m); \n success = buffer_get_int(&m); \n if (success == 0) { \n debug3(\"%s: pam_init_ctx failed\", __func__); \n buffer_free(&m); \n return (NULL); \n } \n buffer_free(&m); \n return (authctxt); \n }",
  "no_vul": "mm_sshpam_init_ctx(Authctxt *authctxt) \n { \n Buffer m; \n int success; \n debug3(\"%s\", __func__); \n buffer_init(&m); \n mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_INIT_CTX, &m); \n debug3(\"%s: waiting for MONITOR_ANS_PAM_INIT_CTX\", __func__); \n mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PAM_INIT_CTX, &m); \n success = buffer_get_int(&m); \n if (success == 0) { \n debug3(\"%s: pam_init_ctx failed\", __func__); \n buffer_free(&m); \n return (NULL); \n } \n buffer_free(&m); \n return (authctxt); \n }",
  "cwe": "CWE-20",
  "codeline": "buffer_put_cstring(&m, authctxt->user);"
}
{
  "idx": 54,
  "target": 1,
  "vul": "void IGDstartelt(void * d, const char * name, int l) \n { \n struct IGDdatas * datas = (struct IGDdatas *)d; \n memcpy( datas->cureltname, name, l); \n datas->cureltname[l] = '\\0'; \n datas->level++; \n if( (l==7) && !memcmp(name, \"service\", l) ) { \n datas->tmp.controlurl[0] = '\\0'; \n datas->tmp.eventsuburl[0] = '\\0'; \n datas->tmp.scpdurl[0] = '\\0'; \n datas->tmp.servicetype[0] = '\\0'; \n } \n }",
  "no_vul": "void IGDstartelt(void * d, const char * name, int l) \n { \n struct IGDdatas * datas = (struct IGDdatas *)d; \n if(l >= MINIUPNPC_URL_MAXSIZE) \n l = MINIUPNPC_URL_MAXSIZE-1; \n memcpy(datas->cureltname, name, l); \n datas->cureltname[l] = '\\0'; \n datas->level++; \n if( (l==7) && !memcmp(name, \"service\", l) ) { \n datas->tmp.controlurl[0] = '\\0'; \n datas->tmp.eventsuburl[0] = '\\0'; \n datas->tmp.scpdurl[0] = '\\0'; \n datas->tmp.servicetype[0] = '\\0'; \n } \n }",
  "cwe": "CWE-119",
  "codeline": "memcpy( datas->cureltname, name, l);"
}
{
  "idx": 55,
  "target": 1,
  "vul": "iakerb_gss_export_sec_context(OM_uint32 *minor_status, \n gss_ctx_id_t *context_handle, \n gss_buffer_t interprocess_token) \n { \n OM_uint32 maj; \n iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle; \n if (!ctx->established) \n return GSS_S_UNAVAILABLE; \n maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc, \n interprocess_token); \n if (ctx->gssc == GSS_C_NO_CONTEXT) { \n iakerb_release_context(ctx); \n *context_handle = GSS_C_NO_CONTEXT; \n } \n return maj; \n }",
  "no_vul": "iakerb_gss_export_sec_context(OM_uint32 *minor_status, \n gss_ctx_id_t *context_handle, \n gss_buffer_t interprocess_token) \n { \n OM_uint32 maj; \n iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle; \n if (!ctx->established) \n return GSS_S_UNAVAILABLE; \n maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc, \n interprocess_token); \n if (ctx->gssc == GSS_C_NO_CONTEXT) { \n iakerb_release_context(ctx); \n *context_handle = GSS_C_NO_CONTEXT; \n } \n return maj; \n }",
  "cwe": "CWE-119",
  "codeline": "iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;"
}
{
  "idx": 56,
  "target": 1,
  "vul": "static unsigned int stack_maxrandom_size(void) \n { \n unsigned int max = 0; \n if ((current->flags & PF_RANDOMIZE) && \n !(current->personality & ADDR_NO_RANDOMIZE)) { \n max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT; \n } \n return max; \n }",
  "no_vul": "static unsigned int stack_maxrandom_size(void) \n static unsigned long stack_maxrandom_size(void) \n { \n unsigned long max = 0; \n if ((current->flags & PF_RANDOMIZE) && \n !(current->personality & ADDR_NO_RANDOMIZE)) { \n max = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT; \n } \n return max; \n }",
  "cwe": "CWE-264",
  "codeline": "unsigned int max = 0;"
}
{
  "idx": 57,
  "target": 1,
  "vul": "static unsigned long randomize_stack_top(unsigned long stack_top) \n { \n unsigned int random_variable = 0; \n if ((current->flags & PF_RANDOMIZE) && \n !(current->personality & ADDR_NO_RANDOMIZE)) { \n random_variable = get_random_int() & STACK_RND_MASK; \n random_variable <<= PAGE_SHIFT; \n } \n #ifdef CONFIG_STACK_GROWSUP \n return PAGE_ALIGN(stack_top) + random_variable; \n #else \n return PAGE_ALIGN(stack_top) - random_variable; \n #endif \n }",
  "no_vul": "static unsigned long randomize_stack_top(unsigned long stack_top) \n { \n unsigned long random_variable = 0; \n if ((current->flags & PF_RANDOMIZE) && \n !(current->personality & ADDR_NO_RANDOMIZE)) { \n random_variable = (unsigned long) get_random_int(); \n random_variable &= STACK_RND_MASK; \n random_variable <<= PAGE_SHIFT; \n } \n #ifdef CONFIG_STACK_GROWSUP \n return PAGE_ALIGN(stack_top) + random_variable; \n #else \n return PAGE_ALIGN(stack_top) - random_variable; \n #endif \n }",
  "cwe": "CWE-264",
  "codeline": "unsigned int random_variable = 0;"
}
{
  "idx": 58,
  "target": 1,
  "vul": "struct crypto_template *crypto_lookup_template(const char *name) \n { \n return try_then_request_module(__crypto_lookup_template(name), \"%s\", \n name); \n }",
  "no_vul": "struct crypto_template *crypto_lookup_template(const char *name) \n { \n return try_then_request_module(__crypto_lookup_template(name), \n \"crypto-%s\", name); \n }",
  "cwe": "CWE-264",
  "codeline": "return try_then_request_module(__crypto_lookup_template(name), \"%s\", \n name);"
}
{
  "idx": 59,
  "target": 1,
  "vul": "void snd_pcm_period_elapsed(struct snd_pcm_substream *substream) \n { \n struct snd_pcm_runtime *runtime; \n unsigned long flags; \n if (PCM_RUNTIME_CHECK(substream)) \n return; \n runtime = substream->runtime; \n snd_pcm_stream_lock_irqsave(substream, flags); \n if (!snd_pcm_running(substream) || \n snd_pcm_update_hw_ptr0(substream, 1) < 0) \n goto _end; \n #ifdef CONFIG_SND_PCM_TIMER \n if (substream->timer_running) \n snd_timer_interrupt(substream->timer, 1); \n #endif \n _end: \n snd_pcm_stream_unlock_irqrestore(substream, flags); \n kill_fasync(&runtime->fasync, SIGIO, POLL_IN); \n }",
  "no_vul": "void snd_pcm_period_elapsed(struct snd_pcm_substream *substream) \n { \n struct snd_pcm_runtime *runtime; \n unsigned long flags; \n if (PCM_RUNTIME_CHECK(substream)) \n return; \n runtime = substream->runtime; \n snd_pcm_stream_lock_irqsave(substream, flags); \n if (!snd_pcm_running(substream) || \n snd_pcm_update_hw_ptr0(substream, 1) < 0) \n goto _end; \n #ifdef CONFIG_SND_PCM_TIMER \n if (substream->timer_running) \n snd_timer_interrupt(substream->timer, 1); \n #endif \n _end: \n kill_fasync(&runtime->fasync, SIGIO, POLL_IN); \n snd_pcm_stream_unlock_irqrestore(substream, flags); \n }",
  "cwe": "CWE-416",
  "codeline": "snd_pcm_stream_unlock_irqrestore(substream, flags);"
}
{
  "idx": 60,
  "target": 1,
  "vul": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic) \n { \n ioapic->rtc_status.pending_eoi = 0; \n bitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS); \n }",
  "no_vul": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic) \n { \n ioapic->rtc_status.pending_eoi = 0; \n bitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPU_ID); \n }",
  "cwe": "CWE-125",
  "codeline": "bitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);"
}
{
  "idx": 61,
  "target": 1,
  "vul": "static unsigned int ipv6_defrag(void *priv, \n struct sk_buff *skb, \n const struct nf_hook_state *state) \n { \n int err; \n #if IS_ENABLED(CONFIG_NF_CONNTRACK) \n if (skb->nfct && !nf_ct_is_template((struct nf_conn *)skb->nfct)) \n return NF_ACCEPT; \n #endif \n err = nf_ct_frag6_gather(state->net, skb, \n nf_ct6_defrag_user(state->hook, skb)); \n if (err == -EINPROGRESS) \n return NF_STOLEN; \n return NF_ACCEPT; \n }",
  "no_vul": "static unsigned int ipv6_defrag(void *priv, \n struct sk_buff *skb, \n const struct nf_hook_state *state) \n { \n int err; \n #if IS_ENABLED(CONFIG_NF_CONNTRACK) \n if (skb->nfct && !nf_ct_is_template((struct nf_conn *)skb->nfct)) \n return NF_ACCEPT; \n #endif \n err = nf_ct_frag6_gather(state->net, skb, \n nf_ct6_defrag_user(state->hook, skb)); \n if (err == -EINPROGRESS) \n return NF_STOLEN; \n return err == 0 ? NF_ACCEPT : NF_DROP; \n }",
  "cwe": "CWE-787",
  "codeline": "return NF_ACCEPT;"
}
{
  "idx": 62,
  "target": 1,
  "vul": "Strgrow(Str x) \n { \n char *old = x->ptr; \n int newlen; \n newlen = x->length * 6 / 5; \n if (newlen == x->length) \n newlen += 2; \n x->ptr = GC_MALLOC_ATOMIC(newlen); \n x->area_size = newlen; \n bcopy((void *)old, (void *)x->ptr, x->length); \n GC_free(old); \n }",
  "no_vul": "Strgrow(Str x) \n { \n char *old = x->ptr; \n int newlen; \n newlen = x->area_size * 6 / 5; \n if (newlen == x->area_size) \n newlen += 2; \n x->ptr = GC_MALLOC_ATOMIC(newlen); \n x->area_size = newlen; \n bcopy((void *)old, (void *)x->ptr, x->length); \n GC_free(old); \n }",
  "cwe": "CWE-119",
  "codeline": "newlen = x->length * 6 / 5;"
}
{
  "idx": 63,
  "target": 1,
  "vul": "static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg) \n { \n struct usbdevfs_connectinfo ci = { \n .devnum = ps->dev->devnum, \n .slow = ps->dev->speed == USB_SPEED_LOW \n }; \n if (copy_to_user(arg, &ci, sizeof(ci))) \n return -EFAULT; \n return 0; \n }",
  "no_vul": "static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg) \n { \n struct usbdevfs_connectinfo ci; \n memset(&ci, 0, sizeof(ci)); \n ci.devnum = ps->dev->devnum; \n ci.slow = ps->dev->speed == USB_SPEED_LOW; \n if (copy_to_user(arg, &ci, sizeof(ci))) \n return -EFAULT; \n return 0; \n }",
  "cwe": "CWE-200",
  "codeline": "struct usbdevfs_connectinfo ci = { \n .devnum = ps->dev->devnum, \n .slow = ps->dev->speed == USB_SPEED_LOW \n };"
}
{
  "idx": 64,
  "target": 1,
  "vul": "static int digi_startup(struct usb_serial *serial) \n { \n struct digi_serial *serial_priv; \n int ret; \n serial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL); \n if (!serial_priv) \n return -ENOMEM; \n spin_lock_init(&serial_priv->ds_serial_lock); \n serial_priv->ds_oob_port_num = serial->type->num_ports; \n serial_priv->ds_oob_port = serial->port[serial_priv->ds_oob_port_num]; \n ret = digi_port_init(serial_priv->ds_oob_port, \n serial_priv->ds_oob_port_num); \n if (ret) { \n kfree(serial_priv); \n return ret; \n } \n usb_set_serial_data(serial, serial_priv); \n return 0; \n }",
  "no_vul": "static int digi_startup(struct usb_serial *serial) \n { \n struct device *dev = &serial->interface->dev; \n struct digi_serial *serial_priv; \n int ret; \n int i; \n if (serial->num_port_pointers < serial->type->num_ports + 1) { \n dev_err(dev, \"OOB endpoints missing\\n\"); \n return -ENODEV; \n } \n for (i = 0; i < serial->type->num_ports + 1 ; i++) { \n if (!serial->port[i]->read_urb) { \n dev_err(dev, \"bulk-in endpoint missing\\n\"); \n return -ENODEV; \n } \n if (!serial->port[i]->write_urb) { \n dev_err(dev, \"bulk-out endpoint missing\\n\"); \n return -ENODEV; \n } \n } \n serial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL); \n if (!serial_priv) \n return -ENOMEM; \n spin_lock_init(&serial_priv->ds_serial_lock); \n serial_priv->ds_oob_port_num = serial->type->num_ports; \n serial_priv->ds_oob_port = serial->port[serial_priv->ds_oob_port_num]; \n ret = digi_port_init(serial_priv->ds_oob_port, \n serial_priv->ds_oob_port_num); \n if (ret) { \n kfree(serial_priv); \n return ret; \n } \n usb_set_serial_data(serial, serial_priv); \n return 0; \n }",
  "cwe": "CWE-703",
  "codeline": "serial_priv->ds_oob_port = serial->port[serial_priv->ds_oob_port_num];"
}
{
  "idx": 65,
  "target": 1,
  "vul": "static int mct_u232_port_probe(struct usb_serial_port *port) \n { \n struct mct_u232_private *priv; \n priv = kzalloc(sizeof(*priv), GFP_KERNEL); \n if (!priv) \n return -ENOMEM; \n priv->read_urb = port->serial->port[1]->interrupt_in_urb; \n priv->read_urb->context = port; \n spin_lock_init(&priv->lock); \n usb_set_serial_port_data(port, priv); \n return 0; \n }",
  "no_vul": "static int mct_u232_port_probe(struct usb_serial_port *port) \n { \n struct usb_serial *serial = port->serial; \n struct mct_u232_private *priv; \n if (!serial->port[1] || !serial->port[1]->interrupt_in_urb) { \n dev_err(&port->dev, \"expected endpoint missing\\n\"); \n return -ENODEV; \n } \n priv = kzalloc(sizeof(*priv), GFP_KERNEL); \n if (!priv) \n return -ENOMEM; \n priv->read_urb = serial->port[1]->interrupt_in_urb; \n priv->read_urb->context = port; \n spin_lock_init(&priv->lock); \n usb_set_serial_port_data(port, priv); \n return 0; \n }",
  "cwe": "CWE-703",
  "codeline": "priv->read_urb = port->serial->port[1]->interrupt_in_urb;"
}
{
  "idx": 66,
  "target": 1,
  "vul": "static void queue_delete(struct snd_seq_queue *q) \n { \n snd_seq_timer_stop(q->timer); \n snd_seq_timer_close(q); \n snd_use_lock_sync(&q->use_lock); \n snd_seq_prioq_delete(&q->tickq); \n snd_seq_prioq_delete(&q->timeq); \n snd_seq_timer_delete(&q->timer); \n kfree(q); \n }",
  "no_vul": "static void queue_delete(struct snd_seq_queue *q) \n { \n mutex_lock(&q->timer_mutex); \n snd_seq_timer_stop(q->timer); \n snd_seq_timer_close(q); \n mutex_unlock(&q->timer_mutex); \n snd_use_lock_sync(&q->use_lock); \n snd_seq_prioq_delete(&q->tickq); \n snd_seq_prioq_delete(&q->timeq); \n snd_seq_timer_delete(&q->timer); \n kfree(q); \n }",
  "cwe": "CWE-362",
  "codeline": "snd_seq_timer_stop(q->timer);"
}
{
  "idx": 67,
  "target": 1,
  "vul": "static int pagemap_open(struct inode *inode, struct file *file) \n { \n pr_warn_once(\"Bits 55-60 of /proc/PID/pagemap entries are about \" \n \"to stop being page-shift some time soon. See the \" \n \"linux/Documentation/vm/pagemap.txt for details.\\n\"); \n return 0; \n }",
  "no_vul": "static int pagemap_open(struct inode *inode, struct file *file) \n { \n if (!capable(CAP_SYS_ADMIN)) \n return -EPERM; \n pr_warn_once(\"Bits 55-60 of /proc/PID/pagemap entries are about \" \n \"to stop being page-shift some time soon. See the \" \n \"linux/Documentation/vm/pagemap.txt for details.\\n\"); \n return 0; \n }",
  "cwe": "CWE-200",
  "codeline": "pr_warn_once(\"Bits 55-60 of /proc/PID/pagemap entries are about \" \n \"to stop being page-shift some time soon. See the \" \n \"linux/Documentation/vm/pagemap.txt for details.\\n\");"
}
{
  "idx": 68,
  "target": 1,
  "vul": "static void tokenadd(struct jv_parser* p, char c) { \n assert(p->tokenpos <= p->tokenlen); \n if (p->tokenpos == p->tokenlen) { \n p->tokenlen = p->tokenlen*2 + 256; \n p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen); \n } \n assert(p->tokenpos < p->tokenlen); \n p->tokenbuf[p->tokenpos++] = c; \n }",
  "no_vul": "static void tokenadd(struct jv_parser* p, char c) { \n assert(p->tokenpos <= p->tokenlen); \n if (p->tokenpos >= (p->tokenlen - 1)) { \n p->tokenlen = p->tokenlen*2 + 256; \n p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen); \n } \n assert(p->tokenpos < p->tokenlen); \n p->tokenbuf[p->tokenpos++] = c; \n }",
  "cwe": "CWE-119",
  "codeline": "if (p->tokenpos == p->tokenlen) {"
}
{
  "idx": 69,
  "target": 1,
  "vul": "static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps) \n { \n mutex_lock(&kvm->arch.vpit->pit_state.lock); \n memcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state)); \n kvm_pit_load_count(kvm, 0, ps->channels[0].count, 0); \n mutex_unlock(&kvm->arch.vpit->pit_state.lock); \n return 0; \n }",
  "no_vul": "static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps) \n { \n int i; \n mutex_lock(&kvm->arch.vpit->pit_state.lock); \n memcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state)); \n for (i = 0; i < 3; i++) \n kvm_pit_load_count(kvm, i, ps->channels[i].count, 0); \n mutex_unlock(&kvm->arch.vpit->pit_state.lock); \n return 0; \n }",
  "cwe": "CWE-369",
  "codeline": "kvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);"
}
{
  "idx": 70,
  "target": 1,
  "vul": "static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps) \n { \n int start = 0; \n u32 prev_legacy, cur_legacy; \n mutex_lock(&kvm->arch.vpit->pit_state.lock); \n prev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY; \n cur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY; \n if (!prev_legacy && cur_legacy) \n start = 1; \n memcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels, \n sizeof(kvm->arch.vpit->pit_state.channels)); \n kvm->arch.vpit->pit_state.flags = ps->flags; \n kvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start); \n mutex_unlock(&kvm->arch.vpit->pit_state.lock); \n return 0; \n }",
  "no_vul": "static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps) \n { \n int start = 0; \n int i; \n u32 prev_legacy, cur_legacy; \n mutex_lock(&kvm->arch.vpit->pit_state.lock); \n prev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY; \n cur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY; \n if (!prev_legacy && cur_legacy) \n start = 1; \n memcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels, \n sizeof(kvm->arch.vpit->pit_state.channels)); \n kvm->arch.vpit->pit_state.flags = ps->flags; \n for (i = 0; i < 3; i++) \n kvm_pit_load_count(kvm, i, kvm->arch.vpit->pit_state.channels[i].count, start); \n mutex_unlock(&kvm->arch.vpit->pit_state.lock); \n return 0; \n }",
  "cwe": "CWE-369",
  "codeline": "kvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);"
}
{
  "idx": 71,
  "target": 1,
  "vul": "struct vfsmount *collect_mounts(struct path *path) \n { \n struct mount *tree; \n namespace_lock(); \n tree = copy_tree(real_mount(path->mnt), path->dentry, \n CL_COPY_ALL | CL_PRIVATE); \n namespace_unlock(); \n if (IS_ERR(tree)) \n return ERR_CAST(tree); \n return &tree->mnt; \n }",
  "no_vul": "struct vfsmount *collect_mounts(struct path *path) \n { \n struct mount *tree; \n namespace_lock(); \n if (!check_mnt(real_mount(path->mnt))) \n tree = ERR_PTR(-EINVAL); \n else \n tree = copy_tree(real_mount(path->mnt), path->dentry, \n CL_COPY_ALL | CL_PRIVATE); \n namespace_unlock(); \n if (IS_ERR(tree)) \n return ERR_CAST(tree); \n return &tree->mnt; \n }",
  "cwe": "CWE-703",
  "codeline": "tree = copy_tree(real_mount(path->mnt), path->dentry, \n CL_COPY_ALL | CL_PRIVATE);"
}
{
  "idx": 72,
  "target": 1,
  "vul": "static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem) \n { \n long tmp = *old; \n *old = atomic_long_cmpxchg(&sem->count, *old, new); \n return *old == tmp; \n }",
  "no_vul": "static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem) \n { \n long tmp = atomic_long_cmpxchg(&sem->count, *old, new); \n if (tmp == *old) { \n *old = new; \n return 1; \n } else { \n *old = tmp; \n return 0; \n } \n }",
  "cwe": "CWE-362",
  "codeline": "*old = atomic_long_cmpxchg(&sem->count, *old, new);"
}
{
  "idx": 73,
  "target": 1,
  "vul": "kvm_irqfd(struct kvm *kvm, struct kvm_irqfd *args) \n { \n if (args->flags & ~(KVM_IRQFD_FLAG_DEASSIGN | KVM_IRQFD_FLAG_RESAMPLE)) \n return -EINVAL; \n if (args->flags & KVM_IRQFD_FLAG_DEASSIGN) \n return kvm_irqfd_deassign(kvm, args); \n return kvm_irqfd_assign(kvm, args); \n }",
  "no_vul": "kvm_irqfd(struct kvm *kvm, struct kvm_irqfd *args) \n { \n if (args->flags & ~(KVM_IRQFD_FLAG_DEASSIGN | KVM_IRQFD_FLAG_RESAMPLE)) \n return -EINVAL; \n if (args->gsi >= KVM_MAX_IRQ_ROUTES) \n return -EINVAL; \n if (args->flags & KVM_IRQFD_FLAG_DEASSIGN) \n return kvm_irqfd_deassign(kvm, args); \n return kvm_irqfd_assign(kvm, args); \n }",
  "cwe": "CWE-20",
  "codeline": "if (args->flags & ~(KVM_IRQFD_FLAG_DEASSIGN | KVM_IRQFD_FLAG_RESAMPLE)) \nreturn -EINVAL;"
}
{
  "idx": 74,
  "target": 1,
  "vul": "on_unregister_handler(TCMUService1HandlerManager1 *interface, \n GDBusMethodInvocation *invocation, \n gchar *subtype, \n gpointer user_data) \n { \n struct tcmur_handler *handler = find_handler_by_subtype(subtype); \n struct dbus_info *info = handler ? handler->opaque : NULL; \n if (!handler) { \n g_dbus_method_invocation_return_value(invocation, \n g_variant_new(\"(bs)\", FALSE, \n \"unknown subtype\")); \n return TRUE; \n } \n dbus_unexport_handler(handler); \n tcmur_unregister_handler(handler); \n g_bus_unwatch_name(info->watcher_id); \n g_free(info); \n g_free(handler); \n g_dbus_method_invocation_return_value(invocation, \n g_variant_new(\"(bs)\", TRUE, \"succeeded\")); \n return TRUE; \n }",
  "no_vul": "on_unregister_handler(TCMUService1HandlerManager1 *interface, \n GDBusMethodInvocation *invocation, \n gchar *subtype, \n gpointer user_data) \n { \n struct tcmur_handler *handler = find_handler_by_subtype(subtype); \n struct dbus_info *info = handler ? handler->opaque : NULL; \n if (!handler) { \n g_dbus_method_invocation_return_value(invocation, \n g_variant_new(\"(bs)\", FALSE, \n \"unknown subtype\")); \n return TRUE; \n } \n else if (handler->_is_dbus_handler != 1) { \n g_dbus_method_invocation_return_value(invocation, \n g_variant_new(\"(bs)\", FALSE, \n \"cannot unregister internal handler\")); \n return TRUE; \n } \n dbus_unexport_handler(handler); \n tcmur_unregister_dbus_handler(handler); \n g_bus_unwatch_name(info->watcher_id); \n g_free(info); \n g_free(handler); \n g_dbus_method_invocation_return_value(invocation, \n g_variant_new(\"(bs)\", TRUE, \"succeeded\")); \n return TRUE; \n }",
  "cwe": "CWE-476",
  "codeline": "tcmur_unregister_handler(handler);"
}
{
  "idx": 75,
  "target": 1,
  "vul": "static int snd_seq_device_dev_free(struct snd_device *device) \n { \n struct snd_seq_device *dev = device->device_data; \n put_device(&dev->dev); \n return 0; \n }",
  "no_vul": "static int snd_seq_device_dev_disconnect(struct snd_device *device) \n { \n struct snd_seq_device *dev = device->device_data; \n device_del(&dev->dev); \n return 0; \n }",
  "cwe": "CWE-416",
  "codeline": "put_device(&dev->dev);"
}
{
  "idx": 76,
  "target": 1,
  "vul": "static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed, \n unsigned int slen) \n { \n u8 *buf = NULL; \n u8 *src = (u8 *)seed; \n int err; \n if (slen) { \n buf = kmalloc(slen, GFP_KERNEL); \n if (!buf) \n return -ENOMEM; \n memcpy(buf, seed, slen); \n src = buf; \n } \n err = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen); \n kzfree(buf); \n return err; \n }",
  "no_vul": "int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen) \n { \n u8 *buf = NULL; \n int err; \n if (!seed && slen) { \n buf = kmalloc(slen, GFP_KERNEL); \n if (!buf) \n return -ENOMEM; \n get_random_bytes(buf, slen); \n seed = buf; \n } \n err = crypto_rng_alg(tfm)->seed(tfm, seed, slen); \n kfree(buf); \n return err; \n }",
  "cwe": "CWE-476",
  "codeline": "if (!buf) \n return -ENOMEM;"
}
{
  "idx": 77,
  "target": 1,
  "vul": "atol8(const char *p, size_t char_cnt) \n { \n int64_t l; \n int digit; \n l = 0; \n while (char_cnt-- > 0) { \n if (*p >= '0' && *p <= '7') \n digit = *p - '0'; \n else \n break; \n p++; \n l <<= 3; \n l |= digit; \n } \n return (l); \n }",
  "no_vul": "atol8(const char *p, size_t char_cnt) \n { \n int64_t l; \n int digit; \n if (char_cnt == 0) \n return (0); \n l = 0; \n while (char_cnt-- > 0) { \n if (*p >= '0' && *p <= '7') \n digit = *p - '0'; \n else \n break; \n p++; \n l <<= 3; \n l |= digit; \n } \n return (l); \n }",
  "cwe": "CWE-125",
  "codeline": "while (char_cnt-- > 0) {"
}
{
  "idx": 78,
  "target": 1,
  "vul": "handle_mlppp(netdissect_options *ndo, \n const u_char *p, int length) \n { \n if (!ndo->ndo_eflag) \n ND_PRINT((ndo, \"MLPPP, \")); \n ND_PRINT((ndo, \"seq 0x%03x, Flags [%s], length %u\", \n (EXTRACT_16BITS(p))&0x0fff, \n bittok2str(ppp_ml_flag_values, \"none\", *p & 0xc0), \n length)); \n }",
  "no_vul": "handle_mlppp(netdissect_options *ndo, \n const u_char *p, int length) \n { \n if (!ndo->ndo_eflag) \n ND_PRINT((ndo, \"MLPPP, \")); \n if (length < 2) { \n ND_PRINT((ndo, \"[|mlppp]\")); \n return; \n } \n if (!ND_TTEST_16BITS(p)) { \n ND_PRINT((ndo, \"[|mlppp]\")); \n return; \n } \n ND_PRINT((ndo, \"seq 0x%03x, Flags [%s], length %u\", \n (EXTRACT_16BITS(p))&0x0fff, \n bittok2str(ppp_ml_flag_values, \"none\", *p & 0xc0), \n length)); \n }",
  "cwe": "CWE-125",
  "codeline": "ND_PRINT((ndo, \"seq 0x%03x, Flags [%s], length %u\", \n (EXTRACT_16BITS(p))&0x0fff, \n bittok2str(ppp_ml_flag_values, \"none\", *p & 0xc0), \n length));"
}
{
  "idx": 79,
  "target": 1,
  "vul": "l_strnstart(const char *tstr1, u_int tl1, const char *str2, u_int l2) \n { \n if (tl1 > l2) \n return 0; \n return (strncmp(tstr1, str2, tl1) == 0 ? 1 : 0); \n }",
  "no_vul": "l_strnstart(const char *tstr1, u_int tl1, const char *str2, u_int l2) \n l_strnstart(netdissect_options *ndo, const char *tstr1, u_int tl1, \n const char *str2, u_int l2) \n { \n if (!ND_TTEST2(*str2, tl1)) { \n return 0; \n } \n if (tl1 > l2) \n return 0; \n return (strncmp(tstr1, str2, tl1) == 0 ? 1 : 0); \n }",
  "cwe": "CWE-125",
  "codeline": "if (tl1 > l2) \n return 0; \n return (strncmp(tstr1, str2, tl1) == 0 ? 1 : 0);"
}
{
  "idx": 80,
  "target": 1,
  "vul": "IW_IMPL(int) iw_get_input_density(struct iw_context *ctx, \n double *px, double *py, int *pcode) \n { \n *px = 1.0; \n *py = 1.0; \n *pcode = ctx->img1.density_code; \n if(ctx->img1.density_code!=IW_DENSITY_UNKNOWN) { \n *px = ctx->img1.density_x; \n *py = ctx->img1.density_y; \n return 1; \n } \n return 0; \n }",
  "no_vul": "IW_IMPL(int) iw_get_input_density(struct iw_context *ctx, \n double *px, double *py, int *pcode) \n { \n *px = 1.0; \n *py = 1.0; \n *pcode = IW_DENSITY_UNKNOWN; \n if(ctx->img1.density_code==IW_DENSITY_UNKNOWN) { \n return 0; \n } \n if(!iw_is_valid_density(ctx->img1.density_x, ctx->img1.density_y, \n ctx->img1.density_code)) \n { \n return 0; \n } \n *px = ctx->img1.density_x; \n *py = ctx->img1.density_y; \n *pcode = ctx->img1.density_code; \n return 1; \n }",
  "cwe": "CWE-369",
  "codeline": "if(ctx->img1.density_code!=IW_DENSITY_UNKNOWN) {"
}
{
  "idx": 81,
  "target": 1,
  "vul": "static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port) \n { \n struct usb_serial *serial = port->serial; \n struct usb_serial_port *wport; \n wport = serial->port[1]; \n tty_port_tty_set(&wport->port, tty); \n return usb_serial_generic_open(tty, port); \n }",
  "no_vul": "static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port) \n { \n return usb_serial_generic_open(tty, port); \n }",
  "cwe": "CWE-404",
  "codeline": "tty_port_tty_set(&wport->port, tty);"
}
{
  "idx": 82,
  "target": 1,
  "vul": "irc_ctcp_dcc_filename_without_quotes (const char *filename) \n { \n int length; \n length = strlen (filename); \n if (length > 0) \n { \n if ((filename[0] == '\\\"') && (filename[length - 1] == '\\\"')) \n return weechat_strndup (filename + 1, length - 2); \n } \n return strdup (filename); \n }",
  "no_vul": "irc_ctcp_dcc_filename_without_quotes (const char *filename) \n { \n int length; \n length = strlen (filename); \n if (length > 1) \n { \n if ((filename[0] == '\\\"') && (filename[length - 1] == '\\\"')) \n return weechat_strndup (filename + 1, length - 2); \n } \n return strdup (filename); \n }",
  "cwe": "CWE-119",
  "codeline": "if ((filename[0] == '\\\"') && (filename[length - 1] == '\\\"')) \n return weechat_strndup (filename + 1, length - 2);"
}
{
  "idx": 83,
  "target": 1,
  "vul": "void dvb_usbv2_disconnect(struct usb_interface *intf) \n { \n struct dvb_usb_device *d = usb_get_intfdata(intf); \n const char *name = d->name; \n struct device dev = d->udev->dev; \n dev_dbg(&d->udev->dev, \"%s: bInterfaceNumber=%d\\n\", __func__, \n intf->cur_altsetting->desc.bInterfaceNumber); \n if (d->props->exit) \n d->props->exit(d); \n dvb_usbv2_exit(d); \n dev_info(&dev, \"%s: '%s' successfully deinitialized and disconnected\\n\", \n KBUILD_MODNAME, name); \n }",
  "no_vul": "void dvb_usbv2_disconnect(struct usb_interface *intf) \n { \n struct dvb_usb_device *d = usb_get_intfdata(intf); \n const char *devname = kstrdup(dev_name(&d->udev->dev), GFP_KERNEL); \n const char *drvname = d->name; \n dev_dbg(&d->udev->dev, \"%s: bInterfaceNumber=%d\\n\", __func__, \n intf->cur_altsetting->desc.bInterfaceNumber); \n if (d->props->exit) \n d->props->exit(d); \n dvb_usbv2_exit(d); \n pr_info(\"%s: '%s:%s' successfully deinitialized and disconnected\\n\", \n KBUILD_MODNAME, drvname, devname); \n kfree(devname); \n }",
  "cwe": "CWE-119",
  "codeline": "dev_info(&dev, \"%s: '%s' successfully deinitialized and disconnected\\n\", \n KBUILD_MODNAME, name);"
}
{
  "idx": 84,
  "target": 1,
  "vul": "static void put_ucounts(struct ucounts *ucounts) \n { \n unsigned long flags; \n if (atomic_dec_and_test(&ucounts->count)) { \n spin_lock_irqsave(&ucounts_lock, flags); \n hlist_del_init(&ucounts->node); \n spin_unlock_irqrestore(&ucounts_lock, flags); \n kfree(ucounts); \n } \n }",
  "no_vul": "static void put_ucounts(struct ucounts *ucounts) \n { \n unsigned long flags; \n spin_lock_irqsave(&ucounts_lock, flags); \n ucounts->count -= 1; \n if (!ucounts->count) \n hlist_del_init(&ucounts->node); \n else \n ucounts = NULL; \n spin_unlock_irqrestore(&ucounts_lock, flags); \n kfree(ucounts); \n }",
  "cwe": "CWE-416",
  "codeline": "if (atomic_dec_and_test(&ucounts->count)) {"
}
{
  "idx": 85,
  "target": 1,
  "vul": "static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb, \n int tlen, int offset) \n { \n __wsum csum = skb->csum; \n if (skb->ip_summed != CHECKSUM_COMPLETE) \n return; \n if (offset != 0) \n csum = csum_sub(csum, \n csum_partial(skb_transport_header(skb) + tlen, \n offset, 0)); \n put_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum); \n }",
  "no_vul": "static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb, \n int tlen, int offset) \n { \n __wsum csum = skb->csum; \n if (skb->ip_summed != CHECKSUM_COMPLETE) \n return; \n if (offset != 0) { \n int tend_off = skb_transport_offset(skb) + tlen; \n csum = csum_sub(csum, skb_checksum(skb, tend_off, offset, 0)); \n } \n put_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum); \n }",
  "cwe": "CWE-125",
  "codeline": "csum = csum_sub(csum, \n csum_partial(skb_transport_header(skb) + tlen, \n offset, 0));"
}
{
  "idx": 86,
  "target": 1,
  "vul": "int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type) \n { \n int error; \n if (type == ACL_TYPE_ACCESS) { \n error = posix_acl_equiv_mode(acl, &inode->i_mode); \n if (error < 0) \n return 0; \n if (error == 0) \n acl = NULL; \n } \n inode->i_ctime = current_time(inode); \n set_cached_acl(inode, type, acl); \n return 0; \n }",
  "no_vul": "int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type) \n { \n int error; \n if (type == ACL_TYPE_ACCESS) { \n error = posix_acl_update_mode(inode, \n &inode->i_mode, &acl); \n if (error) \n return error; \n } \n inode->i_ctime = current_time(inode); \n set_cached_acl(inode, type, acl); \n return 0; \n }",
  "cwe": "CWE-284",
  "codeline": "if (error < 0) \n return 0;"
}
{
  "idx": 87,
  "target": 1,
  "vul": "static void detect_allow_debuggers(int argc, char **argv) { \n int i; \n for (i = 1; i < argc; i++) { \n if (strcmp(argv[i], \"--allow-debuggers\") == 0) { \n arg_allow_debuggers = 1; \n break; \n } \n if (strcmp(argv[i], \"--\") == 0) \n break; \n if (strncmp(argv[i], \"--\", 2) != 0) \n break; \n } \n }",
  "no_vul": "static void detect_quiet(int argc, char **argv) { \n int i; \n for (i = 1; i < argc; i++) { \n if (strcmp(argv[i], \"--quiet\") == 0) { \n arg_quiet = 1; \n break; \n } \n if (strcmp(argv[i], \"--\") == 0) \n break; \n if (strncmp(argv[i], \"--\", 2) != 0) \n break; \n } \n }",
  "cwe": "CWE-703",
  "codeline": "if (strcmp(argv[i], \"--allow-debuggers\") == 0) {"
}
{
  "idx": 88,
  "target": 1,
  "vul": "entry_guard_obeys_restriction(const entry_guard_t *guard, \n const entry_guard_restriction_t *rst) \n { \n tor_assert(guard); \n if (! rst) \n return 1; \n return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN); \n }",
  "no_vul": "entry_guard_obeys_restriction(const entry_guard_t *guard, \n const entry_guard_restriction_t *rst) \n { \n tor_assert(guard); \n if (! rst) \n return 1; \n const node_t *node = node_get_by_id((const char*)rst->exclude_id); \n if (node && guard_in_node_family(guard, node)) \n return 0; \n return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN); \n }",
  "cwe": "CWE-200",
  "codeline": "return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);"
}
{
  "idx": 89,
  "target": 1,
  "vul": "int fscrypt_process_policy(struct inode *inode, \n const struct fscrypt_policy *policy) \n { \n if (policy->version != 0) \n return -EINVAL; \n if (!inode_has_encryption_context(inode)) { \n if (!inode->i_sb->s_cop->empty_dir) \n return -EOPNOTSUPP; \n if (!inode->i_sb->s_cop->empty_dir(inode)) \n return -ENOTEMPTY; \n return create_encryption_context_from_policy(inode, policy); \n } \n if (is_encryption_context_consistent_with_policy(inode, policy)) \n return 0; \n printk(KERN_WARNING \"%s: Policy inconsistent with encryption context\\n\", \n __func__); \n return -EINVAL; \n }",
  "no_vul": "int fscrypt_process_policy(struct inode *inode, \n const struct fscrypt_policy *policy) \n { \n if (!inode_owner_or_capable(inode)) \n return -EACCES; \n if (policy->version != 0) \n return -EINVAL; \n if (!inode_has_encryption_context(inode)) { \n if (!inode->i_sb->s_cop->empty_dir) \n return -EOPNOTSUPP; \n if (!inode->i_sb->s_cop->empty_dir(inode)) \n return -ENOTEMPTY; \n return create_encryption_context_from_policy(inode, policy); \n } \n if (is_encryption_context_consistent_with_policy(inode, policy)) \n return 0; \n printk(KERN_WARNING \"%s: Policy inconsistent with encryption context\\n\", \n __func__); \n return -EINVAL; \n }",
  "cwe": "CWE-264",
  "codeline": "if (!inode_has_encryption_context(inode)) {"
}
{
  "idx": 90,
  "target": 1,
  "vul": "int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a) \n { \n return (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb, \n jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)), \n jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a), \n jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0; \n }",
  "no_vul": "int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a) \n { \n return (tsfb->numlvls > 0 && jas_seq2d_size(a)) ? \n jpc_tsfb_synthesize2(tsfb, \n jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)), \n jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a), \n jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0; \n }",
  "cwe": "CWE-476",
  "codeline": "return (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb, \n jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)), \n jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a), \n jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;"
}
{
  "idx": 91,
  "target": 1,
  "vul": "file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size) \n { \n bee_t *bee = ic->bee; \n bee_user_t *bu = bee_user_by_handle(bee, ic, handle); \n if (bee->ui->ft_in_start) { \n return bee->ui->ft_in_start(bee, bu, file_name, file_size); \n } else { \n return NULL; \n } \n }",
  "no_vul": "file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size) \n { \n bee_t *bee = ic->bee; \n bee_user_t *bu = bee_user_by_handle(bee, ic, handle); \n if (bee->ui->ft_in_start && bu) { \n return bee->ui->ft_in_start(bee, bu, file_name, file_size); \n } else { \n return NULL; \n } \n }",
  "cwe": "CWE-476",
  "codeline": "if (bee->ui->ft_in_start) {"
}
{
  "idx": 92,
  "target": 1,
  "vul": "static struct dentry *aio_mount(struct file_system_type *fs_type, \n int flags, const char *dev_name, void *data) \n { \n static const struct dentry_operations ops = { \n .d_dname = simple_dname, \n }; \n return mount_pseudo(fs_type, \"aio:\", NULL, &ops, AIO_RING_MAGIC); \n }",
  "no_vul": "static struct dentry *aio_mount(struct file_system_type *fs_type, \n int flags, const char *dev_name, void *data) \n { \n static const struct dentry_operations ops = { \n .d_dname = simple_dname, \n }; \n struct dentry *root = mount_pseudo(fs_type, \"aio:\", NULL, &ops, \n AIO_RING_MAGIC); \n if (!IS_ERR(root)) \n root->d_sb->s_iflags |= SB_I_NOEXEC; \n return root; \n }",
  "cwe": "CWE-264",
  "codeline": "return mount_pseudo(fs_type, \"aio:\", NULL, &ops, AIO_RING_MAGIC);"
}
{
  "idx": 93,
  "target": 1,
  "vul": "long ZEXPORT inflateMark(strm) \n z_streamp strm; \n { \n struct inflate_state FAR *state; \n if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16; \n state = (struct inflate_state FAR *)strm->state; \n return ((long)(state->back) << 16) + \n (state->mode == COPY ? state->length : \n (state->mode == MATCH ? state->was - state->length : 0)); \n }",
  "no_vul": "long ZEXPORT inflateMark(strm) \n z_streamp strm; \n { \n struct inflate_state FAR *state; \n if (strm == Z_NULL || strm->state == Z_NULL) \n return (long)(((unsigned long)0 - 1) << 16); \n state = (struct inflate_state FAR *)strm->state; \n return (long)(((unsigned long)((long)state->back)) << 16) + \n (state->mode == COPY ? state->length : \n (state->mode == MATCH ? state->was - state->length : 0)); \n }",
  "cwe": "CWE-189",
  "codeline": "return ((long)(state->back) << 16) + \n (state->mode == COPY ? state->length : \n (state->mode == MATCH ? state->was - state->length : 0));"
}
{
  "idx": 94,
  "target": 1,
  "vul": "jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend) \n { \n jas_matrix_t *matrix; \n assert(xstart <= xend && ystart <= yend); \n if (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) { \n return 0; \n } \n matrix->xstart_ = xstart; \n matrix->ystart_ = ystart; \n matrix->xend_ = xend; \n matrix->yend_ = yend; \n return matrix; \n }",
  "no_vul": "jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend) \n jas_matrix_t *jas_seq2d_create(jas_matind_t xstart, jas_matind_t ystart, \n jas_matind_t xend, jas_matind_t yend) \n { \n jas_matrix_t *matrix; \n assert(xstart <= xend && ystart <= yend); \n if (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) { \n return 0; \n } \n matrix->xstart_ = xstart; \n matrix->ystart_ = ystart; \n matrix->xend_ = xend; \n matrix->yend_ = yend; \n return matrix; \n }",
  "cwe": "CWE-190",
  "codeline": "int xstart, int ystart, int xend, int yend"
}
{
  "idx": 95,
  "target": 1,
  "vul": "static int mem_resize(jas_stream_memobj_t *m, int bufsize) \n { \n unsigned char *buf; \n assert(bufsize >= 0); \n JAS_DBGLOG(100, (\"mem_resize(%p, %d)\\n\", m, bufsize)); \n if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) && \n bufsize) { \n JAS_DBGLOG(100, (\"mem_resize realloc failed\\n\")); \n return -1; \n } \n JAS_DBGLOG(100, (\"mem_resize realloc succeeded\\n\")); \n m->buf_ = buf; \n m->bufsize_ = bufsize; \n return 0; \n }",
  "no_vul": "static int mem_resize(jas_stream_memobj_t *m, int bufsize) \n static int mem_resize(jas_stream_memobj_t *m, size_t bufsize) \n { \n unsigned char *buf; \n JAS_DBGLOG(100, (\"mem_resize(%p, %zu)\\n\", m, bufsize)); \n if (!bufsize) { \n jas_eprintf( \n \"mem_resize was not really designed to handle a buffer of size 0\\n\" \n \"This may not work.\\n\" \n ); \n } \n if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) && \n bufsize) { \n JAS_DBGLOG(100, (\"mem_resize realloc failed\\n\")); \n return -1; \n } \n JAS_DBGLOG(100, (\"mem_resize realloc succeeded\\n\")); \n m->buf_ = buf; \n m->bufsize_ = bufsize; \n return 0; \n }",
  "cwe": "CWE-190",
  "codeline": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)"
}
{
  "idx": 96,
  "target": 1,
  "vul": "static int mem_resize(jas_stream_memobj_t *m, int bufsize) \n { \n unsigned char *buf; \n assert(m->buf_); \n assert(bufsize >= 0); \n if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) { \n return -1; \n } \n m->buf_ = buf; \n m->bufsize_ = bufsize; \n return 0; \n }",
  "no_vul": "static int mem_resize(jas_stream_memobj_t *m, int bufsize) \n { \n unsigned char *buf; \n assert(bufsize >= 0); \n if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) && \n bufsize) { \n return -1; \n } \n m->buf_ = buf; \n m->bufsize_ = bufsize; \n return 0; \n }",
  "cwe": "CWE-415",
  "codeline": "assert(m->buf_);"
}
{
  "idx": 97,
  "target": 1,
  "vul": "int mem_check_range(struct rxe_mem *mem, u64 iova, size_t length) \n { \n switch (mem->type) { \n case RXE_MEM_TYPE_DMA: \n return 0; \n case RXE_MEM_TYPE_MR: \n case RXE_MEM_TYPE_FMR: \n return ((iova < mem->iova) || \n ((iova + length) > (mem->iova + mem->length))) ? \n -EFAULT : 0; \n default: \n return -EFAULT; \n } \n }",
  "no_vul": "int mem_check_range(struct rxe_mem *mem, u64 iova, size_t length) \n { \n switch (mem->type) { \n case RXE_MEM_TYPE_DMA: \n return 0; \n case RXE_MEM_TYPE_MR: \n case RXE_MEM_TYPE_FMR: \n if (iova < mem->iova || \n length > mem->length || \n iova > mem->iova + mem->length - length) \n return -EFAULT; \n return 0; \n default: \n return -EFAULT; \n } \n }",
  "cwe": "CWE-190",
  "codeline": "((iova + length) > (mem->iova + mem->length))) ? -EFAULT : 0;"
}
{
  "idx": 98,
  "target": 1,
  "vul": "static bool check_allocations(ASS_Shaper *shaper, size_t new_size) \n { \n if (new_size > shaper->n_glyphs) { \n if (!ASS_REALLOC_ARRAY(shaper->event_text, new_size) || \n !ASS_REALLOC_ARRAY(shaper->ctypes, new_size) || \n !ASS_REALLOC_ARRAY(shaper->emblevels, new_size) || \n !ASS_REALLOC_ARRAY(shaper->cmap, new_size)) \n return false; \n } \n return true; \n }",
  "no_vul": "static bool check_allocations(ASS_Shaper *shaper, size_t new_size) \n { \n if (new_size > shaper->n_glyphs) { \n if (!ASS_REALLOC_ARRAY(shaper->event_text, new_size) || \n !ASS_REALLOC_ARRAY(shaper->ctypes, new_size) || \n !ASS_REALLOC_ARRAY(shaper->emblevels, new_size) || \n !ASS_REALLOC_ARRAY(shaper->cmap, new_size)) \n return false; \n shaper->n_glyphs = new_size; \n } \n return true; \n }",
  "cwe": "CWE-399",
  "codeline": "if (!ASS_REALLOC_ARRAY(shaper->event_text, new_size) || \n !ASS_REALLOC_ARRAY(shaper->ctypes, new_size) || \n !ASS_REALLOC_ARRAY(shaper->emblevels, new_size) || \n !ASS_REALLOC_ARRAY(shaper->cmap, new_size)) \n return false;"
}
{
  "idx": 99,
  "target": 1,
  "vul": "rs_filter_graph(RSFilter *filter) \n { \n g_return_if_fail(RS_IS_FILTER(filter)); \n GString *str = g_string_new(\"digraph G {\\n\"); \n rs_filter_graph_helper(str, filter); \n g_string_append_printf(str, \"}\\n\"); \n g_file_set_contents(\"/tmp/rs-filter-graph\", str->str, str->len, NULL); \n if (0 != system(\"dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph\")) \n g_warning(\"Calling dot failed\"); \n if (0 != system(\"gnome-open /tmp/rs-filter-graph.png\")) \n g_warning(\"Calling gnome-open failed.\"); \n g_string_free(str, TRUE); \n }",
  "no_vul": "rs_filter_graph(RSFilter *filter) \n { \n g_return_if_fail(RS_IS_FILTER(filter)); \n gchar *dot_filename; \n gchar *png_filename; \n gchar *command_line; \n GString *str = g_string_new(\"digraph G {\\n\"); \n rs_filter_graph_helper(str, filter); \n g_string_append_printf(str, \"}\\n\"); \n dot_filename = g_strdup_printf(\"/tmp/rs-filter-graph.%u\", g_random_int()); \n png_filename = g_strdup_printf(\"%s.%u.png\", dot_filename, g_random_int()); \n g_file_set_contents(dot_filename, str->str, str->len, NULL); \n command_line = g_strdup_printf(\"dot -Tpng >%s <%s\", png_filename, dot_filename); \n if (0 != system(command_line)) \n g_warning(\"Calling dot failed\"); \n g_free(command_line); \n command_line = g_strdup_printf(\"gnome-open %s\", png_filename); \n if (0 != system(command_line)) \n g_warning(\"Calling gnome-open failed.\"); \n g_free(command_line); \n g_free(dot_filename); \n g_free(png_filename); \n g_string_free(str, TRUE); \n }",
  "cwe": "CWE-59",
  "codeline": "g_file_set_contents(\"/tmp/rs-filter-graph\", str->str, str->len, NULL);"
}
{
  "idx": 100,
  "target": 1,
  "vul": "static void t1_check_unusual_charstring(void) \n { \n char *p = strstr(t1_line_array, charstringname) + strlen(charstringname); \n int i; \n if (sscanf(p, \"%i\", &i) != 1) { \n strcpy(t1_buf_array, t1_line_array); \n t1_getline(); \n strcat(t1_buf_array, t1_line_array); \n strcpy(t1_line_array, t1_buf_array); \n t1_line_ptr = eol(t1_line_array); \n } \n }",
  "no_vul": "static void t1_check_unusual_charstring(void) \n { \n char *p = strstr(t1_line_array, charstringname) + strlen(charstringname); \n int i; \n if (sscanf(p, \"%i\", &i) != 1) { \n strcpy(t1_buf_array, t1_line_array); \n t1_getline(); \n alloc_array(t1_buf, strlen(t1_line_array) + strlen(t1_buf_array) + 1, T1_BUF_SIZE); \n strcat(t1_buf_array, t1_line_array); \n alloc_array(t1_line, strlen(t1_buf_array) + 1, T1_BUF_SIZE); \n strcpy(t1_line_array, t1_buf_array); \n t1_line_ptr = eol(t1_line_array); \n } \n }",
  "cwe": "CWE-119",
  "codeline": "strcpy(t1_line_array, t1_buf_array);"
}
{
  "idx": 101,
  "target": 1,
  "vul": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append) \n { \n unsigned nSyms = darray_size(expr->keysym_list.syms); \n unsigned numEntries = darray_size(append->keysym_list.syms); \n darray_append(expr->keysym_list.symsMapIndex, nSyms); \n darray_append(expr->keysym_list.symsNumEntries, numEntries); \n darray_concat(expr->keysym_list.syms, append->keysym_list.syms); \n FreeStmt((ParseCommon *) &append); \n return expr; \n }",
  "no_vul": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append) \n { \n unsigned nSyms = darray_size(expr->keysym_list.syms); \n unsigned numEntries = darray_size(append->keysym_list.syms); \n darray_append(expr->keysym_list.symsMapIndex, nSyms); \n darray_append(expr->keysym_list.symsNumEntries, numEntries); \n darray_concat(expr->keysym_list.syms, append->keysym_list.syms); \n FreeStmt((ParseCommon *) append); \n return expr; \n }",
  "cwe": "CWE-416",
  "codeline": "FreeStmt((ParseCommon *) &append);"
}
{
  "idx": 102,
  "target": 1,
  "vul": "PHP_FUNCTION(linkinfo) \n { \n char *link; \n size_t link_len; \n zend_stat_t sb; \n int ret; \n if (zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &link, &link_len) == FAILURE) { \n return; \n } \n ret = VCWD_STAT(link, &sb); \n if (ret == -1) { \n php_error_docref(NULL, E_WARNING, \"%s\", strerror(errno)); \n RETURN_LONG(Z_L(-1)); \n } \n RETURN_LONG((zend_long) sb.st_dev); \n }",
  "no_vul": "PHP_FUNCTION(linkinfo) \n { \n char *link; \n char *dirname; \n size_t link_len; \n zend_stat_t sb; \n int ret; \n if (zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &link, &link_len) == FAILURE) { \n return; \n } \n dirname = estrndup(link, link_len); \n php_dirname(dirname, link_len); \n if (php_check_open_basedir(dirname)) { \n efree(dirname); \n RETURN_FALSE; \n } \n ret = VCWD_STAT(link, &sb); \n if (ret == -1) { \n php_error_docref(NULL, E_WARNING, \"%s\", strerror(errno)); \n efree(dirname); \n RETURN_LONG(Z_L(-1)); \n } \n efree(dirname); \n RETURN_LONG((zend_long) sb.st_dev); \n }",
  "cwe": "CWE-200",
  "codeline": "ret = VCWD_STAT(link, &sb);"
}
{
  "idx": 103,
  "target": 1,
  "vul": "void inode_init_owner(struct inode *inode, const struct inode *dir, \n umode_t mode) \n { \n inode->i_uid = current_fsuid(); \n if (dir && dir->i_mode & S_ISGID) { \n inode->i_gid = dir->i_gid; \n if (S_ISDIR(mode)) \n mode |= S_ISGID; \n } else \n inode->i_gid = current_fsgid(); \n inode->i_mode = mode; \n }",
  "no_vul": "void inode_init_owner(struct inode *inode, const struct inode *dir, \n umode_t mode) \n { \n inode->i_uid = current_fsuid(); \n if (dir && dir->i_mode & S_ISGID) { \n inode->i_gid = dir->i_gid; \n if (S_ISDIR(mode)) \n mode |= S_ISGID; \n else if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) && \n !in_group_p(inode->i_gid) && \n !capable_wrt_inode_uidgid(dir, CAP_FSETID)) \n mode &= ~S_ISGID; \n } else \n inode->i_gid = current_fsgid(); \n inode->i_mode = mode; \n }",
  "cwe": "CWE-269",
  "codeline": "if (dir && dir->i_mode & S_ISGID) { \ninode->i_gid = dir->i_gid; \nif (S_ISDIR(mode)) \nmode |= S_ISGID; \n} else \ninode->i_gid = current_fsgid(); \ninode->i_mode = mode;"
}
{
  "idx": 104,
  "target": 1,
  "vul": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf, \n size_t size) \n { \n GetBitContext gb; \n AC3HeaderInfo *hdr; \n int err; \n if (!*phdr) \n *phdr = av_mallocz(sizeof(AC3HeaderInfo)); \n if (!*phdr) \n return AVERROR(ENOMEM); \n hdr = *phdr; \n init_get_bits8(&gb, buf, size); \n err = ff_ac3_parse_header(&gb, hdr); \n if (err < 0) \n return AVERROR_INVALIDDATA; \n return get_bits_count(&gb); \n }",
  "no_vul": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf, \n size_t size) \n { \n GetBitContext gb; \n AC3HeaderInfo *hdr; \n int err; \n if (!*phdr) \n *phdr = av_mallocz(sizeof(AC3HeaderInfo)); \n if (!*phdr) \n return AVERROR(ENOMEM); \n hdr = *phdr; \n err = init_get_bits8(&gb, buf, size); \n if (err < 0) \n return AVERROR_INVALIDDATA; \n err = ff_ac3_parse_header(&gb, hdr); \n if (err < 0) \n return AVERROR_INVALIDDATA; \n return get_bits_count(&gb); \n }",
  "cwe": "CWE-476",
  "codeline": "init_get_bits8(&gb, buf, size);"
}
{
  "idx": 105,
  "target": 1,
  "vul": "av_cold void ff_mpv_idct_init(MpegEncContext *s) \n { \n ff_idctdsp_init(&s->idsp, s->avctx); \n if (s->alternate_scan) { \n ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan); \n ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan); \n } else { \n ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct); \n ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct); \n } \n ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan); \n ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan); \n }",
  "no_vul": "av_cold void ff_mpv_idct_init(MpegEncContext *s) \n { \n if (s->codec_id == AV_CODEC_ID_MPEG4) \n s->idsp.mpeg4_studio_profile = s->studio_profile; \n ff_idctdsp_init(&s->idsp, s->avctx); \n if (s->alternate_scan) { \n ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan); \n ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan); \n } else { \n ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct); \n ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct); \n } \n ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan); \n ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan); \n }",
  "cwe": "CWE-476",
  "codeline": "ff_idctdsp_init(&s->idsp, s->avctx);"
}
{
  "idx": 106,
  "target": 1,
  "vul": "mrb_class_real(struct RClass* cl) \n { \n if (cl == 0) \n return NULL; \n while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) { \n cl = cl->super; \n } \n return cl; \n }",
  "no_vul": "mrb_class_real(struct RClass* cl) \n { \n if (cl == 0) return NULL; \n while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) { \n cl = cl->super; \n if (cl == 0) return NULL; \n } \n return cl; \n }",
  "cwe": "CWE-476",
  "codeline": "cl = cl->super;"
}
{
  "idx": 107,
  "target": 1,
  "vul": "static int sock_close(struct inode *inode, struct file *filp) \n { \n sock_release(SOCKET_I(inode)); \n return 0; \n }",
  "no_vul": "static int sock_close(struct inode *inode, struct file *filp) \n { \n __sock_release(SOCKET_I(inode), inode); \n return 0; \n }",
  "cwe": "CWE-362",
  "codeline": "sock_release(SOCKET_I(inode));"
}
{
  "idx": 108,
  "target": 1,
  "vul": "static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr) \n { \n int err = simple_setattr(dentry, iattr); \n if (!err && (iattr->ia_valid & ATTR_UID)) { \n struct socket *sock = SOCKET_I(d_inode(dentry)); \n sock->sk->sk_uid = iattr->ia_uid; \n } \n return err; \n }",
  "no_vul": "static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr) \n { \n int err = simple_setattr(dentry, iattr); \n if (!err && (iattr->ia_valid & ATTR_UID)) { \n struct socket *sock = SOCKET_I(d_inode(dentry)); \n if (sock->sk) \n sock->sk->sk_uid = iattr->ia_uid; \n else \n err = -ENOENT; \n } \n return err; \n }",
  "cwe": "CWE-362",
  "codeline": "sock->sk->sk_uid = iattr->ia_uid;"
}
{
  "idx": 109,
  "target": 1,
  "vul": "INST_HANDLER (sts) { \n int r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4); \n int k = (buf[3] << 8) | buf[2]; \n op->ptr = k; \n ESIL_A (\"r%d,\", r); \n __generic_ld_st (op, \"ram\", 0, 1, 0, k, 1); \n op->cycles = 2; \n }",
  "no_vul": "INST_HANDLER (sts) { \n if (len < 4) { \n return; \n } \n int r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4); \n int k = (buf[3] << 8) | buf[2]; \n op->ptr = k; \n ESIL_A (\"r%d,\", r); \n __generic_ld_st (op, \"ram\", 0, 1, 0, k, 1); \n op->cycles = 2; \n }",
  "cwe": "CWE-125",
  "codeline": "int r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);"
}
{
  "idx": 110,
  "target": 1,
  "vul": "static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb, \n struct net_device *ndev) \n { \n struct hns_nic_priv *priv = netdev_priv(ndev); \n int ret; \n assert(skb->queue_mapping < ndev->ae_handle->q_num); \n ret = hns_nic_net_xmit_hw(ndev, skb, \n &tx_ring_data(priv, skb->queue_mapping)); \n if (ret == NETDEV_TX_OK) { \n netif_trans_update(ndev); \n ndev->stats.tx_bytes += skb->len; \n ndev->stats.tx_packets++; \n } \n return (netdev_tx_t)ret; \n }",
  "no_vul": "static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb, \n struct net_device *ndev) \n { \n struct hns_nic_priv *priv = netdev_priv(ndev); \n assert(skb->queue_mapping < ndev->ae_handle->q_num); \n return hns_nic_net_xmit_hw(ndev, skb, \n &tx_ring_data(priv, skb->queue_mapping)); \n }",
  "cwe": "CWE-416",
  "codeline": "netif_trans_update(ndev);"
}
{
  "idx": 111,
  "target": 1,
  "vul": "struct mapped_device *dm_get_from_kobject(struct kobject *kobj) \n { \n struct mapped_device *md; \n md = container_of(kobj, struct mapped_device, kobj_holder.kobj); \n if (test_bit(DMF_FREEING, &md->flags) || \n dm_deleting_md(md)) \n return NULL; \n dm_get(md); \n return md; \n }",
  "no_vul": "struct mapped_device *dm_get_from_kobject(struct kobject *kobj) \n { \n struct mapped_device *md; \n md = container_of(kobj, struct mapped_device, kobj_holder.kobj); \n spin_lock(&_minor_lock); \n if (test_bit(DMF_FREEING, &md->flags) || dm_deleting_md(md)) { \n md = NULL; \n goto out; \n } \n dm_get(md); \n out: \n spin_unlock(&_minor_lock); \n return md; \n }",
  "cwe": "CWE-362",
  "codeline": "if (test_bit(DMF_FREEING, &md->flags) || \ndm_deleting_md(md)) \nreturn NULL;"
}
{
  "idx": 112,
  "target": 1,
  "vul": "void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi) \n { \n __issue_discard_cmd(sbi, false); \n __drop_discard_cmd(sbi); \n __wait_discard_cmd(sbi, false); \n }",
  "no_vul": "void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi) \n void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi, bool umount) \n { \n __issue_discard_cmd(sbi, false); \n __drop_discard_cmd(sbi); \n __wait_discard_cmd(sbi, !umount); \n }",
  "cwe": "CWE-20",
  "codeline": "__wait_discard_cmd(sbi, false);"
}
{
  "idx": 113,
  "target": 1,
  "vul": "static int amd_gpio_remove(struct platform_device *pdev) \n { \n struct amd_gpio *gpio_dev; \n gpio_dev = platform_get_drvdata(pdev); \n gpiochip_remove(&gpio_dev->gc); \n pinctrl_unregister(gpio_dev->pctrl); \n return 0; \n }",
  "no_vul": "static int amd_gpio_remove(struct platform_device *pdev) \n { \n struct amd_gpio *gpio_dev; \n gpio_dev = platform_get_drvdata(pdev); \n gpiochip_remove(&gpio_dev->gc); \n return 0; \n }",
  "cwe": "CWE-415",
  "codeline": "pinctrl_unregister(gpio_dev->pctrl);"
}
{
  "idx": 114,
  "target": 1,
  "vul": "struct net *get_net_ns_by_id(struct net *net, int id) \n { \n struct net *peer; \n if (id < 0) \n return NULL; \n rcu_read_lock(); \n spin_lock_bh(&net->nsid_lock); \n peer = idr_find(&net->netns_ids, id); \n if (peer) \n get_net(peer); \n spin_unlock_bh(&net->nsid_lock); \n rcu_read_unlock(); \n return peer; \n }",
  "no_vul": "struct net *get_net_ns_by_id(struct net *net, int id) \n { \n struct net *peer; \n if (id < 0) \n return NULL; \n rcu_read_lock(); \n spin_lock_bh(&net->nsid_lock); \n peer = idr_find(&net->netns_ids, id); \n if (peer) \n peer = maybe_get_net(peer); \n spin_unlock_bh(&net->nsid_lock); \n rcu_read_unlock(); \n return peer; \n }",
  "cwe": "CWE-416",
  "codeline": "get_net(peer);"
}
{
  "idx": 115,
  "target": 1,
  "vul": "static int __init fm10k_init_module(void) \n { \n pr_info(\"%s - version %s\\n\", fm10k_driver_string, fm10k_driver_version); \n pr_info(\"%s\\n\", fm10k_copyright); \n fm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0, \n fm10k_driver_name); \n fm10k_dbg_init(); \n return fm10k_register_pci_driver(); \n }",
  "no_vul": "static int __init fm10k_init_module(void) \n { \n pr_info(\"%s - version %s\\n\", fm10k_driver_string, fm10k_driver_version); \n pr_info(\"%s\\n\", fm10k_copyright); \n fm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0, \n fm10k_driver_name); \n if (!fm10k_workqueue) \n return -ENOMEM; \n fm10k_dbg_init(); \n return fm10k_register_pci_driver(); \n }",
  "cwe": "CWE-476",
  "codeline": "fm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0, fm10k_driver_name);"
}
{
  "idx": 116,
  "target": 1,
  "vul": "static int hci_uart_set_proto(struct hci_uart *hu, int id) \n { \n const struct hci_uart_proto *p; \n int err; \n p = hci_uart_get_proto(id); \n if (!p) \n return -EPROTONOSUPPORT; \n hu->proto = p; \n set_bit(HCI_UART_PROTO_READY, &hu->flags); \n err = hci_uart_register_dev(hu); \n if (err) { \n clear_bit(HCI_UART_PROTO_READY, &hu->flags); \n return err; \n } \n return 0; \n }",
  "no_vul": "static int hci_uart_set_proto(struct hci_uart *hu, int id) \n { \n const struct hci_uart_proto *p; \n int err; \n p = hci_uart_get_proto(id); \n if (!p) \n return -EPROTONOSUPPORT; \n hu->proto = p; \n err = hci_uart_register_dev(hu); \n if (err) { \n return err; \n } \n set_bit(HCI_UART_PROTO_READY, &hu->flags); \n return 0; \n }",
  "cwe": "CWE-416",
  "codeline": "clear_bit(HCI_UART_PROTO_READY, &hu->flags);"
}
{
  "idx": 117,
  "target": 1,
  "vul": "GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) \n { \n if (ms) \n { \n int32_t nestsize = (int32_t)ms->nest_size[ms->nest_level]; \n if (nestsize == 0 && ms->nest_level == 0) \n nestsize = ms->buffer_size_longs; \n if (size + 2 <= nestsize) return GPMF_OK; \n } \n return GPMF_ERROR_BAD_STRUCTURE; \n }",
  "no_vul": "GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) \n { \n if (ms) \n { \n uint32_t nestsize = (uint32_t)ms->nest_size[ms->nest_level]; \n if (nestsize == 0 && ms->nest_level == 0) \n nestsize = ms->buffer_size_longs; \n if (size + 2 <= nestsize) return GPMF_OK; \n } \n return GPMF_ERROR_BAD_STRUCTURE; \n }",
  "cwe": "CWE-787",
  "codeline": "int32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];"
}
{
  "idx": 118,
  "target": 1,
  "vul": "MagickExport unsigned char *DetachBlob(BlobInfo *blob_info) \n { \n unsigned char \n *data; \n assert(blob_info != (BlobInfo *) NULL); \n if (blob_info->debug != MagickFalse) \n (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\"); \n if (blob_info->mapped != MagickFalse) \n { \n (void) UnmapBlob(blob_info->data,blob_info->length); \n RelinquishMagickResource(MapResource,blob_info->length); \n } \n blob_info->mapped=MagickFalse; \n blob_info->length=0; \n blob_info->offset=0; \n blob_info->eof=MagickFalse; \n blob_info->error=0; \n blob_info->exempt=MagickFalse; \n blob_info->type=UndefinedStream; \n blob_info->file_info.file=(FILE *) NULL; \n data=blob_info->data; \n blob_info->data=(unsigned char *) NULL; \n blob_info->stream=(StreamHandler) NULL; \n return(data); \n }",
  "no_vul": "MagickExport unsigned char *DetachBlob(BlobInfo *blob_info) \n { \n unsigned char \n *data; \n assert(blob_info != (BlobInfo *) NULL); \n if (blob_info->debug != MagickFalse) \n (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\"); \n if (blob_info->mapped != MagickFalse) \n { \n (void) UnmapBlob(blob_info->data,blob_info->length); \n blob_info->data=NULL; \n RelinquishMagickResource(MapResource,blob_info->length); \n } \n blob_info->mapped=MagickFalse; \n blob_info->length=0; \n blob_info->offset=0; \n blob_info->eof=MagickFalse; \n blob_info->error=0; \n blob_info->exempt=MagickFalse; \n blob_info->type=UndefinedStream; \n blob_info->file_info.file=(FILE *) NULL; \n data=blob_info->data; \n blob_info->data=(unsigned char *) NULL; \n blob_info->stream=(StreamHandler) NULL; \n return(data); \n }",
  "cwe": "CWE-416",
  "codeline": "(void) UnmapBlob(blob_info->data,blob_info->length); \nRelinquishMagickResource(MapResource,blob_info->length);"
}
{
  "idx": 119,
  "target": 1,
  "vul": "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent) \n { \n rcu_read_lock(); \n __ptrace_link(child, new_parent, __task_cred(new_parent)); \n rcu_read_unlock(); \n }",
  "no_vul": "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent) \n { \n __ptrace_link(child, new_parent, current_cred()); \n }",
  "cwe": "CWE-264",
  "codeline": "rcu_read_lock(); \n__ptrace_link(child, new_parent, __task_cred(new_parent)); \nrcu_read_unlock();"
}
{
  "idx": 120,
  "target": 1,
  "vul": "static float *get_window(vorb *f, int len) \n { \n len <<= 1; \n if (len == f->blocksize_0) return f->window[0]; \n if (len == f->blocksize_1) return f->window[1]; \n assert(0); \n return NULL; \n }",
  "no_vul": "static float *get_window(vorb *f, int len) \n { \n len <<= 1; \n if (len == f->blocksize_0) return f->window[0]; \n if (len == f->blocksize_1) return f->window[1]; \n return NULL; \n }",
  "cwe": "CWE-20",
  "codeline": "assert(0);"
}
{
  "idx": 121,
  "target": 1,
  "vul": "static void copyIPv6IfDifferent(void * dest, const void * src) \n { \n if(dest != src) { \n memcpy(dest, src, sizeof(struct in6_addr)); \n } \n }",
  "no_vul": "static void copyIPv6IfDifferent(void * dest, const void * src) \n { \n if(dest != src && src != NULL) { \n memcpy(dest, src, sizeof(struct in6_addr)); \n } \n }",
  "cwe": "CWE-476",
  "codeline": "if(dest != src) {"
}
{
  "idx": 122,
  "target": 1,
  "vul": "static void numtostr(js_State *J, const char *fmt, int w, double n) \n { \n char buf[32], *e; \n sprintf(buf, fmt, w, n); \n e = strchr(buf, 'e'); \n if (e) { \n int exp = atoi(e+1); \n sprintf(e, \"e%+d\", exp); \n } \n js_pushstring(J, buf); \n }",
  "no_vul": "static void numtostr(js_State *J, const char *fmt, int w, double n) \n { \n char buf[50], *e; \n sprintf(buf, fmt, w, n); \n e = strchr(buf, 'e'); \n if (e) { \n int exp = atoi(e+1); \n sprintf(e, \"e%+d\", exp); \n } \n js_pushstring(J, buf); \n }",
  "cwe": "CWE-119",
  "codeline": "sprintf(buf, fmt, w, n);"
}
{
  "idx": 123,
  "target": 1,
  "vul": "int snmp_version(void *context, size_t hdrlen, unsigned char tag, \n const void *data, size_t datalen) \n { \n if (*(unsigned char *)data > 1) \n return -ENOTSUPP; \n return 1; \n }",
  "no_vul": "int snmp_version(void *context, size_t hdrlen, unsigned char tag, \n const void *data, size_t datalen) \n { \n if (datalen != 1) \n return -EINVAL; \n if (*(unsigned char *)data > 1) \n return -ENOTSUPP; \n return 1; \n }",
  "cwe": "CWE-129",
  "codeline": "if (*(unsigned char *)data > 1) \nreturn -ENOTSUPP;"
}
{
  "idx": 124,
  "target": 1,
  "vul": "int am_check_url(request_rec *r, const char *url) \n { \n const char *i; \n for (i = url; *i; i++) { \n if (*i >= 0 && *i < ' ') { \n AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r, \n \"Control character detected in URL.\"); \n return HTTP_BAD_REQUEST; \n } \n } \n return OK; \n }",
  "no_vul": "int am_check_url(request_rec *r, const char *url) \n { \n const char *i; \n for (i = url; *i; i++) { \n if (*i >= 0 && *i < ' ') { \n AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r, \n \"Control character detected in URL.\"); \n return HTTP_BAD_REQUEST; \n } \n if (*i == '\\\\') { \n AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r, \n \"Backslash character detected in URL.\"); \n return HTTP_BAD_REQUEST; \n } \n } \n return OK; \n }",
  "cwe": "CWE-601",
  "codeline": "if (*i >= 0 && *i < ' ') {"
}
{
  "idx": 125,
  "target": 1,
  "vul": "GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs) \n { \n GF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox); \n if (e) { \n return e; \n } \n if (!((GF_DataInformationBox *)s)->dref) { \n GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\")); \n ((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF); \n } \n return GF_OK; \n }",
  "no_vul": "GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs) \n { \n GF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox); \n if (e) { \n return e; \n } \n if (!((GF_DataInformationBox *)s)->dref) { \n GF_Box* dref; \n GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\")); \n dref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF); \n ((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)dref; \n gf_isom_box_add_for_dump_mode(s, dref); \n } \n return GF_OK; \n }",
  "cwe": "CWE-400",
  "codeline": "((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);"
}
{
  "idx": 126,
  "target": 1,
  "vul": "static void smp_task_done(struct sas_task *task) \n { \n if (!del_timer(&task->slow_task->timer)) \n return; \n complete(&task->slow_task->completion); \n }",
  "no_vul": "static void smp_task_done(struct sas_task *task) \n { \n del_timer(&task->slow_task->timer); \n complete(&task->slow_task->completion); \n }",
  "cwe": "CWE-416",
  "codeline": "if (!del_timer(&task->slow_task->timer)) \nreturn;"
}
{
  "idx": 127,
  "target": 1,
  "vul": "static void smp_task_timedout(struct timer_list *t) \n { \n struct sas_task_slow *slow = from_timer(slow, t, timer); \n struct sas_task *task = slow->task; \n unsigned long flags; \n spin_lock_irqsave(&task->task_state_lock, flags); \n if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) \n task->task_state_flags |= SAS_TASK_STATE_ABORTED; \n spin_unlock_irqrestore(&task->task_state_lock, flags); \n complete(&task->slow_task->completion); \n }",
  "no_vul": "static void smp_task_timedout(struct timer_list *t) \n { \n struct sas_task_slow *slow = from_timer(slow, t, timer); \n struct sas_task *task = slow->task; \n unsigned long flags; \n spin_lock_irqsave(&task->task_state_lock, flags); \n if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) { \n task->task_state_flags |= SAS_TASK_STATE_ABORTED; \n complete(&task->slow_task->completion); \n } \n spin_unlock_irqrestore(&task->task_state_lock, flags); \n }",
  "cwe": "CWE-416",
  "codeline": "complete(&task->slow_task->completion);"
}
{
  "idx": 128,
  "target": 1,
  "vul": "seamless_process(STREAM s) \n { \n unsigned int pkglen; \n char *buf; \n pkglen = s->end - s->p; \n buf = xmalloc(pkglen + 1); \n STRNCPY(buf, (char *) s->p, pkglen + 1); \n str_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL); \n xfree(buf); \n }",
  "no_vul": "seamless_process(STREAM s) \n { \n unsigned int pkglen; \n char *buf; \n struct stream packet = *s; \n if (!s_check(s)) \n { \n rdp_protocol_error(\"seamless_process(), stream is in unstable state\", &packet); \n } \n pkglen = s->end - s->p; \n buf = xmalloc(pkglen + 1); \n STRNCPY(buf, (char *) s->p, pkglen + 1); \n str_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL); \n xfree(buf); \n }",
  "cwe": "CWE-119",
  "codeline": "STRNCPY(buf, (char *) s->p, pkglen + 1);"
}
{
  "idx": 129,
  "target": 1,
  "vul": "lspci_process(STREAM s) \n { \n unsigned int pkglen; \n static char *rest = NULL; \n char *buf; \n pkglen = s->end - s->p; \n buf = xmalloc(pkglen + 1); \n STRNCPY(buf, (char *) s->p, pkglen + 1); \n str_handle_lines(buf, &rest, lspci_process_line, NULL); \n xfree(buf); \n }",
  "no_vul": "lspci_process(STREAM s) \n { \n unsigned int pkglen; \n static char *rest = NULL; \n char *buf; \n struct stream packet = *s; \n if (!s_check(s)) \n { \n rdp_protocol_error(\"lspci_process(), stream is in unstable state\", &packet); \n } \n pkglen = s->end - s->p; \n buf = xmalloc(pkglen + 1); \n STRNCPY(buf, (char *) s->p, pkglen + 1); \n str_handle_lines(buf, &rest, lspci_process_line, NULL); \n xfree(buf); \n }",
  "cwe": "CWE-119",
  "codeline": "buf = xmalloc(pkglen + 1);"
}
{
  "idx": 130,
  "target": 1,
  "vul": "rdpsnddbg_process(STREAM s) \n { \n unsigned int pkglen; \n static char *rest = NULL; \n char *buf; \n pkglen = s->end - s->p; \n buf = (char *) xmalloc(pkglen + 1); \n STRNCPY(buf, (char *) s->p, pkglen + 1); \n str_handle_lines(buf, &rest, rdpsnddbg_line_handler, NULL); \n xfree(buf); \n }",
  "no_vul": "rdpsnddbg_process(STREAM s) \n { \n unsigned int pkglen; \n static char *rest = NULL; \n char *buf; \n if (!s_check(s)) \n { \n rdp_protocol_error(\"rdpsnddbg_process(), stream is in unstable state\", s); \n } \n pkglen = s->end - s->p; \n buf = (char *) xmalloc(pkglen + 1); \n STRNCPY(buf, (char *) s->p, pkglen + 1); \n str_handle_lines(buf, &rest, rdpsnddbg_line_handler, NULL); \n xfree(buf); \n }",
  "cwe": "CWE-119",
  "codeline": "buf = (char *) xmalloc(pkglen + 1);"
}
{
  "idx": 131,
  "target": 1,
  "vul": "ospf6_print_lshdr(netdissect_options *ndo, \n register const struct lsa6_hdr *lshp, const u_char *dataend) \n { \n if ((const u_char *)(lshp + 1) > dataend) \n goto trunc; \n ND_TCHECK(lshp->ls_type); \n ND_TCHECK(lshp->ls_seq); \n ND_PRINT((ndo, \"\\n\\t Advertising Router %s, seq 0x%08x, age %us, length %u\", \n ipaddr_string(ndo, &lshp->ls_router), \n EXTRACT_32BITS(&lshp->ls_seq), \n EXTRACT_16BITS(&lshp->ls_age), \n EXTRACT_16BITS(&lshp->ls_length)-(u_int)sizeof(struct lsa6_hdr))); \n ospf6_print_ls_type(ndo, EXTRACT_16BITS(&lshp->ls_type), &lshp->ls_stateid); \n return (0); \n trunc: \n return (1); \n }",
  "no_vul": "ospf6_print_lshdr(netdissect_options *ndo, \n register const struct lsa6_hdr *lshp, const u_char *dataend) \n { \n if ((const u_char *)(lshp + 1) > dataend) \n goto trunc; \n ND_TCHECK(lshp->ls_length); \n ND_PRINT((ndo, \"\\n\\t Advertising Router %s, seq 0x%08x, age %us, length %u\", \n ipaddr_string(ndo, &lshp->ls_router), \n EXTRACT_32BITS(&lshp->ls_seq), \n EXTRACT_16BITS(&lshp->ls_age), \n EXTRACT_16BITS(&lshp->ls_length)-(u_int)sizeof(struct lsa6_hdr))); \n ospf6_print_ls_type(ndo, EXTRACT_16BITS(&lshp->ls_type), &lshp->ls_stateid); \n return (0); \n trunc: \n return (1); \n }",
  "cwe": "CWE-125",
  "codeline": "ND_TCHECK(lshp->ls_type);"
}
{
  "idx": 132,
  "target": 1,
  "vul": "get_next_file(FILE *VFile, char *ptr) \n { \n char *ret; \n ret = fgets(ptr, PATH_MAX, VFile); \n if (!ret) \n return NULL; \n if (ptr[strlen(ptr) - 1] == '\\n') \n ptr[strlen(ptr) - 1] = '\\0'; \n return ret; \n }",
  "no_vul": "get_next_file(FILE *VFile, char *ptr) \n { \n char *ret; \n size_t len; \n ret = fgets(ptr, PATH_MAX, VFile); \n if (!ret) \n return NULL; \n len = strlen (ptr); \n if (len > 0 && ptr[len - 1] == '\\n') \n ptr[len - 1] = '\\0'; \n return ret; \n }",
  "cwe": "CWE-120",
  "codeline": "if (ptr[strlen(ptr) - 1] == '\\n')"
}
{
  "idx": 133,
  "target": 1,
  "vul": "static int dev_get_valid_name(struct net *net, \n struct net_device *dev, \n const char *name) \n { \n BUG_ON(!net); \n if (!dev_valid_name(name)) \n return -EINVAL; \n if (strchr(name, '%')) \n return dev_alloc_name_ns(net, dev, name); \n else if (__dev_get_by_name(net, name)) \n return -EEXIST; \n else if (dev->name != name) \n strlcpy(dev->name, name, IFNAMSIZ); \n return 0; \n }",
  "no_vul": "static int dev_get_valid_name(struct net *net, \n int dev_get_valid_name(struct net *net, struct net_device *dev, \n const char *name) \n { \n BUG_ON(!net); \n if (!dev_valid_name(name)) \n return -EINVAL; \n if (strchr(name, '%')) \n return dev_alloc_name_ns(net, dev, name); \n else if (__dev_get_by_name(net, name)) \n return -EEXIST; \n else if (dev->name != name) \n strlcpy(dev->name, name, IFNAMSIZ); \n return 0; \n }",
  "cwe": "CWE-476",
  "codeline": "else if (dev->name != name)"
}
{
  "idx": 134,
  "target": 1,
  "vul": "virDomainGetTime(virDomainPtr dom, \n long long *seconds, \n unsigned int *nseconds, \n unsigned int flags) \n { \n VIR_DOMAIN_DEBUG(dom, \"seconds=%p, nseconds=%p, flags=%x\", \n seconds, nseconds, flags); \n virResetLastError(); \n virCheckDomainReturn(dom, -1); \n if (dom->conn->driver->domainGetTime) { \n int ret = dom->conn->driver->domainGetTime(dom, seconds, \n nseconds, flags); \n if (ret < 0) \n goto error; \n return ret; \n } \n virReportUnsupportedError(); \n error: \n virDispatchError(dom->conn); \n return -1; \n }",
  "no_vul": "virDomainGetTime(virDomainPtr dom, \n long long *seconds, \n unsigned int *nseconds, \n unsigned int flags) \n { \n VIR_DOMAIN_DEBUG(dom, \"seconds=%p, nseconds=%p, flags=%x\", \n seconds, nseconds, flags); \n virResetLastError(); \n virCheckDomainReturn(dom, -1); \n virCheckReadOnlyGoto(dom->conn->flags, error); \n if (dom->conn->driver->domainGetTime) { \n int ret = dom->conn->driver->domainGetTime(dom, seconds, \n nseconds, flags); \n if (ret < 0) \n goto error; \n return ret; \n } \n virReportUnsupportedError(); \n error: \n virDispatchError(dom->conn); \n return -1; \n }",
  "cwe": "CWE-254",
  "codeline": "virCheckReadOnlyGoto(dom->conn->flags, error);"
}
{
  "idx": 135,
  "target": 1,
  "vul": "int vfs_open(const struct path *path, struct file *file, \n const struct cred *cred) \n { \n struct dentry *dentry = path->dentry; \n struct inode *inode = dentry->d_inode; \n file->f_path = *path; \n if (dentry->d_flags & DCACHE_OP_SELECT_INODE) { \n inode = dentry->d_op->d_select_inode(dentry, file->f_flags); \n if (IS_ERR(inode)) \n return PTR_ERR(inode); \n } \n return do_dentry_open(file, inode, NULL, cred); \n }",
  "no_vul": "int vfs_open(const struct path *path, struct file *file, \n const struct cred *cred) \n { \n struct inode *inode = vfs_select_inode(path->dentry, file->f_flags); \n if (IS_ERR(inode)) \n return PTR_ERR(inode); \n file->f_path = *path; \n return do_dentry_open(file, inode, NULL, cred); \n }",
  "cwe": "CWE-284",
  "codeline": "if (dentry->d_flags & DCACHE_OP_SELECT_INODE) { \ninode = dentry->d_op->d_select_inode(dentry, file->f_flags); \nif (IS_ERR(inode)) \nreturn PTR_ERR(inode); \n}"
}
{
  "idx": 136,
  "target": 1,
  "vul": "static bool ndp_msg_check_valid(struct ndp_msg *msg) \n { \n size_t len = ndp_msg_payload_len(msg); \n enum ndp_msg_type msg_type = ndp_msg_type(msg); \n if (len < ndp_msg_type_info(msg_type)->raw_struct_size) \n return false; \n return true; \n }",
  "no_vul": "static bool ndp_msg_check_valid(struct ndp_msg *msg) \n { \n size_t len = ndp_msg_payload_len(msg); \n enum ndp_msg_type msg_type = ndp_msg_type(msg); \n if (len < ndp_msg_type_info(msg_type)->raw_struct_size) \n return false; \n if (ndp_msg_type_info(msg_type)->addrto_validate) \n return ndp_msg_type_info(msg_type)->addrto_validate(&msg->addrto); \n else \n return true; \n }",
  "cwe": "CWE-284",
  "codeline": "if (len < ndp_msg_type_info(msg_type)->raw_struct_size) \nreturn false;"
}
{
  "idx": 137,
  "target": 1,
  "vul": "void usb_serial_console_disconnect(struct usb_serial *serial) \n { \n if (serial->port[0] == usbcons_info.port) { \n usb_serial_console_exit(); \n usb_serial_put(serial); \n } \n }",
  "no_vul": "void usb_serial_console_disconnect(struct usb_serial *serial) \n { \n if (serial->port[0] && serial->port[0] == usbcons_info.port) { \n usb_serial_console_exit(); \n usb_serial_put(serial); \n } \n }",
  "cwe": "CWE-416",
  "codeline": "if (serial->port[0] == usbcons_info.port) {"
}
{
  "idx": 138,
  "target": 1,
  "vul": "ModuleExport size_t RegisterMPCImage(void) \n { \n MagickInfo \n *entry; \n entry=SetMagickInfo(\"CACHE\"); \n entry->description=ConstantString(\"Magick Persistent Cache image format\"); \n entry->module=ConstantString(\"MPC\"); \n entry->seekable_stream=MagickTrue; \n entry->stealth=MagickTrue; \n (void) RegisterMagickInfo(entry); \n entry=SetMagickInfo(\"MPC\"); \n entry->decoder=(DecodeImageHandler *) ReadMPCImage; \n entry->encoder=(EncodeImageHandler *) WriteMPCImage; \n entry->magick=(IsImageFormatHandler *) IsMPC; \n entry->description=ConstantString(\"Magick Persistent Cache image format\"); \n entry->seekable_stream=MagickTrue; \n entry->module=ConstantString(\"MPC\"); \n (void) RegisterMagickInfo(entry); \n return(MagickImageCoderSignature); \n }",
  "no_vul": "ModuleExport size_t RegisterMPCImage(void) \n { \n MagickInfo \n *entry; \n entry=SetMagickInfo(\"CACHE\"); \n entry->description=ConstantString(\"Magick Persistent Cache image format\"); \n entry->module=ConstantString(\"MPC\"); \n entry->stealth=MagickTrue; \n (void) RegisterMagickInfo(entry); \n entry=SetMagickInfo(\"MPC\"); \n entry->decoder=(DecodeImageHandler *) ReadMPCImage; \n entry->encoder=(EncodeImageHandler *) WriteMPCImage; \n entry->magick=(IsImageFormatHandler *) IsMPC; \n entry->description=ConstantString(\"Magick Persistent Cache image format\"); \n entry->seekable_stream=MagickTrue; \n entry->module=ConstantString(\"MPC\"); \n (void) RegisterMagickInfo(entry); \n return(MagickImageCoderSignature); \n }",
  "cwe": "CWE-20",
  "codeline": "entry->seekable_stream=MagickTrue;"
}
{
  "idx": 139,
  "target": 1,
  "vul": "MagickExport int LocaleLowercase(const int c) \n { \n if (c < 0) \n return(c); \n #if defined(MAGICKCORE_LOCALE_SUPPORT) \n if (c_locale != (locale_t) NULL) \n return(tolower_l((int) ((unsigned char) c),c_locale)); \n #endif \n return(tolower((int) ((unsigned char) c))); \n }",
  "no_vul": "MagickExport int LocaleLowercase(const int c) \n { \n if (c == EOF) \n return(c); \n #if defined(MAGICKCORE_LOCALE_SUPPORT) \n if (c_locale != (locale_t) NULL) \n return(tolower_l((int) ((unsigned char) c),c_locale)); \n #endif \n return(tolower((int) ((unsigned char) c))); \n }",
  "cwe": "CWE-125",
  "codeline": "if (c < 0) \nreturn(c);"
}
{
  "idx": 140,
  "target": 1,
  "vul": "BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate( \n TabContents* tab_contents, \n const string16& utf16_name) \n : PluginInfoBarDelegate(tab_contents, utf16_name) { \n UserMetrics::RecordAction(UserMetricsAction(\"BlockedPluginInfobar.Shown\")); \n std::string name = UTF16ToUTF8(utf16_name); \n if (name == webkit::npapi::PluginGroup::kJavaGroupName) \n UserMetrics::RecordAction( \n UserMetricsAction(\"BlockedPluginInfobar.Shown.Java\")); \n else if (name == webkit::npapi::PluginGroup::kQuickTimeGroupName) \n UserMetrics::RecordAction( \n UserMetricsAction(\"BlockedPluginInfobar.Shown.QuickTime\")); \n else if (name == webkit::npapi::PluginGroup::kShockwaveGroupName) \n UserMetrics::RecordAction( \n UserMetricsAction(\"BlockedPluginInfobar.Shown.Shockwave\")); \n else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName) \n UserMetrics::RecordAction( \n UserMetricsAction(\"BlockedPluginInfobar.Shown.RealPlayer\")); \n }",
  "no_vul": "BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate( \n TabContents* tab_contents, \n const string16& utf16_name) \n : PluginInfoBarDelegate(tab_contents, utf16_name) { \n UserMetrics::RecordAction(UserMetricsAction(\"BlockedPluginInfobar.Shown\")); \n std::string name = UTF16ToUTF8(utf16_name); \n if (name == webkit::npapi::PluginGroup::kJavaGroupName) \n UserMetrics::RecordAction( \n UserMetricsAction(\"BlockedPluginInfobar.Shown.Java\")); \n else if (name == webkit::npapi::PluginGroup::kQuickTimeGroupName) \n UserMetrics::RecordAction( \n UserMetricsAction(\"BlockedPluginInfobar.Shown.QuickTime\")); \n else if (name == webkit::npapi::PluginGroup::kShockwaveGroupName) \n UserMetrics::RecordAction( \n UserMetricsAction(\"BlockedPluginInfobar.Shown.Shockwave\")); \n else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName) \n UserMetrics::RecordAction( \n UserMetricsAction(\"BlockedPluginInfobar.Shown.RealPlayer\")); \n else if (name == webkit::npapi::PluginGroup::kWindowsMediaPlayerGroupName) \n UserMetrics::RecordAction( \n UserMetricsAction(\"BlockedPluginInfobar.Shown.WindowsMediaPlayer\")); \n }",
  "cwe": "CWE-264",
  "codeline": "else if (name == webkit::npapi::PluginGroup::kWindowsMediaPlayerGroupName) \n UserMetrics::RecordAction( \n UserMetricsAction(\"BlockedPluginInfobar.Shown.WindowsMediaPlayer\"));"
}
{
  "idx": 141,
  "target": 1,
  "vul": "NativeBrowserFrame* NativeBrowserFrame::CreateNativeBrowserFrame( \n BrowserFrame* browser_frame, \n BrowserView* browser_view) { \n if (views::Widget::IsPureViews()) \n return new BrowserFrameViews(browser_frame, browser_view); \n return new BrowserFrameGtk(browser_frame, browser_view); \n }",
  "no_vul": "NativeBrowserFrame* NativeBrowserFrame::CreateNativeBrowserFrame( \n BrowserFrame* browser_frame, \n BrowserView* browser_view) { \n if (views::Widget::IsPureViews() && \n views::ViewsDelegate::views_delegate->GetDefaultParentView()) \n return new BrowserFrameViews(browser_frame, browser_view); \n return new BrowserFrameGtk(browser_frame, browser_view); \n }",
  "cwe": "CWE-399",
  "codeline": "if (views::Widget::IsPureViews())"
}
{
  "idx": 142,
  "target": 1,
  "vul": "void FocusFirstNameField() { \n LOG(WARNING) << \"Clicking on the tab.\"; \n ASSERT_NO_FATAL_FAILURE(ui_test_utils::ClickOnView(browser(), \n VIEW_ID_TAB_CONTAINER)); \n ASSERT_TRUE(ui_test_utils::IsViewFocused(browser(), \n VIEW_ID_TAB_CONTAINER)); \n LOG(WARNING) << \"Focusing the first name field.\"; \n bool result = false; \n ASSERT_TRUE(ui_test_utils::ExecuteJavaScriptAndExtractBool( \n render_view_host(), L\"\", \n L\"if (document.readyState === 'complete')\" \n L\" document.getElementById('firstname').focus();\" \n L\"else\" \n L\" domAutomationController.send(false);\", \n &result)); \n ASSERT_TRUE(result); \n }",
  "no_vul": "void FocusFirstNameField() { \n LOG(WARNING) << \"Clicking on the tab.\"; \n ui_test_utils::SimulateMouseClick(browser()->GetSelectedWebContents()); \n LOG(WARNING) << \"Focusing the first name field.\"; \n bool result = false; \n ASSERT_TRUE(ui_test_utils::ExecuteJavaScriptAndExtractBool( \n render_view_host(), L\"\", \n L\"if (document.readyState === 'complete')\" \n L\" document.getElementById('firstname').focus();\" \n L\"else\" \n L\" domAutomationController.send(false);\", \n &result)); \n ASSERT_TRUE(result); \n }",
  "cwe": "CWE-119",
  "codeline": "ASSERT_NO_FATAL_FAILURE(ui_test_utils::ClickOnView(browser(), \n VIEW_ID_TAB_CONTAINER));"
}
{
  "idx": 143,
  "target": 1,
  "vul": "bool BaseSettingChange::Init(Profile* profile) { \n DCHECK(profile); \n profile_ = profile; \n return true; \n }",
  "no_vul": "bool BaseSettingChange::Init(Profile* profile) { \n DCHECK(profile && !profile_); \n profile_ = profile; \n return true; \n }",
  "cwe": "CWE-119",
  "codeline": "profile_ = profile;"
}
{
  "idx": 144,
  "target": 1,
  "vul": "PowerPopupView() { \n SetHorizontalAlignment(ALIGN_RIGHT); \n UpdateText(); \n }",
  "no_vul": "PowerPopupView() { \n SetHorizontalAlignment(ALIGN_RIGHT); \n SetMultiLine(true); \n UpdateText(); \n }",
  "cwe": "CWE-399",
  "codeline": "SetHorizontalAlignment(ALIGN_RIGHT);"
}
{
  "idx": 145,
  "target": 1,
  "vul": "virtual void SetUpCommandLine(CommandLine* command_line) { \n GpuFeatureTest::SetUpCommandLine(command_line); \n command_line->AppendSwitch(switches::kEnableThreadedCompositing); \n }",
  "no_vul": "virtual void SetUpCommandLine(CommandLine* command_line) { \n GpuFeatureTest::SetUpCommandLine(command_line); \n command_line->AppendSwitch(switches::kDisableAcceleratedCompositing); \n }",
  "cwe": "CWE-399",
  "codeline": "command_line->AppendSwitch(switches::kEnableThreadedCompositing);"
}
{
  "idx": 146,
  "target": 1,
  "vul": "void removeAllDOMObjects() \n { \n DOMDataStore& store = DOMData::getCurrentStore(); \n v8::HandleScope scope; \n if (isMainThread()) { \n DOMData::removeObjectsFromWrapperMap<Node>(&store, store.domNodeMap()); \n DOMData::removeObjectsFromWrapperMap<Node>(&store, store.activeDomNodeMap()); \n } \n DOMData::removeObjectsFromWrapperMap<void>(&store, store.domObjectMap()); \n }",
  "no_vul": "void removeAllDOMObjects() \n { \n DOMDataStore& store = DOMData::getCurrentStore(); \n v8::HandleScope scope; \n ASSERT(!isMainThread()); \n DOMData::removeObjectsFromWrapperMap<void>(&store, store.domObjectMap()); \n }",
  "cwe": "CWE-119",
  "codeline": "DOMData::removeObjectsFromWrapperMap<Node>(&store, store.domNodeMap());"
}
{
  "idx": 147,
  "target": 1,
  "vul": "static void setPathFromConvexPoints(SkPath* path, size_t numPoints, const FloatPoint* points) \n { \n path->incReserve(numPoints); \n path->moveTo(WebCoreFloatToSkScalar(points[0].x()), \n WebCoreFloatToSkScalar(points[0].y())); \n for (size_t i = 1; i < numPoints; ++i) { \n path->lineTo(WebCoreFloatToSkScalar(points[i].x()), \n WebCoreFloatToSkScalar(points[i].y())); \n } \n path->setIsConvex(true); \n }",
  "no_vul": "static void setPathFromConvexPoints(SkPath* path, size_t numPoints, const FloatPoint* points) \n { \n path->incReserve(numPoints); \n path->moveTo(WebCoreFloatToSkScalar(points[0].x()), \n WebCoreFloatToSkScalar(points[0].y())); \n for (size_t i = 1; i < numPoints; ++i) { \n path->lineTo(WebCoreFloatToSkScalar(points[i].x()), \n WebCoreFloatToSkScalar(points[i].y())); \n } \n SkPath::Convexity convexity = SkPath::kConvex_Convexity; \n if (numPoints == 4) \n convexity = SkPath::kUnknown_Convexity; \n path->setConvexity(convexity); \n }",
  "cwe": "CWE-19",
  "codeline": "path->setIsConvex(true);"
}
{
  "idx": 148,
  "target": 1,
  "vul": "static void _ewk_frame_smart_del(Evas_Object* ewkFrame) \n { \n EWK_FRAME_SD_GET(ewkFrame, smartData); \n if (smartData) { \n if (smartData->frame) { \n WebCore::FrameLoaderClientEfl* flc = _ewk_frame_loader_efl_get(smartData->frame); \n flc->setWebFrame(0); \n smartData->frame->loader()->detachFromParent(); \n smartData->frame->loader()->cancelAndClear(); \n smartData->frame = 0; \n } \n eina_stringshare_del(smartData->title); \n eina_stringshare_del(smartData->uri); \n eina_stringshare_del(smartData->name); \n } \n _parent_sc.del(ewkFrame); \n }",
  "no_vul": "static void _ewk_frame_smart_del(Evas_Object* ewkFrame) \n { \n EWK_FRAME_SD_GET(ewkFrame, smartData); \n if (smartData) { \n if (smartData->frame) { \n WebCore::FrameLoaderClientEfl* flc = _ewk_frame_loader_efl_get(smartData->frame); \n flc->setWebFrame(0); \n EWK_FRAME_SD_GET(ewk_view_frame_main_get(smartData->view), mainSmartData); \n if (mainSmartData->frame == smartData->frame) \n smartData->frame->loader()->detachFromParent(); \n smartData->frame = 0; \n } \n eina_stringshare_del(smartData->title); \n eina_stringshare_del(smartData->uri); \n eina_stringshare_del(smartData->name); \n } \n _parent_sc.del(ewkFrame); \n }",
  "cwe": "CWE-399",
  "codeline": "smartData->frame->loader()->detachFromParent();"
}
{
  "idx": 149,
  "target": 1,
  "vul": "int BrowserNonClientFrameViewAura::NonClientTopBorderHeight( \n bool force_restored) const { \n if (frame()->widget_delegate() && \n frame()->widget_delegate()->ShouldShowWindowTitle()) { \n return close_button_->bounds().bottom(); \n } \n if (!frame()->IsMaximized() || force_restored) \n return kTabstripTopSpacingRestored; \n return kTabstripTopSpacingMaximized; \n }",
  "no_vul": "int BrowserNonClientFrameViewAura::NonClientTopBorderHeight( \n bool force_restored) const { \n if (force_restored) \n return kTabstripTopSpacingRestored; \n if (frame()->IsFullscreen()) \n return 0; \n if (frame()->IsMaximized()) \n return kTabstripTopSpacingMaximized; \n if (frame()->widget_delegate() && \n frame()->widget_delegate()->ShouldShowWindowTitle()) { \n return close_button_->bounds().bottom(); \n } \n return kTabstripTopSpacingRestored; \n }",
  "cwe": "CWE-119",
  "codeline": "return close_button_->bounds().bottom();"
}
{
  "idx": 150,
  "target": 1,
  "vul": "void OmniboxEditModel::RestoreState(const State* state) { \n controller_->GetToolbarModel()->set_url_replacement_enabled( \n !state || state->url_replacement_enabled); \n permanent_text_ = controller_->GetToolbarModel()->GetText(); \n view_->RevertWithoutResettingSearchTermReplacement(); \n input_ = state ? state->autocomplete_input : AutocompleteInput(); \n if (!state) \n return; \n SetFocusState(state->focus_state, OMNIBOX_FOCUS_CHANGE_TAB_SWITCH); \n focus_source_ = state->focus_source; \n if (state->user_input_in_progress) { \n keyword_ = state->keyword; \n is_keyword_hint_ = state->is_keyword_hint; \n view_->SetUserText(state->user_text, \n DisplayTextFromUserText(state->user_text), false); \n view_->SetGrayTextAutocompletion(state->gray_text); \n } \n }",
  "no_vul": "void OmniboxEditModel::RestoreState(const State* state) { \n bool url_replacement_enabled = !state || state->url_replacement_enabled; \n controller_->GetToolbarModel()->set_url_replacement_enabled( \n url_replacement_enabled); \n controller_->GetToolbarModel()->set_origin_chip_enabled( \n url_replacement_enabled); \n permanent_text_ = controller_->GetToolbarModel()->GetText(); \n view_->RevertWithoutResettingSearchTermReplacement(); \n input_ = state ? state->autocomplete_input : AutocompleteInput(); \n if (!state) \n return; \n SetFocusState(state->focus_state, OMNIBOX_FOCUS_CHANGE_TAB_SWITCH); \n focus_source_ = state->focus_source; \n if (state->user_input_in_progress) { \n keyword_ = state->keyword; \n is_keyword_hint_ = state->is_keyword_hint; \n view_->SetUserText(state->user_text, \n DisplayTextFromUserText(state->user_text), false); \n view_->SetGrayTextAutocompletion(state->gray_text); \n } \n }",
  "cwe": "CWE-362",
  "codeline": "controller_->GetToolbarModel()->set_url_replacement_enabled( \n !state || state->url_replacement_enabled);"
}
{
  "idx": 151,
  "target": 1,
  "vul": "xsltStylesheetPtr XSLStyleSheet::compileStyleSheet() \n { \n if (m_embedded) \n return xsltLoadStylesheetPI(document()); \n ASSERT(!m_stylesheetDocTaken); \n xsltStylesheetPtr result = xsltParseStylesheetDoc(m_stylesheetDoc); \n if (result) \n m_stylesheetDocTaken = true; \n return result; \n }",
  "no_vul": "xsltStylesheetPtr XSLStyleSheet::compileStyleSheet() \n { \n if (m_embedded) \n return xsltLoadStylesheetPI(document()); \n if (m_compilationFailed) \n return 0; \n ASSERT(!m_stylesheetDocTaken); \n xsltStylesheetPtr result = xsltParseStylesheetDoc(m_stylesheetDoc); \n if (result) \n m_stylesheetDocTaken = true; \n else \n m_compilationFailed = true; \n return result; \n }",
  "cwe": "CWE-399",
  "codeline": "xsltStylesheetPtr result = xsltParseStylesheetDoc(m_stylesheetDoc);"
}
{
  "idx": 152,
  "target": 1,
  "vul": "void ColorChooserDialog::DidCloseDialog(bool chose_color, \n SkColor color, \n RunState run_state) { \n if (!listener_) \n return; \n EndRun(run_state); \n CopyCustomColors(custom_colors_, g_custom_colors); \n if (chose_color) \n listener_->OnColorChosen(color); \n listener_->OnColorChooserDialogClosed(); \n }",
  "no_vul": "void ColorChooserDialog::DidCloseDialog(bool chose_color, \n SkColor color, \n RunState run_state) { \n EndRun(run_state); \n CopyCustomColors(custom_colors_, g_custom_colors); \n if (listener_) { \n if (chose_color) \n listener_->OnColorChosen(color); \n listener_->OnColorChooserDialogClosed(); \n } \n }",
  "cwe": "CWE-399",
  "codeline": "if (!listener_) \nreturn;"
}
{
  "idx": 153,
  "target": 1,
  "vul": "void CreateAuthenticatorFactory() { \n DCHECK(context_->network_task_runner()->BelongsToCurrentThread()); \n std::string local_certificate = key_pair_.GenerateCertificate(); \n if (local_certificate.empty()) { \n LOG(ERROR) << \"Failed to generate host certificate.\"; \n Shutdown(kHostInitializationFailed); \n return; \n } \n scoped_ptr<protocol::AuthenticatorFactory> factory( \n new protocol::Me2MeHostAuthenticatorFactory( \n local_certificate, *key_pair_.private_key(), host_secret_hash_)); \n host_->SetAuthenticatorFactory(factory.Pass()); \n }",
  "no_vul": "void CreateAuthenticatorFactory() { \n DCHECK(context_->network_task_runner()->BelongsToCurrentThread()); \n if (!host_ || shutting_down_) \n return; \n std::string local_certificate = key_pair_.GenerateCertificate(); \n if (local_certificate.empty()) { \n LOG(ERROR) << \"Failed to generate host certificate.\"; \n Shutdown(kHostInitializationFailed); \n return; \n } \n scoped_ptr<protocol::AuthenticatorFactory> factory( \n new protocol::Me2MeHostAuthenticatorFactory( \n local_certificate, *key_pair_.private_key(), host_secret_hash_)); \n host_->SetAuthenticatorFactory(factory.Pass()); \n }",
  "cwe": "CWE-119",
  "codeline": "host_->SetAuthenticatorFactory(factory.Pass());"
}
{
  "idx": 154,
  "target": 1,
  "vul": "void BookmarksIOFunction::ShowSelectFileDialog( \n ui::SelectFileDialog::Type type, \n const base::FilePath& default_path) { \n AddRef(); \n WebContents* web_contents = dispatcher()->delegate()-> \n GetAssociatedWebContents(); \n select_file_dialog_ = ui::SelectFileDialog::Create( \n this, new ChromeSelectFilePolicy(web_contents)); \n ui::SelectFileDialog::FileTypeInfo file_type_info; \n file_type_info.extensions.resize(1); \n file_type_info.extensions[0].push_back(FILE_PATH_LITERAL(\"html\")); \n if (type == ui::SelectFileDialog::SELECT_OPEN_FILE) \n file_type_info.support_drive = true; \n select_file_dialog_->SelectFile(type, \n string16(), \n default_path, \n &file_type_info, \n 0, \n FILE_PATH_LITERAL(\"\"), \n NULL, \n NULL); \n }",
  "no_vul": "void BookmarksIOFunction::ShowSelectFileDialog( \n ui::SelectFileDialog::Type type, \n const base::FilePath& default_path) { \n if (!dispatcher()) \n return; \n AddRef(); \n WebContents* web_contents = dispatcher()->delegate()-> \n GetAssociatedWebContents(); \n select_file_dialog_ = ui::SelectFileDialog::Create( \n this, new ChromeSelectFilePolicy(web_contents)); \n ui::SelectFileDialog::FileTypeInfo file_type_info; \n file_type_info.extensions.resize(1); \n file_type_info.extensions[0].push_back(FILE_PATH_LITERAL(\"html\")); \n if (type == ui::SelectFileDialog::SELECT_OPEN_FILE) \n file_type_info.support_drive = true; \n select_file_dialog_->SelectFile(type, \n string16(), \n default_path, \n &file_type_info, \n 0, \n FILE_PATH_LITERAL(\"\"), \n NULL, \n NULL); \n }",
  "cwe": "CWE-399",
  "codeline": "WebContents* web_contents = dispatcher()->delegate()-> \n GetAssociatedWebContents();"
}
{
  "idx": 155,
  "target": 1,
  "vul": "bool ResourceDispatcherHostImpl::AcceptAuthRequest( \n ResourceLoader* loader, \n net::AuthChallengeInfo* auth_info) { \n if (delegate_ && !delegate_->AcceptAuthRequest(loader->request(), auth_info)) \n return false; \n if (!auth_info->is_proxy) { \n HttpAuthResourceType resource_type = \n HttpAuthResourceTypeOf(loader->request()); \n UMA_HISTOGRAM_ENUMERATION(\"Net.HttpAuthResource\", \n resource_type, \n HTTP_AUTH_RESOURCE_LAST); \n if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS) \n return false; \n } \n return true; \n }",
  "no_vul": "bool ResourceDispatcherHostImpl::AcceptAuthRequest( \n ResourceLoader* loader, \n net::AuthChallengeInfo* auth_info) { \n if (delegate_ && !delegate_->AcceptAuthRequest(loader->request(), auth_info)) \n return false; \n if (!auth_info->is_proxy) { \n HttpAuthResourceType resource_type = \n HttpAuthResourceTypeOf(loader->request()); \n UMA_HISTOGRAM_ENUMERATION(\"Net.HttpAuthResource\", \n resource_type, \n HTTP_AUTH_RESOURCE_LAST); \n } \n return true; \n }",
  "cwe": "CWE-264",
  "codeline": "if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS) \n return false;"
}
{
  "idx": 156,
  "target": 1,
  "vul": "void LayerWebKitThread::setNeedsCommit() \n { \n if (m_owner) \n m_owner->notifySyncRequired(); \n }",
  "no_vul": "void LayerWebKitThread::setNeedsCommit() \n { \n if (m_owner) \n m_owner->notifyFlushRequired(); \n }",
  "cwe": "CWE-20",
  "codeline": "m_owner->notifySyncRequired();"
}
{
  "idx": 157,
  "target": 1,
  "vul": "int MockNetworkTransaction::RestartWithAuth( \n const AuthCredentials& credentials, \n const CompletionCallback& callback) { \n if (!IsReadyToRestartForAuth()) \n return ERR_FAILED; \n HttpRequestInfo auth_request_info = *request_; \n auth_request_info.extra_headers.AddHeaderFromString(\"Authorization: Bar\"); \n return StartInternal(&auth_request_info, callback, BoundNetLog()); \n }",
  "no_vul": "int MockNetworkTransaction::RestartWithAuth( \n const AuthCredentials& credentials, \n const CompletionCallback& callback) { \n if (!IsReadyToRestartForAuth()) \n return ERR_FAILED; \n HttpRequestInfo auth_request_info = *request_; \n auth_request_info.extra_headers.SetHeader(\"Authorization\", \"Bar\"); \n return StartInternal(&auth_request_info, callback, BoundNetLog()); \n }",
  "cwe": "CWE-119",
  "codeline": "auth_request_info.extra_headers.AddHeaderFromString(\"Authorization: Bar\");"
}
{
  "idx": 158,
  "target": 1,
  "vul": "void FrameView::updateLayoutAndStyleForPainting() \n { \n RefPtr<FrameView> protector(this); \n updateLayoutAndStyleIfNeededRecursive(); \n if (RenderView* view = renderView()) { \n TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline\"), \"UpdateLayerTree\", \"frame\", m_frame.get()); \n InspectorInstrumentation::willUpdateLayerTree(m_frame.get()); \n view->compositor()->updateIfNeededRecursive(); \n if (view->compositor()->inCompositingMode() && m_frame->isLocalRoot()) \n m_frame->page()->scrollingCoordinator()->updateAfterCompositingChangeIfNeeded(); \n updateCompositedSelectionBoundsIfNeeded(); \n InspectorInstrumentation::didUpdateLayerTree(m_frame.get()); \n invalidateTreeIfNeededRecursive(); \n } \n scrollContentsIfNeededRecursive(); \n ASSERT(lifecycle().state() == DocumentLifecycle::PaintInvalidationClean); \n }",
  "no_vul": "void FrameView::updateLayoutAndStyleForPainting() \n { \n RefPtr<FrameView> protector(this); \n updateLayoutAndStyleIfNeededRecursive(); \n updateWidgetPositionsIfNeeded(); \n if (RenderView* view = renderView()) { \n TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline\"), \"UpdateLayerTree\", \"frame\", m_frame.get()); \n InspectorInstrumentation::willUpdateLayerTree(m_frame.get()); \n view->compositor()->updateIfNeededRecursive(); \n if (view->compositor()->inCompositingMode() && m_frame->isLocalRoot()) \n m_frame->page()->scrollingCoordinator()->updateAfterCompositingChangeIfNeeded(); \n updateCompositedSelectionBoundsIfNeeded(); \n InspectorInstrumentation::didUpdateLayerTree(m_frame.get()); \n invalidateTreeIfNeededRecursive(); \n } \n scrollContentsIfNeededRecursive(); \n ASSERT(lifecycle().state() == DocumentLifecycle::PaintInvalidationClean); \n }",
  "cwe": "CWE-416",
  "codeline": "updateLayoutAndStyleIfNeededRecursive();"
}
{
  "idx": 159,
  "target": 1,
  "vul": "bool AsyncPixelTransfersCompletedQuery::End( \n base::subtle::Atomic32 submit_count) { \n AsyncMemoryParams mem_params; \n Buffer buffer = manager()->decoder()->GetSharedMemoryBuffer(shm_id()); \n if (!buffer.shared_memory) \n return false; \n mem_params.shared_memory = buffer.shared_memory; \n mem_params.shm_size = buffer.size; \n mem_params.shm_data_offset = shm_offset(); \n mem_params.shm_data_size = sizeof(QuerySync); \n observer_ = new AsyncPixelTransferCompletionObserverImpl(submit_count); \n manager()->decoder()->GetAsyncPixelTransferManager() \n ->AsyncNotifyCompletion(mem_params, observer_); \n return AddToPendingTransferQueue(submit_count); \n }",
  "no_vul": "bool AsyncPixelTransfersCompletedQuery::End( \n base::subtle::Atomic32 submit_count) { \n AsyncMemoryParams mem_params; \n Buffer buffer = manager()->decoder()->GetSharedMemoryBuffer(shm_id()); \n if (!buffer.shared_memory) \n return false; \n mem_params.shared_memory = buffer.shared_memory; \n mem_params.shm_size = buffer.size; \n mem_params.shm_data_offset = shm_offset(); \n mem_params.shm_data_size = sizeof(QuerySync); \n uint32 end = mem_params.shm_data_offset + mem_params.shm_data_size; \n if (end > mem_params.shm_size || end < mem_params.shm_data_offset) \n return false; \n observer_ = new AsyncPixelTransferCompletionObserverImpl(submit_count); \n manager()->decoder()->GetAsyncPixelTransferManager() \n ->AsyncNotifyCompletion(mem_params, observer_); \n return AddToPendingTransferQueue(submit_count); \n }",
  "cwe": "CWE-119",
  "codeline": "mem_params.shm_data_size = sizeof(QuerySync);"
}
{
  "idx": 160,
  "target": 1,
  "vul": "bool IsSmartVirtualKeyboardEnabled() { \n if (base::CommandLine::ForCurrentProcess()->HasSwitch( \n keyboard::switches::kEnableVirtualKeyboard)) { \n return false; \n } \n return !base::CommandLine::ForCurrentProcess()->HasSwitch( \n keyboard::switches::kDisableSmartVirtualKeyboard); \n }",
  "no_vul": "bool IsSmartVirtualKeyboardEnabled() { \n if (base::CommandLine::ForCurrentProcess()->HasSwitch( \n keyboard::switches::kEnableVirtualKeyboard)) { \n return false; \n } \n return keyboard::IsSmartDeployEnabled(); \n }",
  "cwe": "CWE-399",
  "codeline": "return !base::CommandLine::ForCurrentProcess()->HasSwitch( \n keyboard::switches::kDisableSmartVirtualKeyboard);"
}
{
  "idx": 161,
  "target": 1,
  "vul": "void SVGImage::setContainerSize(const IntSize& size) \n { \n if (!m_page || !usesContainerSize()) \n return; \n LocalFrame* frame = m_page->mainFrame(); \n SVGSVGElement* rootElement = toSVGDocument(frame->document())->rootElement(); \n if (!rootElement) \n return; \n RenderSVGRoot* renderer = toRenderSVGRoot(rootElement->renderer()); \n if (!renderer) \n return; \n FrameView* view = frameView(); \n view->resize(this->containerSize()); \n renderer->setContainerSize(size); \n }",
  "no_vul": "void SVGImage::setContainerSize(const IntSize& size) \n { \n if (!m_page || !usesContainerSize()) \n return; \n LocalFrame* frame = m_page->mainFrame(); \n SVGSVGElement* rootElement = toSVGDocument(frame->document())->rootElement(); \n if (!rootElement) \n return; \n FrameView* view = frameView(); \n view->resize(this->containerSize()); \n RenderSVGRoot* renderer = toRenderSVGRoot(rootElement->renderer()); \n if (!renderer) \n return; \n renderer->setContainerSize(size); \n }",
  "cwe": "CWE-399",
  "codeline": "view->resize(this->containerSize());"
}
{
  "idx": 162,
  "target": 1,
  "vul": "int32_t PepperFlashRendererHost::OnNavigate( \n ppapi::host::HostMessageContext* host_context, \n const ppapi::URLRequestInfoData& data, \n const std::string& target, \n bool from_user_action) { \n content::PepperPluginInstance* plugin_instance = \n host_->GetPluginInstance(pp_instance()); \n if (!plugin_instance) \n return PP_ERROR_FAILED; \n ppapi::proxy::HostDispatcher* host_dispatcher = \n ppapi::proxy::HostDispatcher::GetForInstance(pp_instance()); \n host_dispatcher->set_allow_plugin_reentrancy(); \n base::WeakPtr<PepperFlashRendererHost> weak_ptr = weak_factory_.GetWeakPtr(); \n navigate_replies_.push_back(host_context->MakeReplyMessageContext()); \n plugin_instance->Navigate(data, target.c_str(), from_user_action); \n if (weak_ptr.get()) { \n SendReply(navigate_replies_.back(), IPC::Message()); \n navigate_replies_.pop_back(); \n } \n return PP_OK_COMPLETIONPENDING; \n }",
  "no_vul": "int32_t PepperFlashRendererHost::OnNavigate( \n ppapi::host::HostMessageContext* host_context, \n const ppapi::URLRequestInfoData& data, \n const std::string& target, \n bool from_user_action) { \n content::PepperPluginInstance* plugin_instance = \n host_->GetPluginInstance(pp_instance()); \n if (!plugin_instance) \n return PP_ERROR_FAILED; \n std::map<std::string, FlashNavigateUsage>& rejected_headers = \n g_rejected_headers.Get(); \n if (rejected_headers.empty()) { \n for (size_t i = 0; i < arraysize(kRejectedHttpRequestHeaders); ++i) \n rejected_headers[kRejectedHttpRequestHeaders[i]] = \n static_cast<FlashNavigateUsage>(i); \n } \n net::HttpUtil::HeadersIterator header_iter(data.headers.begin(), \n data.headers.end(), \n \"\\n\\r\"); \n bool rejected = false; \n while (header_iter.GetNext()) { \n std::string lower_case_header_name = StringToLowerASCII(header_iter.name()); \n if (!IsSimpleHeader(lower_case_header_name, header_iter.values())) { \n rejected = true; \n std::map<std::string, FlashNavigateUsage>::const_iterator iter = \n rejected_headers.find(lower_case_header_name); \n FlashNavigateUsage usage = iter != rejected_headers.end() ? \n iter->second : REJECT_OTHER_HEADERS; \n RecordFlashNavigateUsage(usage); \n } \n } \n RecordFlashNavigateUsage(TOTAL_NAVIGATE_REQUESTS); \n if (rejected) { \n RecordFlashNavigateUsage(TOTAL_REJECTED_NAVIGATE_REQUESTS); \n return PP_ERROR_NOACCESS; \n } \n ppapi::proxy::HostDispatcher* host_dispatcher = \n ppapi::proxy::HostDispatcher::GetForInstance(pp_instance()); \n host_dispatcher->set_allow_plugin_reentrancy(); \n base::WeakPtr<PepperFlashRendererHost> weak_ptr = weak_factory_.GetWeakPtr(); \n navigate_replies_.push_back(host_context->MakeReplyMessageContext()); \n plugin_instance->Navigate(data, target.c_str(), from_user_action); \n if (weak_ptr.get()) { \n SendReply(navigate_replies_.back(), IPC::Message()); \n navigate_replies_.pop_back(); \n } \n return PP_OK_COMPLETIONPENDING; \n }",
  "cwe": "CWE-399",
  "codeline": "plugin_instance->Navigate(data, target.c_str(), from_user_action);"
}
{
  "idx": 163,
  "target": 1,
  "vul": "void FormAssociatedElement::formRemovedFromTree(const Node* formRoot) \n { \n ASSERT(m_form); \n if (toHTMLElement(this)->highestAncestor() != formRoot) \n setForm(0); \n }",
  "no_vul": "void FormAssociatedElement::formRemovedFromTree(const Node* formRoot) \n { \n ASSERT(m_form); \n if (toHTMLElement(this)->highestAncestor() == formRoot) \n return; \n RefPtr<HTMLElement> protector(toHTMLElement(this)); \n setForm(0); \n }",
  "cwe": "CWE-287",
  "codeline": "if (toHTMLElement(this)->highestAncestor() != formRoot) \nsetForm(0);"
}
{
  "idx": 164,
  "target": 1,
  "vul": "void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item, \n int64_t offline_id) { \n JNIEnv* env = AttachCurrentThread(); \n Java_OfflinePageDownloadBridge_openItem( \n env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id); \n }",
  "no_vul": "void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item, \n int64_t offline_id) { \n JNIEnv* env = AttachCurrentThread(); \n Java_OfflinePageDownloadBridge_openItem( \n env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id, \n offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct()); \n }",
  "cwe": "CWE-264",
  "codeline": "Java_OfflinePageDownloadBridge_openItem( \n env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id);"
}
{
  "idx": 165,
  "target": 1,
  "vul": "bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const \n { \n if (m_allowStar) \n return true; \n KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url; \n if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL)) \n return true; \n for (size_t i = 0; i < m_list.size(); ++i) { \n if (m_list[i].matches(effectiveURL, redirectStatus)) \n return true; \n } \n return false; \n }",
  "no_vul": "bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const \n { \n if (m_allowStar) { \n if (url.protocolIs(\"blob\") || url.protocolIs(\"data\") || url.protocolIs(\"filesystem\")) \n return hasSourceMatchInList(url, redirectStatus); \n return true; \n } \n KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url; \n if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL)) \n return true; \n return hasSourceMatchInList(effectiveURL, redirectStatus); \n }",
  "cwe": "CWE-264",
  "codeline": "if (m_allowStar) \nreturn true;"
}
{
  "idx": 166,
  "target": 1,
  "vul": "void MidiManagerUsb::DispatchSendMidiData(MidiManagerClient* client, \n uint32_t port_index, \n const std::vector<uint8>& data, \n double timestamp) { \n DCHECK_LT(port_index, output_streams_.size()); \n output_streams_[port_index]->Send(data); \n client->AccumulateMidiBytesSent(data.size()); \n }",
  "no_vul": "void MidiManagerUsb::DispatchSendMidiData(MidiManagerClient* client, \n uint32_t port_index, \n const std::vector<uint8>& data, \n double timestamp) { \n if (port_index >= output_streams_.size()) { \n return; \n } \n output_streams_[port_index]->Send(data); \n client->AccumulateMidiBytesSent(data.size()); \n }",
  "cwe": "CWE-119",
  "codeline": "DCHECK_LT(port_index, output_streams_.size());"
}
{
  "idx": 167,
  "target": 1,
  "vul": "void RemoveActionCallback(const ActionCallback& callback) { \n DCHECK(g_task_runner.Get()); \n DCHECK(g_task_runner.Get()->BelongsToCurrentThread()); \n std::vector<ActionCallback>* callbacks = g_callbacks.Pointer(); \n for (size_t i = 0; i < callbacks->size(); ++i) { \n if ((*callbacks)[i].Equals(callback)) { \n callbacks->erase(callbacks->begin() + i); \n return; \n } \n } \n }",
  "no_vul": "void RemoveActionCallback(const ActionCallback& callback) { \n DCHECK(g_task_runner.Get()); \n DCHECK(g_task_runner.Get()->BelongsToCurrentThread()); \n std::vector<ActionCallback>* callbacks = g_callbacks.Pointer(); \n for (size_t i = 0; i < callbacks->size(); ++i) { \n if ((*callbacks)[i] == callback) { \n callbacks->erase(callbacks->begin() + i); \n return; \n } \n } \n }",
  "cwe": "CWE-20",
  "codeline": "if ((*callbacks)[i].Equals(callback)) {"
}
{
  "idx": 168,
  "target": 1,
  "vul": "base::string16 FormatBookmarkURLForDisplay(const GURL& url) { \n return url_formatter::FormatUrl( \n url, url_formatter::kFormatUrlOmitAll & \n ~url_formatter::kFormatUrlOmitUsernamePassword, \n net::UnescapeRule::SPACES, nullptr, nullptr, nullptr); \n }",
  "no_vul": "base::string16 FormatBookmarkURLForDisplay(const GURL& url) { \n url_formatter::FormatUrlTypes format_types = \n url_formatter::kFormatUrlOmitAll & \n ~url_formatter::kFormatUrlOmitUsernamePassword; \n if (url.has_username()) \n format_types &= ~url_formatter::kFormatUrlOmitHTTP; \n return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES, \n nullptr, nullptr, nullptr); \n }",
  "cwe": "CWE-79",
  "codeline": "return url_formatter::FormatUrl( \n url, url_formatter::kFormatUrlOmitAll & \n ~url_formatter::kFormatUrlOmitUsernamePassword, \n net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);"
}
{
  "idx": 169,
  "target": 1,
  "vul": "int32_t PPB_Flash_MessageLoop_Impl::InternalRun( \n const RunFromHostProxyCallback& callback) { \n if (state_->run_called()) { \n if (!callback.is_null()) \n callback.Run(PP_ERROR_FAILED); \n return PP_ERROR_FAILED; \n } \n state_->set_run_called(); \n state_->set_run_callback(callback); \n scoped_refptr<State> state_protector(state_); \n { \n base::MessageLoop::ScopedNestableTaskAllower allow( \n base::MessageLoop::current()); \n base::MessageLoop::current()->Run(); \n } \n return state_protector->result(); \n }",
  "no_vul": "int32_t PPB_Flash_MessageLoop_Impl::InternalRun( \n const RunFromHostProxyCallback& callback) { \n if (state_->run_called()) { \n if (!callback.is_null()) \n callback.Run(PP_ERROR_FAILED); \n return PP_ERROR_FAILED; \n } \n state_->set_run_called(); \n state_->set_run_callback(callback); \n scoped_refptr<State> state_protector(state_); \n { \n base::MessageLoop::ScopedNestableTaskAllower allow( \n base::MessageLoop::current()); \n blink::WebView::willEnterModalLoop(); \n base::MessageLoop::current()->Run(); \n blink::WebView::didExitModalLoop(); \n } \n return state_protector->result(); \n }",
  "cwe": "CWE-264",
  "codeline": "base::MessageLoop::current()->Run();"
}
{
  "idx": 170,
  "target": 1,
  "vul": "bool CustomButton::AcceleratorPressed(const ui::Accelerator& accelerator) { \n SetState(STATE_NORMAL); \n ui::MouseEvent synthetic_event( \n ui::ET_MOUSE_RELEASED, gfx::Point(), gfx::Point(), ui::EventTimeForNow(), \n ui::EF_LEFT_MOUSE_BUTTON, ui::EF_LEFT_MOUSE_BUTTON); \n NotifyClick(synthetic_event); \n return true; \n }",
  "no_vul": "bool CustomButton::AcceleratorPressed(const ui::Accelerator& accelerator) { \n if ((IsChildWidget() && !FocusInChildWidget()) || \n (!IsChildWidget() && !GetWidget()->IsActive())) { \n return false; \n } \n SetState(STATE_NORMAL); \n ui::MouseEvent synthetic_event( \n ui::ET_MOUSE_RELEASED, gfx::Point(), gfx::Point(), ui::EventTimeForNow(), \n ui::EF_LEFT_MOUSE_BUTTON, ui::EF_LEFT_MOUSE_BUTTON); \n NotifyClick(synthetic_event); \n return true; \n }",
  "cwe": "CWE-254",
  "codeline": "SetState(STATE_NORMAL);"
}
{
  "idx": 171,
  "target": 1,
  "vul": "void SetUpFontconfig() { \n std::unique_ptr<Environment> env = Environment::Create(); \n if (!env->HasVar(\"FONTCONFIG_FILE\")) { \n FilePath dir_module; \n PathService::Get(DIR_MODULE, &dir_module); \n FilePath font_cache = dir_module.Append(\"fontconfig_caches\"); \n FilePath test_fonts = dir_module.Append(\"test_fonts\"); \n std::string fonts_conf = ReplaceStringPlaceholders( \n kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr); \n FilePath fonts_conf_file_temp; \n CHECK(CreateTemporaryFileInDir(dir_module, &fonts_conf_file_temp)); \n CHECK( \n WriteFile(fonts_conf_file_temp, fonts_conf.c_str(), fonts_conf.size())); \n FilePath fonts_conf_file = dir_module.Append(\"fonts.conf\"); \n CHECK(ReplaceFile(fonts_conf_file_temp, fonts_conf_file, nullptr)); \n env->SetVar(\"FONTCONFIG_FILE\", fonts_conf_file.value()); \n } \n CHECK(FcInit()); \n }",
  "no_vul": "void SetUpFontconfig() { \n FilePath dir_module; \n PathService::Get(DIR_MODULE, &dir_module); \n FilePath font_cache = dir_module.Append(\"fontconfig_caches\"); \n FilePath test_fonts = dir_module.Append(\"test_fonts\"); \n std::string fonts_conf = ReplaceStringPlaceholders( \n kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr); \n FcConfig* config = FcConfigCreate(); \n CHECK(config); \n #if FC_VERSION >= 21205 \n CHECK(FcConfigParseAndLoadFromMemory( \n config, reinterpret_cast<const FcChar8*>(fonts_conf.c_str()), FcTrue)); \n #else \n FilePath temp; \n CHECK(CreateTemporaryFile(&temp)); \n CHECK(WriteFile(temp, fonts_conf.c_str(), fonts_conf.size())); \n CHECK(FcConfigParseAndLoad( \n config, reinterpret_cast<const FcChar8*>(temp.value().c_str()), FcTrue)); \n CHECK(DeleteFile(temp, false)); \n #endif \n CHECK(FcConfigBuildFonts(config)); \n CHECK(FcConfigSetCurrent(config)); \n FcConfigDestroy(config); \n }",
  "cwe": "CWE-254",
  "codeline": "CHECK(ReplaceFile(fonts_conf_file_temp, fonts_conf_file, nullptr));"
}
{
  "idx": 172,
  "target": 1,
  "vul": "void ImageInputType::ensurePrimaryContent() \n { \n if (!m_useFallbackContent) \n return; \n m_useFallbackContent = false; \n reattachFallbackContent(); \n }",
  "no_vul": "void ImageInputType::ensureFallbackContent() \n { \n if (m_useFallbackContent) \n return; \n setUseFallbackContent(); \n reattachFallbackContent(); \n }",
  "cwe": "CWE-361",
  "codeline": "m_useFallbackContent = false;"
}
{
  "idx": 173,
  "target": 1,
  "vul": "V4L2JpegEncodeAccelerator::JobRecord::JobRecord( \n scoped_refptr<VideoFrame> input_frame, \n scoped_refptr<VideoFrame> output_frame, \n int quality, \n int32_t task_id, \n BitstreamBuffer* exif_buffer) \n : input_frame(input_frame), \n output_frame(output_frame), \n quality(quality), \n task_id(task_id), \n output_shm(base::SharedMemoryHandle(), 0, true), \n exif_shm(nullptr) { \n if (exif_buffer) { \n exif_shm.reset(new UnalignedSharedMemory(exif_buffer->TakeRegion(), \n exif_buffer->size(), false)); \n exif_offset = exif_buffer->offset(); \n } \n }",
  "no_vul": "V4L2JpegEncodeAccelerator::JobRecord::JobRecord( \n scoped_refptr<VideoFrame> input_frame, \n scoped_refptr<VideoFrame> output_frame, \n int quality, \n int32_t task_id, \n BitstreamBuffer* exif_buffer) \n : input_frame(input_frame), \n output_frame(output_frame), \n quality(quality), \n task_id(task_id), \n output_shm(base::subtle::PlatformSharedMemoryRegion(), 0, true), \n exif_shm(nullptr) { \n if (exif_buffer) { \n exif_shm.reset(new UnalignedSharedMemory(exif_buffer->TakeRegion(), \n exif_buffer->size(), false)); \n exif_offset = exif_buffer->offset(); \n } \n }",
  "cwe": "CWE-20",
  "codeline": "output_shm(base::SharedMemoryHandle(), 0, true),"
}
{
  "idx": 174,
  "target": 1,
  "vul": "void FeatureInfo::EnableOESTextureHalfFloatLinear() { \n if (!oes_texture_half_float_linear_available_) \n return; \n AddExtensionString(\"GL_OES_texture_half_float_linear\"); \n feature_flags_.enable_texture_half_float_linear = true; \n feature_flags_.gpu_memory_buffer_formats.Add(gfx::BufferFormat::RGBA_F16); \n }",
  "no_vul": "void FeatureInfo::EnableOESTextureHalfFloatLinear() { \n if (!oes_texture_half_float_linear_available_) \n return; \n AddExtensionString(\"GL_OES_texture_half_float_linear\"); \n feature_flags_.enable_texture_half_float_linear = true; \n if (workarounds_.disable_half_float_for_gmb) \n return; \n feature_flags_.gpu_memory_buffer_formats.Add(gfx::BufferFormat::RGBA_F16); \n }",
  "cwe": "CWE-125",
  "codeline": "feature_flags_.gpu_memory_buffer_formats.Add(gfx::BufferFormat::RGBA_F16);"
}
{
  "idx": 175,
  "target": 1,
  "vul": "bool PasswordAutofillAgent::TryToShowTouchToFill( \n const WebFormControlElement& control_element) { \n const WebInputElement* element = ToWebInputElement(&control_element); \n if (!element || (!base::Contains(web_input_to_password_info_, *element) && \n !base::Contains(password_to_username_, *element))) { \n return false; \n } \n if (was_touch_to_fill_ui_shown_) \n return false; \n was_touch_to_fill_ui_shown_ = true; \n GetPasswordManagerDriver()->ShowTouchToFill(); \n return true; \n }",
  "no_vul": "bool PasswordAutofillAgent::TryToShowTouchToFill( \n const WebFormControlElement& control_element) { \n const WebInputElement* element = ToWebInputElement(&control_element); \n WebInputElement username_element; \n WebInputElement password_element; \n PasswordInfo* password_info = nullptr; \n if (!element || \n !FindPasswordInfoForElement(*element, &username_element, \n &password_element, &password_info)) { \n return false; \n } \n if (was_touch_to_fill_ui_shown_) \n return false; \n was_touch_to_fill_ui_shown_ = true; \n GetPasswordManagerDriver()->ShowTouchToFill(); \n return true; \n }",
  "cwe": "CWE-125",
  "codeline": "if (!element || (!base::Contains(web_input_to_password_info_, *element) && \n !base::Contains(password_to_username_, *element))) {"
}
{
  "idx": 176,
  "target": 1,
  "vul": "bool OmniboxViewViews::ShouldShowPlaceholderText() const { \n return Textfield::ShouldShowPlaceholderText() && \n !model()->is_caret_visible() && !model()->is_keyword_selected(); \n }",
  "no_vul": "bool OmniboxViewViews::ShouldShowPlaceholderText() const { \n bool show_with_caret = base::FeatureList::IsEnabled( \n omnibox::kUIExperimentShowPlaceholderWhenCaretShowing); \n return Textfield::ShouldShowPlaceholderText() && \n (show_with_caret || !model()->is_caret_visible()) && \n !model()->is_keyword_selected(); \n }",
  "cwe": "CWE-200",
  "codeline": "return Textfield::ShouldShowPlaceholderText() && \n !model()->is_caret_visible() && !model()->is_keyword_selected();"
}
{
  "idx": 177,
  "target": 1,
  "vul": "base::string16 GetRelyingPartyIdString( \n AuthenticatorRequestDialogModel* dialog_model) { \n static constexpr char kRpIdUrlPrefix[] = \"https://\"; \n static constexpr int kDialogWidth = 300; \n const auto& rp_id = dialog_model->relying_party_id(); \n DCHECK(!rp_id.empty()); \n GURL rp_id_url(kRpIdUrlPrefix + rp_id); \n auto max_static_string_length = gfx::GetStringWidthF( \n l10n_util::GetStringUTF16(IDS_WEBAUTHN_GENERIC_TITLE), gfx::FontList(), \n gfx::Typesetter::DEFAULT); \n return url_formatter::ElideHost(rp_id_url, gfx::FontList(), \n kDialogWidth - max_static_string_length); \n }",
  "no_vul": "base::string16 GetRelyingPartyIdString( \n AuthenticatorRequestDialogModel* dialog_model) { \n static constexpr char kRpIdUrlPrefix[] = \"https://\"; \n static constexpr int kDialogWidth = 300; \n const auto& rp_id = dialog_model->relying_party_id(); \n DCHECK(!rp_id.empty()); \n GURL rp_id_url(kRpIdUrlPrefix + rp_id); \n return url_formatter::ElideHost(rp_id_url, gfx::FontList(), kDialogWidth); \n }",
  "cwe": "CWE-119",
  "codeline": "auto max_static_string_length = gfx::GetStringWidthF( \n l10n_util::GetStringUTF16(IDS_WEBAUTHN_GENERIC_TITLE), gfx::FontList(), \n gfx::Typesetter::DEFAULT);"
}
{
  "idx": 178,
  "target": 1,
  "vul": "Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto( \n ContainerNode& insertion_point) { \n HTMLElement::InsertedInto(insertion_point); \n LogAddElementIfIsolatedWorldAndInDocument(\"link\", relAttr, hrefAttr); \n if (!insertion_point.isConnected()) \n return kInsertionDone; \n DCHECK(isConnected()); \n if (!ShouldLoadLink() && IsInShadowTree()) { \n String message = \"HTML element <link> is ignored in shadow tree.\"; \n GetDocument().AddConsoleMessage(ConsoleMessage::Create( \n kJSMessageSource, kWarningMessageLevel, message)); \n return kInsertionDone; \n } \n GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this); \n Process(); \n if (link_) \n link_->OwnerInserted(); \n return kInsertionDone; \n }",
  "no_vul": "Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto( \n ContainerNode& insertion_point) { \n HTMLElement::InsertedInto(insertion_point); \n LogAddElementIfIsolatedWorldAndInDocument(\"link\", relAttr, hrefAttr); \n if (!insertion_point.isConnected()) \n return kInsertionDone; \n DCHECK(isConnected()); \n GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this); \n if (!ShouldLoadLink() && IsInShadowTree()) { \n String message = \"HTML element <link> is ignored in shadow tree.\"; \n GetDocument().AddConsoleMessage(ConsoleMessage::Create( \n kJSMessageSource, kWarningMessageLevel, message)); \n return kInsertionDone; \n } \n Process(); \n if (link_) \n link_->OwnerInserted(); \n return kInsertionDone; \n }",
  "cwe": "CWE-416",
  "codeline": "if (!ShouldLoadLink() && IsInShadowTree()) { \n String message = \"HTML element <link> is ignored in shadow tree.\"; \n GetDocument().AddConsoleMessage(ConsoleMessage::Create( \n kJSMessageSource, kWarningMessageLevel, message)); \n return kInsertionDone; \n }"
}
{
  "idx": 179,
  "target": 1,
  "vul": "void RendererSchedulerImpl::OnShutdownTaskQueue( \n const scoped_refptr<MainThreadTaskQueue>& task_queue) { \n if (main_thread_only().was_shutdown) \n return; \n if (task_queue_throttler_) \n task_queue_throttler_->ShutdownTaskQueue(task_queue.get()); \n if (task_runners_.erase(task_queue)) { \n switch (task_queue->queue_class()) { \n case MainThreadTaskQueue::QueueClass::kTimer: \n task_queue->RemoveTaskObserver( \n &main_thread_only().timer_task_cost_estimator); \n case MainThreadTaskQueue::QueueClass::kLoading: \n task_queue->RemoveTaskObserver( \n &main_thread_only().loading_task_cost_estimator); \n default: \n break; \n } \n } \n }",
  "no_vul": "void RendererSchedulerImpl::OnShutdownTaskQueue( \n const scoped_refptr<MainThreadTaskQueue>& task_queue) { \n if (main_thread_only().was_shutdown) \n return; \n if (task_queue_throttler_) \n task_queue_throttler_->ShutdownTaskQueue(task_queue.get()); \n if (task_runners_.erase(task_queue)) { \n switch (task_queue->queue_class()) { \n case MainThreadTaskQueue::QueueClass::kTimer: \n task_queue->RemoveTaskObserver( \n &main_thread_only().timer_task_cost_estimator); \n break; \n case MainThreadTaskQueue::QueueClass::kLoading: \n task_queue->RemoveTaskObserver( \n &main_thread_only().loading_task_cost_estimator); \n break; \n default: \n break; \n } \n } \n }",
  "cwe": "CWE-119",
  "codeline": "case MainThreadTaskQueue::QueueClass::kTimer: \ntask_queue->RemoveTaskObserver( \n&main_thread_only().timer_task_cost_estimator);"
}
{
  "idx": 180,
  "target": 1,
  "vul": "void NavigatorImpl::DiscardPendingEntryIfNeeded(int expected_pending_entry_id) { \n NavigationEntry* pending_entry = controller_->GetPendingEntry(); \n bool pending_matches_fail_msg = \n pending_entry && \n expected_pending_entry_id == pending_entry->GetUniqueID(); \n if (!pending_matches_fail_msg) \n return; \n bool should_preserve_entry = controller_->IsUnmodifiedBlankTab() || \n delegate_->ShouldPreserveAbortedURLs(); \n if (pending_entry != controller_->GetVisibleEntry() || \n !should_preserve_entry) { \n controller_->DiscardPendingEntry(true); \n controller_->delegate()->NotifyNavigationStateChanged(INVALIDATE_TYPE_URL); \n } \n }",
  "no_vul": "void NavigatorImpl::DiscardPendingEntryIfNeeded(int expected_pending_entry_id) { \n NavigationEntry* pending_entry = controller_->GetPendingEntry(); \n bool pending_matches_fail_msg = \n pending_entry && \n expected_pending_entry_id == pending_entry->GetUniqueID(); \n if (!pending_matches_fail_msg) \n return; \n bool should_preserve_entry = pending_entry->GetURL().is_valid() && \n (controller_->IsUnmodifiedBlankTab() || \n delegate_->ShouldPreserveAbortedURLs()); \n if (pending_entry != controller_->GetVisibleEntry() || \n !should_preserve_entry) { \n controller_->DiscardPendingEntry(true); \n controller_->delegate()->NotifyNavigationStateChanged(INVALIDATE_TYPE_URL); \n } \n }",
  "cwe": "CWE-20",
  "codeline": "bool should_preserve_entry = controller_->IsUnmodifiedBlankTab() || \n delegate_->ShouldPreserveAbortedURLs();"
}
{
  "idx": 181,
  "target": 1,
  "vul": "void RemoteFrame::ScheduleNavigation(Document& origin_document, \n const KURL& url, \n WebFrameLoadType frame_load_type, \n UserGestureStatus user_gesture_status) { \n FrameLoadRequest frame_request(&origin_document, ResourceRequest(url)); \n frame_request.GetResourceRequest().SetHasUserGesture( \n user_gesture_status == UserGestureStatus::kActive); \n frame_request.GetResourceRequest().SetFrameType( \n IsMainFrame() ? network::mojom::RequestContextFrameType::kTopLevel \n : network::mojom::RequestContextFrameType::kNested); \n Navigate(frame_request, frame_load_type); \n }",
  "no_vul": "void RemoteFrame::ScheduleNavigation(Document& origin_document, \n const KURL& url, \n WebFrameLoadType frame_load_type, \n UserGestureStatus user_gesture_status) { \n if (!origin_document.GetSecurityOrigin()->CanDisplay(url)) { \n origin_document.AddConsoleMessage(ConsoleMessage::Create( \n kSecurityMessageSource, kErrorMessageLevel, \n \"Not allowed to load local resource: \" + url.ElidedString())); \n return; \n } \n FrameLoadRequest frame_request(&origin_document, ResourceRequest(url)); \n frame_request.GetResourceRequest().SetHasUserGesture( \n user_gesture_status == UserGestureStatus::kActive); \n frame_request.GetResourceRequest().SetFrameType( \n IsMainFrame() ? network::mojom::RequestContextFrameType::kTopLevel \n : network::mojom::RequestContextFrameType::kNested); \n Navigate(frame_request, frame_load_type); \n }",
  "cwe": "CWE-732",
  "codeline": "FrameLoadRequest frame_request(&origin_document, ResourceRequest(url));"
}
{
  "idx": 182,
  "target": 1,
  "vul": "void Browser::SetWebContentsBlocked(content::WebContents* web_contents, \n bool blocked) { \n int index = tab_strip_model_->GetIndexOfWebContents(web_contents); \n if (index == TabStripModel::kNoTab) { \n return; \n } \n tab_strip_model_->SetTabBlocked(index, blocked); \n bool browser_active = BrowserList::GetInstance()->GetLastActive() == this; \n bool contents_is_active = \n tab_strip_model_->GetActiveWebContents() == web_contents; \n if (!blocked && contents_is_active && browser_active) \n web_contents->Focus(); \n }",
  "no_vul": "void Browser::SetWebContentsBlocked(content::WebContents* web_contents, \n bool blocked) { \n int index = tab_strip_model_->GetIndexOfWebContents(web_contents); \n if (index == TabStripModel::kNoTab) { \n return; \n } \n if (web_contents->IsFullscreenForCurrentTab()) \n web_contents->ExitFullscreen(true); \n tab_strip_model_->SetTabBlocked(index, blocked); \n bool browser_active = BrowserList::GetInstance()->GetLastActive() == this; \n bool contents_is_active = \n tab_strip_model_->GetActiveWebContents() == web_contents; \n if (!blocked && contents_is_active && browser_active) \n web_contents->Focus(); \n }",
  "cwe": "CWE-20",
  "codeline": "if (!blocked && contents_is_active && browser_active) \n web_contents->Focus();"
}
{
  "idx": 183,
  "target": 1,
  "vul": "bool DownloadItemImpl::CanOpenDownload() { \n const bool is_complete = GetState() == DownloadItem::COMPLETE; \n return (!IsDone() || is_complete) && !IsTemporary() && \n !file_externally_removed_; \n }",
  "no_vul": "bool DownloadItemImpl::CanOpenDownload() { \n const bool is_complete = GetState() == DownloadItem::COMPLETE; \n return (!IsDone() || is_complete) && !IsTemporary() && \n !file_externally_removed_ && \n delegate_->IsMostRecentDownloadItemAtFilePath(this); \n }",
  "cwe": "CWE-20",
  "codeline": "return (!IsDone() || is_complete) && !IsTemporary() && \n !file_externally_removed_;"
}
{
  "idx": 184,
  "target": 1,
  "vul": "void MemBackendImpl::EvictIfNeeded() { \n if (current_size_ <= max_size_) \n return; \n int target_size = std::max(0, max_size_ - kDefaultEvictionSize); \n base::LinkNode<MemEntryImpl>* entry = lru_list_.head(); \n while (current_size_ > target_size && entry != lru_list_.end()) { \n MemEntryImpl* to_doom = entry->value(); \n entry = entry->next(); \n if (!to_doom->InUse()) \n to_doom->Doom(); \n } \n }",
  "no_vul": "void MemBackendImpl::EvictIfNeeded() { \n if (current_size_ <= max_size_) \n return; \n int target_size = std::max(0, max_size_ - kDefaultEvictionSize); \n base::LinkNode<MemEntryImpl>* entry = lru_list_.head(); \n while (current_size_ > target_size && entry != lru_list_.end()) { \n MemEntryImpl* to_doom = entry->value(); \n do { \n entry = entry->next(); \n } while (entry != lru_list_.end() && entry->value()->parent() == to_doom); \n if (!to_doom->InUse()) \n to_doom->Doom(); \n } \n }",
  "cwe": "CWE-416",
  "codeline": "entry = entry->next();"
}
{
  "idx": 185,
  "target": 1,
  "vul": "int PDFiumEngine::GetVisiblePageIndex(FPDF_PAGE page) { \n for (int page_index : visible_pages_) { \n if (pages_[page_index]->GetPage() == page) \n return page_index; \n } \n return -1; \n }",
  "no_vul": "int PDFiumEngine::GetVisiblePageIndex(FPDF_PAGE page) { \n std::vector<int> visible_pages_copy(visible_pages_); \n for (int page_index : visible_pages_copy) { \n if (pages_[page_index]->GetPage() == page) \n return page_index; \n } \n return -1; \n }",
  "cwe": "CWE-20",
  "codeline": "for (int page_index : visible_pages_) {"
}
{
  "idx": 186,
  "target": 1,
  "vul": "bool NavigateToUrlWithEdge(const base::string16& url) { \n base::string16 protocol_url = L\"microsoft-edge:\" + url; \n SHELLEXECUTEINFO info = { sizeof(info) }; \n info.fMask = SEE_MASK_NOASYNC | SEE_MASK_FLAG_NO_UI; \n info.lpVerb = L\"open\"; \n info.lpFile = protocol_url.c_str(); \n info.nShow = SW_SHOWNORMAL; \n if (::ShellExecuteEx(&info)) \n return true; \n PLOG(ERROR) << \"Failed to launch Edge for uninstall survey\"; \n return false; \n }",
  "no_vul": "bool NavigateToUrlWithEdge(const base::string16& url) { \n base::string16 protocol_url = L\"microsoft-edge:\" + url; \n SHELLEXECUTEINFO info = { sizeof(info) }; \n info.fMask = SEE_MASK_NOASYNC; \n info.lpVerb = L\"open\"; \n info.lpFile = protocol_url.c_str(); \n info.nShow = SW_SHOWNORMAL; \n if (::ShellExecuteEx(&info)) \n return true; \n PLOG(ERROR) << \"Failed to launch Edge for uninstall survey\"; \n return false; \n }",
  "cwe": "CWE-20",
  "codeline": "info.fMask = SEE_MASK_NOASYNC | SEE_MASK_FLAG_NO_UI;"
}
{
  "idx": 187,
  "target": 1,
  "vul": "void AudioNode::Dispose() { \n DCHECK(IsMainThread()); \n #if DEBUG_AUDIONODE_REFERENCES \n fprintf(stderr, \"[%16p]: %16p: %2d: AudioNode::dispose %16p\\n\", context(), \n this, Handler().GetNodeType(), handler_.get()); \n #endif \n BaseAudioContext::GraphAutoLocker locker(context()); \n Handler().Dispose(); \n if (context()->HasRealtimeConstraint()) { \n context()->GetDeferredTaskHandler().AddRenderingOrphanHandler( \n std::move(handler_)); \n } else { \n if (context()->ContextState() == BaseAudioContext::kRunning) { \n context()->GetDeferredTaskHandler().AddRenderingOrphanHandler( \n std::move(handler_)); \n } \n } \n }",
  "no_vul": "void AudioNode::Dispose() { \n DCHECK(IsMainThread()); \n #if DEBUG_AUDIONODE_REFERENCES \n fprintf(stderr, \"[%16p]: %16p: %2d: AudioNode::dispose %16p\\n\", context(), \n this, Handler().GetNodeType(), handler_.get()); \n #endif \n BaseAudioContext::GraphAutoLocker locker(context()); \n Handler().Dispose(); \n if (context()->ContextState() == BaseAudioContext::kRunning) { \n context()->GetDeferredTaskHandler().AddRenderingOrphanHandler( \n std::move(handler_)); \n } \n }",
  "cwe": "CWE-416",
  "codeline": "if (context()->HasRealtimeConstraint()) { \n context()->GetDeferredTaskHandler().AddRenderingOrphanHandler( \n std::move(handler_)); \n } else { \n if (context()->ContextState() == BaseAudioContext::kRunning) { \n context()->GetDeferredTaskHandler().AddRenderingOrphanHandler( \n std::move(handler_)); \n } \n }"
}
{
  "idx": 188,
  "target": 1,
  "vul": "bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) { \n vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode, \n VAProfileJPEGBaseline, error_uma_cb); \n if (!vaapi_wrapper_) { \n VLOGF(1) << \"Failed initializing VAAPI\"; \n return false; \n } \n return true; \n }",
  "no_vul": "bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {",
  "cwe": "CWE-79",
  "codeline": "vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode, \n VAProfileJPEGBaseline, error_uma_cb);"
}
{
  "idx": 189,
  "target": 1,
  "vul": "WebContents* DevToolsWindow::OpenURLFromTab( \n WebContents* source, \n const content::OpenURLParams& params) { \n DCHECK(source == main_web_contents_); \n if (!params.url.SchemeIs(content::kChromeDevToolsScheme)) { \n WebContents* inspected_web_contents = GetInspectedWebContents(); \n return inspected_web_contents ? \n inspected_web_contents->OpenURL(params) : NULL; \n } \n bindings_->Reload(); \n return main_web_contents_; \n }",
  "no_vul": "WebContents* DevToolsWindow::OpenURLFromTab( \n WebContents* source, \n const content::OpenURLParams& params) { \n DCHECK(source == main_web_contents_); \n if (!params.url.SchemeIs(content::kChromeDevToolsScheme)) { \n WebContents* inspected_web_contents = GetInspectedWebContents(); \n if (!inspected_web_contents) \n return nullptr; \n content::OpenURLParams modified = params; \n modified.referrer = content::Referrer(); \n return inspected_web_contents->OpenURL(modified); \n } \n bindings_->Reload(); \n return main_web_contents_; \n }",
  "cwe": "CWE-668",
  "codeline": "return inspected_web_contents ? inspected_web_contents->OpenURL(params) : NULL;"
}
{
  "idx": 190,
  "target": 1,
  "vul": "void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked( \n mojom::PaymentHandlerResponsePtr response) { \n DCHECK(delegate_); \n if (delegate_ != nullptr) { \n delegate_->OnInstrumentDetailsReady(response->method_name, \n response->stringified_details); \n delegate_ = nullptr; \n } \n }",
  "no_vul": "void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked( \n mojom::PaymentHandlerResponsePtr response) { \n if (delegate_ != nullptr) { \n delegate_->OnInstrumentDetailsReady(response->method_name, \n response->stringified_details); \n delegate_ = nullptr; \n } \n }",
  "cwe": "CWE-416",
  "codeline": "DCHECK(delegate_);"
}
{
  "idx": 191,
  "target": 1,
  "vul": "OperationID FileSystemOperationRunner::BeginOperation( \n std::unique_ptr<FileSystemOperation> operation) { \n OperationID id = next_operation_id_++; \n operations_.emplace(id, std::move(operation)); \n return id; \n }",
  "no_vul": "OperationID FileSystemOperationRunner::BeginOperation( \n std::unique_ptr<FileSystemOperation> operation) { \n OperationID id = next_operation_id_++; \n operations_[id] = std::move(operation); \n return id; \n }",
  "cwe": "CWE-190",
  "codeline": "operations_.emplace(id, std::move(operation));"
}
{
  "idx": 192,
  "target": 1,
  "vul": "std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line, \n const std::wstring& switch_name) { \n assert(!command_line.empty()); \n assert(!switch_name.empty()); \n std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line); \n std::wstring switch_with_equal = L\"--\" + switch_name + L\"=\"; \n for (size_t i = 1; i < as_array.size(); ++i) { \n const std::wstring& arg = as_array[i]; \n if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0) \n return arg.substr(switch_with_equal.size()); \n } \n return std::wstring(); \n }",
  "no_vul": "std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line, \n const std::wstring& switch_name) { \n static constexpr wchar_t kSwitchTerminator[] = L\"--\"; \n assert(!command_line.empty()); \n assert(!switch_name.empty()); \n std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line); \n std::wstring switch_with_equal = L\"--\" + switch_name + L\"=\"; \n auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator); \n for (auto scan = as_array.cbegin(); scan != end; ++scan) { \n const std::wstring& arg = *scan; \n if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0) \n return arg.substr(switch_with_equal.size()); \n } \n return std::wstring(); \n }",
  "cwe": "CWE-77",
  "codeline": "for (size_t i = 1; i < as_array.size(); ++i) {"
}
{
  "idx": 193,
  "target": 1,
  "vul": "DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() { \n DCHECK_EQ(read_type_, kReadAsArrayBuffer); \n if (array_buffer_result_) \n return array_buffer_result_; \n if (!raw_data_ || error_code_ != FileErrorCode::kOK) \n return nullptr; \n DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer()); \n if (finished_loading_) { \n array_buffer_result_ = result; \n AdjustReportedMemoryUsageToV8( \n -1 * static_cast<int64_t>(raw_data_->ByteLength())); \n raw_data_.reset(); \n } \n return result; \n }",
  "no_vul": "DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() { \n DCHECK_EQ(read_type_, kReadAsArrayBuffer); \n if (array_buffer_result_) \n return array_buffer_result_; \n if (!raw_data_ || error_code_ != FileErrorCode::kOK) \n return nullptr; \n if (!finished_loading_) { \n return DOMArrayBuffer::Create( \n ArrayBuffer::Create(raw_data_->Data(), raw_data_->ByteLength())); \n } \n array_buffer_result_ = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer()); \n AdjustReportedMemoryUsageToV8(-1 * \n static_cast<int64_t>(raw_data_->ByteLength())); \n raw_data_.reset(); \n return array_buffer_result_; \n }",
  "cwe": "CWE-416",
  "codeline": "if (finished_loading_) { \n array_buffer_result_ = result; \n AdjustReportedMemoryUsageToV8( \n -1 * static_cast<int64_t>(raw_data_->ByteLength())); \n raw_data_.reset(); \n }"
}
{
  "idx": 194,
  "target": 1,
  "vul": "bool SVGElement::HasSVGParent() const { \n return ParentOrShadowHostElement() && \n ParentOrShadowHostElement()->IsSVGElement(); \n }",
  "no_vul": "bool SVGElement::HasSVGParent() const { \n Element* parent = FlatTreeTraversal::ParentElement(*this); \n return parent && parent->IsSVGElement(); \n }",
  "cwe": "CWE-704",
  "codeline": "return ParentOrShadowHostElement() && ParentOrShadowHostElement()->IsSVGElement();"
}
{
  "idx": 195,
  "target": 1,
  "vul": "void FileSystemManagerImpl::CreateWriter(const GURL& file_path, \n CreateWriterCallback callback) { \n DCHECK_CURRENTLY_ON(BrowserThread::IO); \n FileSystemURL url(context_->CrackURL(file_path)); \n base::Optional<base::File::Error> opt_error = ValidateFileSystemURL(url); \n if (opt_error) { \n std::move(callback).Run(opt_error.value(), nullptr); \n return; \n } \n if (!security_policy_->CanWriteFileSystemFile(process_id_, url)) { \n std::move(callback).Run(base::File::FILE_ERROR_SECURITY, nullptr); \n return; \n } \n blink::mojom::FileWriterPtr writer; \n mojo::MakeStrongBinding(std::make_unique<storage::FileWriterImpl>( \n url, context_->CreateFileSystemOperationRunner(), \n blob_storage_context_->context()->AsWeakPtr()), \n MakeRequest(&writer)); \n std::move(callback).Run(base::File::FILE_OK, std::move(writer)); \n }",
  "no_vul": "void FileSystemManagerImpl::CreateWriter(const GURL& file_path, \n CreateWriterCallback callback) { \n DCHECK_CURRENTLY_ON(BrowserThread::IO); \n if (!base::FeatureList::IsEnabled(blink::features::kWritableFilesAPI)) { \n bindings_.ReportBadMessage(\"FileSystemManager.CreateWriter\"); \n return; \n } \n FileSystemURL url(context_->CrackURL(file_path)); \n base::Optional<base::File::Error> opt_error = ValidateFileSystemURL(url); \n if (opt_error) { \n std::move(callback).Run(opt_error.value(), nullptr); \n return; \n } \n if (!security_policy_->CanWriteFileSystemFile(process_id_, url)) { \n std::move(callback).Run(base::File::FILE_ERROR_SECURITY, nullptr); \n return; \n } \n blink::mojom::FileWriterPtr writer; \n mojo::MakeStrongBinding(std::make_unique<storage::FileWriterImpl>( \n url, context_->CreateFileSystemOperationRunner(), \n blob_storage_context_->context()->AsWeakPtr()), \n MakeRequest(&writer)); \n std::move(callback).Run(base::File::FILE_OK, std::move(writer)); \n }",
  "cwe": "CWE-189",
  "codeline": "FileSystemManagerImpl::CreateWriter(const GURL& file_path, \n CreateWriterCallback callback) { \n DCHECK_CURRENTLY_ON(BrowserThread::IO); \n FileSystemURL url(context_->CrackURL(file_path)); \n base::Optional<base::File::Error> opt_error = ValidateFileSystemURL(url); \n if (opt_error) { \n std::move(callback).Run(opt_error.value(), nullptr); \n return; \n } \n if (!security_policy_->CanWriteFileSystemFile(process_id_, url)) { \n std::move(callback).Run(base::File::FILE_ERROR_SECURITY, nullptr); \n return; \n } \n blink::mojom::FileWriterPtr writer; \n mojo::MakeStrongBinding(std::make_unique<storage::FileWriterImpl>( \n url, context_->CreateFileSystemOperationRunner(), \n blob_storage_context_->context()->AsWeakPtr()), \n MakeRequest(&writer)); \n std::move(callback).Run(base::File::FILE_OK, std::move(writer)); \n }"
}
{
  "idx": 196,
  "target": 1,
  "vul": "ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() { \n DCHECK_CURRENTLY_ON(work_thread_id()); \n auto params = bluetooth_socket::Send::Params::Create(*args_); \n EXTENSION_FUNCTION_VALIDATE(params.get()); \n io_buffer_size_ = params->data.size(); \n io_buffer_ = new net::WrappedIOBuffer(params->data.data()); \n BluetoothApiSocket* socket = GetSocket(params->socket_id); \n if (!socket) \n return RespondNow(Error(kSocketNotFoundError)); \n socket->Send(io_buffer_, \n io_buffer_size_, \n base::Bind(&BluetoothSocketSendFunction::OnSuccess, this), \n base::Bind(&BluetoothSocketSendFunction::OnError, this)); \n return did_respond() ? AlreadyResponded() : RespondLater(); \n }",
  "no_vul": "ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() { \n DCHECK_CURRENTLY_ON(work_thread_id()); \n params_ = bluetooth_socket::Send::Params::Create(*args_); \n EXTENSION_FUNCTION_VALIDATE(params_.get()); \n io_buffer_size_ = params_->data.size(); \n io_buffer_ = new net::WrappedIOBuffer(params_->data.data()); \n BluetoothApiSocket* socket = GetSocket(params_->socket_id); \n if (!socket) \n return RespondNow(Error(kSocketNotFoundError)); \n socket->Send(io_buffer_, \n io_buffer_size_, \n base::Bind(&BluetoothSocketSendFunction::OnSuccess, this), \n base::Bind(&BluetoothSocketSendFunction::OnError, this)); \n return did_respond() ? AlreadyResponded() : RespondLater(); \n }",
  "cwe": "CWE-416",
  "codeline": "auto params = bluetooth_socket::Send::Params::Create(*args_);"
}
{
  "idx": 197,
  "target": 1,
  "vul": "void BaseAudioContext::Initialize() { \n if (IsDestinationInitialized()) \n return; \n FFTFrame::Initialize(); \n audio_worklet_ = AudioWorklet::Create(this); \n if (destination_node_) { \n destination_node_->Handler().Initialize(); \n listener_ = AudioListener::Create(*this); \n } \n }",
  "no_vul": "void BaseAudioContext::Initialize() { \n if (IsDestinationInitialized()) \n return; \n FFTFrame::Initialize(); \n audio_worklet_ = AudioWorklet::Create(this); \n if (destination_node_) { \n destination_node_->Handler().Initialize(); \n destination_handler_ = &destination_node_->GetAudioDestinationHandler(); \n listener_ = AudioListener::Create(*this); \n } \n }",
  "cwe": "CWE-416",
  "codeline": "destination_node_->Handler().Initialize();"
}
{
  "idx": 198,
  "target": 1,
  "vul": "bool RendererPermissionsPolicyDelegate::IsRestrictedUrl( \n const GURL& document_url, \n std::string* error) { \n if (dispatcher_->IsExtensionActive(kWebStoreAppId)) { \n if (error) \n *error = errors::kCannotScriptGallery; \n return true; \n } \n if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) { \n if (error) \n *error = errors::kCannotScriptNtp; \n return true; \n } \n return false; \n }",
  "no_vul": "bool RendererPermissionsPolicyDelegate::IsRestrictedUrl( \n const GURL& document_url, \n std::string* error) { \n if (dispatcher_->IsExtensionActive(kWebStoreAppId)) { \n if (error) \n *error = errors::kCannotScriptGallery; \n return true; \n } \n if (base::CommandLine::ForCurrentProcess()->HasSwitch( \n ::switches::kInstantProcess)) { \n if (error) \n *error = errors::kCannotScriptNtp; \n return true; \n } \n return false; \n }",
  "cwe": "CWE-285",
  "codeline": "if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {"
}
{
  "idx": 199,
  "target": 1,
  "vul": "PerformanceNavigationTiming::PerformanceNavigationTiming( \n LocalFrame* frame, \n ResourceTimingInfo* info, \n TimeTicks time_origin, \n const WebVector<WebServerTimingInfo>& server_timing) \n : PerformanceResourceTiming(info ? info->InitialURL().GetString() : \"\", \n \"navigation\", \n time_origin, \n server_timing), \n ContextClient(frame), \n resource_timing_info_(info) { \n DCHECK(frame); \n DCHECK(info); \n }",
  "no_vul": "PerformanceNavigationTiming::PerformanceNavigationTiming( \n LocalFrame* frame, \n ResourceTimingInfo* info, \n TimeTicks time_origin, \n const WebVector<WebServerTimingInfo>& server_timing) \n : PerformanceResourceTiming( \n info ? info->FinalResponse().Url().GetString() : \"\", \n \"navigation\", \n time_origin, \n server_timing), \n ContextClient(frame), \n resource_timing_info_(info) { \n DCHECK(frame); \n DCHECK(info); \n }",
  "cwe": "CWE-200",
  "codeline": "info ? info->InitialURL().GetString() : \"\""
}
{
  "idx": 200,
  "target": 1,
  "vul": "scoped_refptr<Image> CSSPaintValue::GetImage( \n const ImageResourceObserver& client, \n const Document& document, \n const ComputedStyle&, \n const FloatSize& target_size) { \n if (!generator_) { \n generator_ = CSSPaintImageGenerator::Create( \n GetName(), document, paint_image_generator_observer_); \n } \n if (!ParseInputArguments(document)) \n return nullptr; \n return generator_->Paint(client, RoundedIntSize(target_size), \n parsed_input_arguments_); \n }",
  "no_vul": "scoped_refptr<Image> CSSPaintValue::GetImage( \n const ImageResourceObserver& client, \n const Document& document, \n const ComputedStyle& style, \n const FloatSize& target_size) { \n if (style.InsideLink() != EInsideLink::kNotInsideLink) \n return nullptr; \n if (!generator_) { \n generator_ = CSSPaintImageGenerator::Create( \n GetName(), document, paint_image_generator_observer_); \n } \n if (!ParseInputArguments(document)) \n return nullptr; \n return generator_->Paint(client, RoundedIntSize(target_size), \n parsed_input_arguments_); \n }",
  "cwe": "CWE-200",
  "codeline": "if (!generator_) { \n generator_ = CSSPaintImageGenerator::Create( \n GetName(), document, paint_image_generator_observer_); \n }"
}
{
  "idx": 201,
  "target": 1,
  "vul": "void CredentialManagerImpl::OnProvisionalSaveComplete() { \n DCHECK(form_manager_); \n DCHECK(client_->IsSavingAndFillingEnabledForCurrentPage()); \n const autofill::PasswordForm& form = form_manager_->pending_credentials(); \n if (form_manager_->IsPendingCredentialsPublicSuffixMatch()) { \n form_manager_->Save(); \n return; \n } \n if (!form.federation_origin.unique()) { \n for (auto* match : form_manager_->form_fetcher()->GetFederatedMatches()) { \n if (match->username_value == form.username_value && \n match->federation_origin.IsSameOriginWith(form.federation_origin)) { \n form_manager_->Update(*match); \n return; \n } \n } \n } else if (!form_manager_->IsNewLogin()) { \n form_manager_->Update(*form_manager_->preferred_match()); \n return; \n } \n client_->PromptUserToSaveOrUpdatePassword(std::move(form_manager_), false); \n }",
  "no_vul": "void CredentialManagerImpl::OnProvisionalSaveComplete() { \n DCHECK(form_manager_); \n DCHECK(client_->IsSavingAndFillingEnabledForCurrentPage()); \n const autofill::PasswordForm& form = form_manager_->pending_credentials(); \n if (form_manager_->IsPendingCredentialsPublicSuffixMatch()) { \n form_manager_->Save(); \n return; \n } \n if (!form.federation_origin.unique()) { \n for (auto* match : form_manager_->form_fetcher()->GetFederatedMatches()) { \n if (match->username_value == form.username_value && \n match->federation_origin.IsSameOriginWith(form.federation_origin)) { \n form_manager_->Update(*match); \n return; \n } \n } \n } else if (!form_manager_->IsNewLogin()) { \n auto best_match = form_manager_->best_matches().find(form.username_value); \n DCHECK(best_match != form_manager_->best_matches().end()); \n form_manager_->Update(*best_match->second); \n return; \n } \n client_->PromptUserToSaveOrUpdatePassword(std::move(form_manager_), false); \n }",
  "cwe": "CWE-125",
  "codeline": "form_manager_->Update(*form_manager_->preferred_match());"
}
{
  "idx": 202,
  "target": 1,
  "vul": "void InputConnectionImpl::CommitText(const base::string16& text, \n int new_cursor_pos) { \n StartStateUpdateTimer(); \n std::string error; \n if (!ime_engine_->ClearComposition(input_context_id_, &error)) \n LOG(ERROR) << \"ClearComposition failed: error=\\\"\" << error << \"\\\"\"; \n if (IsControlChar(text)) { \n SendControlKeyEvent(text); \n return; \n } \n if (!ime_engine_->CommitText(input_context_id_, \n base::UTF16ToUTF8(text).c_str(), &error)) \n LOG(ERROR) << \"CommitText failed: error=\\\"\" << error << \"\\\"\"; \n }",
  "no_vul": "void InputConnectionImpl::CommitText(const base::string16& text, \n int new_cursor_pos) { \n StartStateUpdateTimer(); \n std::string error; \n if (!ime_engine_->ClearComposition(input_context_id_, &error)) \n LOG(ERROR) << \"ClearComposition failed: error=\\\"\" << error << \"\\\"\"; \n if (IsControlChar(text)) { \n SendControlKeyEvent(text); \n return; \n } \n if (!ime_engine_->CommitText(input_context_id_, \n base::UTF16ToUTF8(text).c_str(), &error)) \n LOG(ERROR) << \"CommitText failed: error=\\\"\" << error << \"\\\"\"; \n composing_text_.clear(); \n }",
  "cwe": "CWE-119",
  "codeline": "composing_text_.clear();"
}
{
  "idx": 203,
  "target": 1,
  "vul": "static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid) \n { \n const char *perm = \"add\"; \n if (uid >= AID_APP) { \n return 0; \n } \n return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0; \n }",
  "no_vul": "static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid) \n { \n const char *perm = \"add\"; \n if (multiuser_get_app_id(uid) >= AID_APP) { \n return 0; \n } \n return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0; \n }",
  "cwe": "CWE-264",
  "codeline": "if (uid >= AID_APP) {"
}
{
  "idx": 204,
  "target": 1,
  "vul": "static byte parseHexByte(const char * &str) { \n byte b = parseHexChar(str[0]); \n if (str[1] == ':' || str[1] == '\\0') { \n str += 2; \n return b; \n } else { \n b = b << 4 | parseHexChar(str[1]); \n str += 3; \n return b; \n } \n }",
  "no_vul": "static byte parseHexByte(const char * &str) { \n if (str[0] == '\\0') { \n ALOGE(\"Passed an empty string\"); \n return 0; \n } \n byte b = parseHexChar(str[0]); \n if (str[1] == '\\0' || str[1] == ':') { \n str ++; \n } else { \n b = b << 4 | parseHexChar(str[1]); \n str += 2; \n } \n if (str[0] != '\\0') { \n str++; \n } \n return b; \n }",
  "cwe": "CWE-200",
  "codeline": "if (str[1] == ':' || str[1] == '\\0') {"
}
{
  "idx": 205,
  "target": 1,
  "vul": "INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits) \n { \n stream_t *ps_stream = (stream_t *)pv_ctxt; \n if (ps_stream->u4_offset < ps_stream->u4_max_offset) \n { \n FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned) \n } \n return; \n }",
  "no_vul": "INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits) \n { \n stream_t *ps_stream = (stream_t *)pv_ctxt; \n if ((ps_stream->u4_offset + 64) < ps_stream->u4_max_offset) \n { \n FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned) \n } \n else \n { \n UWORD32 u4_temp; \n if (((ps_stream->u4_offset & 0x1f) + u4_no_of_bits) >= 32) \n { \n ps_stream->u4_buf = ps_stream->u4_buf_nxt; \n ps_stream->u4_buf_nxt = 0; \n } \n ps_stream->u4_offset += u4_no_of_bits; \n } \n return; \n }",
  "cwe": "CWE-200",
  "codeline": "if (ps_stream->u4_offset < ps_stream->u4_max_offset)"
}
{
  "idx": 206,
  "target": 1,
  "vul": "status_t CameraClient::dump(int fd, const Vector<String16>& args) { \n const size_t SIZE = 256; \n char buffer[SIZE]; \n size_t len = snprintf(buffer, SIZE, \"Client[%d] (%p) PID: %d\\n\", \n mCameraId, \n getRemoteCallback()->asBinder().get(), \n mClientPid); \n len = (len > SIZE - 1) ? SIZE - 1 : len; \n write(fd, buffer, len); \n return mHardware->dump(fd, args); \n }",
  "no_vul": "status_t CameraClient::dump(int fd, const Vector<String16>& args) { \n return BasicClient::dump(fd, args); \n } \n status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) { \n const size_t SIZE = 256; \n char buffer[SIZE]; \n size_t len = snprintf(buffer, SIZE, \"Client[%d] (%p) PID: %d\\n\", \n mCameraId, \n getRemoteCallback()->asBinder().get(), \n mClientPid); \n len = (len > SIZE - 1) ? SIZE - 1 : len; \n write(fd, buffer, len); \n return mHardware->dump(fd, args); \n }",
  "cwe": "CWE-264",
  "codeline": "len = (len > SIZE - 1) ? SIZE - 1 : len;"
}
{
  "idx": 207,
  "target": 1,
  "vul": "status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) { \n String8 result; \n result.appendFormat(\"CameraDeviceClient[%d] (%p) PID: %d, dump:\\n\", \n mCameraId, \n getRemoteCallback()->asBinder().get(), \n mClientPid); \n result.append(\" State: \"); \n mFrameProcessor->dump(fd, args); \n return dumpDevice(fd, args); \n }",
  "no_vul": "status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) { \n return BasicClient::dump(fd, args); \n } \n status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) { \n String8 result; \n result.appendFormat(\"CameraDeviceClient[%d] (%p) PID: %d, dump:\\n\", \n mCameraId, \n getRemoteCallback()->asBinder().get(), \n mClientPid); \n result.append(\" State: \"); \n mFrameProcessor->dump(fd, args); \n return dumpDevice(fd, args); \n }",
  "cwe": "CWE-264",
  "codeline": "mFrameProcessor->dump(fd, args);"
}
{
  "idx": 208,
  "target": 1,
  "vul": "status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) { \n String8 result; \n result.appendFormat(\"ProCamera2Client[%d] (%p) PID: %d, dump:\\n\", \n mCameraId, \n getRemoteCallback()->asBinder().get(), \n mClientPid); \n result.append(\" State: \"); \n mFrameProcessor->dump(fd, args); \n return dumpDevice(fd, args); \n }",
  "no_vul": "status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) { \n return BasicClient::dump(fd, args); \n } \n status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) { \n String8 result; \n result.appendFormat(\"ProCamera2Client[%d] (%p) PID: %d, dump:\\n\", \n mCameraId, \n getRemoteCallback()->asBinder().get(), \n mClientPid); \n result.append(\" State: \"); \n mFrameProcessor->dump(fd, args); \n return dumpDevice(fd, args); \n }",
  "cwe": "CWE-264",
  "codeline": "mFrameProcessor->dump(fd, args);"
}
{
  "idx": 209,
  "target": 1,
  "vul": "void NuPlayer::GenericSource::notifyPreparedAndCleanup(status_t err) { \n if (err != OK) { \n mMetaDataSize = -1ll; \n mContentType = \"\"; \n mSniffedMIME = \"\"; \n { \n sp<DataSource> dataSource = mDataSource; \n sp<NuCachedSource2> cachedSource = mCachedSource; \n sp<DataSource> httpSource = mHttpSource; \n { \n Mutex::Autolock _l(mDisconnectLock); \n mDataSource.clear(); \n mCachedSource.clear(); \n mHttpSource.clear(); \n } \n } \n cancelPollBuffering(); \n } \n notifyPrepared(err); \n }",
  "no_vul": "void NuPlayer::GenericSource::notifyPreparedAndCleanup(status_t err) { \n if (err != OK) { \n mMetaDataSize = -1ll; \n mContentType = \"\"; \n mSniffedMIME = \"\"; \n { \n sp<DataSource> dataSource = mDataSource; \n sp<NuCachedSource2> cachedSource = mCachedSource; \n sp<DataSource> httpSource = mHttpSource; \n { \n Mutex::Autolock _l(mDisconnectLock); \n mDataSource.clear(); \n mDrmManagerClient = NULL; \n mCachedSource.clear(); \n mHttpSource.clear(); \n } \n } \n cancelPollBuffering(); \n } \n notifyPrepared(err); \n }",
  "cwe": "CWE-119",
  "codeline": "mDrmManagerClient = NULL;"
}
{
  "idx": 210,
  "target": 1,
  "vul": "static EAS_RESULT PushcdlStack (EAS_U32 *pStack, EAS_INT *pStackPtr, EAS_U32 value) \n { \n if (*pStackPtr >= CDL_STACK_SIZE) \n return EAS_ERROR_FILE_FORMAT; \n *pStackPtr = *pStackPtr + 1; \n pStack[*pStackPtr] = value; \n return EAS_SUCCESS; \n }",
  "no_vul": "static EAS_RESULT PushcdlStack (EAS_U32 *pStack, EAS_INT *pStackPtr, EAS_U32 value) \n { \n if (*pStackPtr >= (CDL_STACK_SIZE - 1)) { \n ALOGE(\"b/34031018, stackPtr(%d)\", *pStackPtr); \n android_errorWriteLog(0x534e4554, \"34031018\"); \n return EAS_ERROR_FILE_FORMAT; \n } \n *pStackPtr = *pStackPtr + 1; \n pStack[*pStackPtr] = value; \n return EAS_SUCCESS; \n }",
  "cwe": "CWE-119",
  "codeline": "if (*pStackPtr >= CDL_STACK_SIZE)"
}
{
  "idx": 211,
  "target": 1,
  "vul": "void smp_process_keypress_notification(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) { \n uint8_t* p = (uint8_t*)p_data; \n uint8_t reason = SMP_INVALID_PARAMETERS; \n SMP_TRACE_DEBUG(\"%s\", __func__); \n p_cb->status = *(uint8_t*)p_data; \n if (smp_command_has_invalid_parameters(p_cb)) { \n smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &reason); \n return; \n } \n if (p != NULL) { \n STREAM_TO_UINT8(p_cb->peer_keypress_notification, p); \n } else { \n p_cb->peer_keypress_notification = BTM_SP_KEY_OUT_OF_RANGE; \n } \n p_cb->cb_evt = SMP_PEER_KEYPR_NOT_EVT; \n }",
  "no_vul": "void smp_process_keypress_notification(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) { \n uint8_t* p = (uint8_t*)p_data; \n uint8_t reason = SMP_INVALID_PARAMETERS; \n SMP_TRACE_DEBUG(\"%s\", __func__); \n if (smp_command_has_invalid_parameters(p_cb)) { \n if (p_cb->rcvd_cmd_len < 2) { \n android_errorWriteLog(0x534e4554, \"111936834\"); \n } \n smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &reason); \n return; \n } \n p_cb->status = *(uint8_t*)p_data; \n if (p != NULL) { \n STREAM_TO_UINT8(p_cb->peer_keypress_notification, p); \n } else { \n p_cb->peer_keypress_notification = BTM_SP_KEY_OUT_OF_RANGE; \n } \n p_cb->cb_evt = SMP_PEER_KEYPR_NOT_EVT; \n }",
  "cwe": "CWE-125",
  "codeline": "p_cb->status = *(uint8_t*)p_data;"
}
{
  "idx": 212,
  "target": 1,
  "vul": "void BnCrypto::readVector(const Parcel &data, Vector<uint8_t> &vector) const { \n uint32_t size = data.readInt32(); \n vector.insertAt((size_t)0, size); \n data.read(vector.editArray(), size); \n }",
  "no_vul": "void BnCrypto::readVector(const Parcel &data, Vector<uint8_t> &vector) const { \n uint32_t size = data.readInt32(); \n if (vector.insertAt((size_t)0, size) < 0) { \n vector.clear(); \n } \n if (data.read(vector.editArray(), size) != NO_ERROR) { \n vector.clear(); \n android_errorWriteWithInfoLog(0x534e4554, \"62872384\", -1, NULL, 0); \n } \n }",
  "cwe": "CWE-200",
  "codeline": "vector.insertAt((size_t)0, size);"
}
{
  "idx": 213,
  "target": 1,
  "vul": "static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel) \n { \n if (parcel == NULL) { \n return NULL; \n } \n android::Parcel* p = android::parcelForJavaObject(env, parcel); \n const size_t size = p->readInt32(); \n const void* regionData = p->readInplace(size); \n if (regionData == NULL) { \n return NULL; \n } \n SkRegion* region = new SkRegion; \n region->readFromMemory(regionData, size); \n return reinterpret_cast<jlong>(region); \n }",
  "no_vul": "static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel) \n { \n if (parcel == NULL) { \n return NULL; \n } \n android::Parcel* p = android::parcelForJavaObject(env, parcel); \n const size_t size = p->readInt32(); \n const void* regionData = p->readInplace(size); \n if (regionData == NULL) { \n return NULL; \n } \n SkRegion* region = new SkRegion; \n size_t actualSize = region->readFromMemory(regionData, size); \n if (size != actualSize) { \n delete region; \n return NULL; \n } \n return reinterpret_cast<jlong>(region); \n }",
  "cwe": "CWE-264",
  "codeline": "const void* regionData = p->readInplace(size);"
}
{
  "idx": 214,
  "target": 1,
  "vul": "status_t OMXNodeInstance::emptyBuffer( \n OMX::buffer_id buffer, \n OMX_U32 rangeOffset, OMX_U32 rangeLength, \n OMX_U32 flags, OMX_TICKS timestamp) { \n Mutex::Autolock autoLock(mLock); \n OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer); \n header->nFilledLen = rangeLength; \n header->nOffset = rangeOffset; \n BufferMeta *buffer_meta = \n static_cast<BufferMeta *>(header->pAppPrivate); \n buffer_meta->CopyToOMX(header); \n return emptyBuffer_l(header, flags, timestamp, (intptr_t)buffer); \n }",
  "no_vul": "status_t OMXNodeInstance::emptyBuffer( \n OMX::buffer_id buffer, \n OMX_U32 rangeOffset, OMX_U32 rangeLength, \n OMX_U32 flags, OMX_TICKS timestamp) { \n Mutex::Autolock autoLock(mLock); \n OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer); \n if (rangeOffset > header->nAllocLen \n || rangeLength > header->nAllocLen - rangeOffset) { \n return BAD_VALUE; \n } \n header->nFilledLen = rangeLength; \n header->nOffset = rangeOffset; \n BufferMeta *buffer_meta = \n static_cast<BufferMeta *>(header->pAppPrivate); \n buffer_meta->CopyToOMX(header); \n return emptyBuffer_l(header, flags, timestamp, (intptr_t)buffer); \n }",
  "cwe": "CWE-119",
  "codeline": "header->nFilledLen = rangeLength;"
}
{
  "idx": 215,
  "target": 1,
  "vul": "native_handle_t* native_handle_create(int numFds, int numInts) \n { \n native_handle_t* h = malloc( \n sizeof(native_handle_t) + sizeof(int)*(numFds+numInts)); \n if (h) { \n h->version = sizeof(native_handle_t); \n h->numFds = numFds; \n h->numInts = numInts; \n } \n return h; \n }",
  "no_vul": "native_handle_t* native_handle_create(int numFds, int numInts) \n { \n if (numFds < 0 || numInts < 0 || numFds > kMaxNativeFds || numInts > kMaxNativeInts) { \n return NULL; \n } \n size_t mallocSize = sizeof(native_handle_t) + (sizeof(int) * (numFds + numInts)); \n native_handle_t* h = malloc(mallocSize); \n if (h) { \n h->version = sizeof(native_handle_t); \n h->numFds = numFds; \n h->numInts = numInts; \n } \n return h; \n }",
  "cwe": "CWE-189",
  "codeline": "h->version = sizeof(native_handle_t);"
}
{
  "idx": 216,
  "target": 1,
  "vul": "void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) { \n if (len > outHeader->nAllocLen) { \n ALOGE(\"memset buffer too small: got %lu, expected %zu\", (unsigned long)outHeader->nAllocLen, len); \n android_errorWriteLog(0x534e4554, \"29422022\"); \n notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL); \n mSignalledError = true; \n return NULL; \n } \n return memset(outHeader->pBuffer, c, len); \n }",
  "no_vul": "void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) { \n if (len > outHeader->nAllocLen) { \n ALOGE(\"memset buffer too small: got %u, expected %zu\", outHeader->nAllocLen, len); \n android_errorWriteLog(0x534e4554, \"29422022\"); \n notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL); \n mSignalledError = true; \n return NULL; \n } \n return memset(outHeader->pBuffer, c, len); \n }",
  "cwe": "CWE-264",
  "codeline": "ALOGE(\"memset buffer too small: got %lu, expected %zu\", (unsigned long)outHeader->nAllocLen, len);"
}
{
  "idx": 217,
  "target": 1,
  "vul": "std::string utf16ToUtf8(const StringPiece16& utf16) { \n ssize_t utf8Length = utf16_to_utf8_length(utf16.data(), utf16.length()); \n if (utf8Length <= 0) { \n return {}; \n } \n std::string utf8; \n utf8.resize(utf8Length); \n utf16_to_utf8(utf16.data(), utf16.length(), &*utf8.begin()); \n return utf8; \n }",
  "no_vul": "std::string utf16ToUtf8(const StringPiece16& utf16) { \n ssize_t utf8Length = utf16_to_utf8_length(utf16.data(), utf16.length()); \n if (utf8Length <= 0) { \n return {}; \n } \n std::string utf8; \n utf8.resize(utf8Length + 1); \n utf16_to_utf8(utf16.data(), utf16.length(), &*utf8.begin(), utf8Length + 1); \n utf8.resize(utf8Length); \n return utf8; \n }",
  "cwe": "CWE-119",
  "codeline": "utf8.resize(utf8Length);"
}
{
  "idx": 218,
  "target": 1,
  "vul": "static jboolean enableNative(JNIEnv* env, jobject obj) { \n ALOGV(\"%s:\",__FUNCTION__); \n jboolean result = JNI_FALSE; \n if (!sBluetoothInterface) return result; \n int ret = sBluetoothInterface->enable(); \n result = (ret == BT_STATUS_SUCCESS || ret == BT_STATUS_DONE) ? JNI_TRUE : JNI_FALSE; \n return result; \n }",
  "no_vul": "static jboolean cancelDiscoveryNative(JNIEnv* env, jobject obj) { \n ALOGV(\"%s:\",__FUNCTION__); \n jboolean result = JNI_FALSE; \n if (!sBluetoothInterface) return result; \n int ret = sBluetoothInterface->cancel_discovery(); \n result = (ret == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE; \n return result; \n }",
  "cwe": "CWE-20",
  "codeline": "int ret = sBluetoothInterface->enable();"
}
{
  "idx": 219,
  "target": 1,
  "vul": "status_t NuPlayer::GenericSource::setBuffers( \n bool audio, Vector<MediaBuffer *> &buffers) { \n if (mIsWidevine && !audio && mVideoTrack.mSource != NULL) { \n return mVideoTrack.mSource->setBuffers(buffers); \n } \n return INVALID_OPERATION; \n }",
  "no_vul": "status_t NuPlayer::GenericSource::setBuffers( \n bool audio, Vector<MediaBuffer *> &buffers) { \n if (mIsSecure && !audio && mVideoTrack.mSource != NULL) { \n return mVideoTrack.mSource->setBuffers(buffers); \n } \n return INVALID_OPERATION; \n }",
  "cwe": "CWE-119",
  "codeline": "if (mIsWidevine && !audio && mVideoTrack.mSource != NULL) {"
}
{
  "idx": 220,
  "target": 1,
  "vul": "uint8_t smb2cli_session_security_mode(struct smbXcli_session *session) \n { \n struct smbXcli_conn *conn = session->conn; \n uint8_t security_mode = 0; \n if (conn == NULL) { \n return security_mode; \n } \n security_mode = SMB2_NEGOTIATE_SIGNING_ENABLED; \n if (conn->mandatory_signing) { \n security_mode |= SMB2_NEGOTIATE_SIGNING_REQUIRED; \n } \n return security_mode; \n }",
  "no_vul": "uint8_t smb2cli_session_security_mode(struct smbXcli_session *session) \n { \n struct smbXcli_conn *conn = session->conn; \n uint8_t security_mode = 0; \n if (conn == NULL) { \n return security_mode; \n } \n security_mode = SMB2_NEGOTIATE_SIGNING_ENABLED; \n if (conn->mandatory_signing) { \n security_mode |= SMB2_NEGOTIATE_SIGNING_REQUIRED; \n } \n if (session->smb2->should_sign) { \n security_mode |= SMB2_NEGOTIATE_SIGNING_REQUIRED; \n } \n return security_mode; \n }",
  "cwe": "CWE-20",
  "codeline": "if (conn->mandatory_signing) { \n security_mode |= SMB2_NEGOTIATE_SIGNING_REQUIRED; \n }"
}
{
  "idx": 221,
  "target": 1,
  "vul": "tbGetBuffer(unsigned size) \n { \n char *rtrn; \n if (size >= BUFFER_SIZE) \n return NULL; \n if ((BUFFER_SIZE - tbNext) <= size) \n tbNext = 0; \n rtrn = &textBuffer[tbNext]; \n tbNext += size; \n return rtrn; \n }",
  "no_vul": "tbGetBuffer(unsigned size) \n { \n struct textBuffer *tb; \n tb = &textBuffer[textBufferIndex]; \n textBufferIndex = (textBufferIndex + 1) % NUM_BUFFER; \n if (size > tb->size) { \n free(tb->buffer); \n tb->buffer = xnfalloc(size); \n tb->size = size; \n } \n return tb->buffer; \n }",
  "cwe": "CWE-119",
  "codeline": "if ((BUFFER_SIZE - tbNext) <= size) \ntbNext = 0;"
}
{
  "idx": 222,
  "target": 1,
  "vul": "static void Ins_JMPR( INS_ARG ) \n { \n CUR.IP += (Int)(args[0]); \n CUR.step_ins = FALSE; \n * allow for simple cases here by just checking the preceding byte. \n * Fonts with this problem are not uncommon. \n */ \n CUR.IP -= 1; \n }",
  "no_vul": "static void Ins_JMPR( INS_ARG ) \n { \n if ( BOUNDS(CUR.IP + args[0], CUR.codeSize ) ) \n { \n CUR.error = TT_Err_Invalid_Reference; \n return; \n } \n CUR.IP += (Int)(args[0]); \n CUR.step_ins = FALSE; \n * allow for simple cases here by just checking the preceding byte. \n * Fonts with this problem are not uncommon. \n */ \n CUR.IP -= 1; \n }",
  "cwe": "CWE-125",
  "codeline": "CUR.IP += (Int)(args[0]);"
}
{
  "idx": 223,
  "target": 1,
  "vul": "int __glXDispSwap_CreateContext(__GLXclientState *cl, GLbyte *pc) \n { \n xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc; \n __GLX_DECLARE_SWAP_VARIABLES; \n __GLX_SWAP_SHORT(&req->length); \n __GLX_SWAP_INT(&req->context); \n __GLX_SWAP_INT(&req->visual); \n return __glXDisp_CreateContext(cl, pc); \n }",
  "no_vul": "int __glXDispSwap_CreateContext(__GLXclientState *cl, GLbyte *pc) \n { \n ClientPtr client = cl->client; \n xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc; \n __GLX_DECLARE_SWAP_VARIABLES; \n REQUEST_SIZE_MATCH(xGLXCreateContextReq); \n __GLX_SWAP_SHORT(&req->length); \n __GLX_SWAP_INT(&req->context); \n __GLX_SWAP_INT(&req->visual); \n return __glXDisp_CreateContext(cl, pc); \n }",
  "cwe": "CWE-20",
  "codeline": "REQUEST_SIZE_MATCH(xGLXCreateContextReq);"
}
{
  "idx": 224,
  "target": 1,
  "vul": "static ssize_t exitcode_proc_write(struct file *file, \n const char __user *buffer, size_t count, loff_t *pos) \n { \n char *end, buf[sizeof(\"nnnnn\\0\")]; \n int tmp; \n if (copy_from_user(buf, buffer, count)) \n return -EFAULT; \n tmp = simple_strtol(buf, &end, 0); \n if ((*end != '\\0') && !isspace(*end)) \n return -EINVAL; \n uml_exitcode = tmp; \n return count; \n }",
  "no_vul": "static ssize_t exitcode_proc_write(struct file *file, \n const char __user *buffer, size_t count, loff_t *pos) \n { \n char *end, buf[sizeof(\"nnnnn\\0\")]; \n size_t size; \n int tmp; \n size = min(count, sizeof(buf)); \n if (copy_from_user(buf, buffer, size)) \n return -EFAULT; \n tmp = simple_strtol(buf, &end, 0); \n if ((*end != '\\0') && !isspace(*end)) \n return -EINVAL; \n uml_exitcode = tmp; \n return count; \n }",
  "cwe": "CWE-119",
  "codeline": "if (copy_from_user(buf, buffer, count))"
}
{
  "idx": 225,
  "target": 1,
  "vul": "static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh) \n { \n int err; \n struct sock_diag_req *req = nlmsg_data(nlh); \n const struct sock_diag_handler *hndl; \n if (nlmsg_len(nlh) < sizeof(*req)) \n return -EINVAL; \n hndl = sock_diag_lock_handler(req->sdiag_family); \n if (hndl == NULL) \n err = -ENOENT; \n else \n err = hndl->dump(skb, nlh); \n sock_diag_unlock_handler(hndl); \n return err; \n }",
  "no_vul": "static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh) \n { \n int err; \n struct sock_diag_req *req = nlmsg_data(nlh); \n const struct sock_diag_handler *hndl; \n if (nlmsg_len(nlh) < sizeof(*req)) \n return -EINVAL; \n if (req->sdiag_family >= AF_MAX) \n return -EINVAL; \n hndl = sock_diag_lock_handler(req->sdiag_family); \n if (hndl == NULL) \n err = -ENOENT; \n else \n err = hndl->dump(skb, nlh); \n sock_diag_unlock_handler(hndl); \n return err; \n }",
  "cwe": "CWE-20",
  "codeline": "if (nlmsg_len(nlh) < sizeof(*req)) \n return -EINVAL;"
}
{
  "idx": 226,
  "target": 1,
  "vul": "static int wddx_stack_destroy(wddx_stack *stack) \n { \n register int i; \n if (stack->elements) { \n for (i = 0; i < stack->top; i++) { \n if (((st_entry *)stack->elements[i])->data) { \n zval_ptr_dtor(&((st_entry *)stack->elements[i])->data); \n } \n if (((st_entry *)stack->elements[i])->varname) { \n efree(((st_entry *)stack->elements[i])->varname); \n } \n efree(stack->elements[i]); \n } \n efree(stack->elements); \n } \n return SUCCESS; \n }",
  "no_vul": "static int wddx_stack_destroy(wddx_stack *stack) \n { \n register int i; \n if (stack->elements) { \n for (i = 0; i < stack->top; i++) { \n if (((st_entry *)stack->elements[i])->data \n && ((st_entry *)stack->elements[i])->type != ST_FIELD) { \n zval_ptr_dtor(&((st_entry *)stack->elements[i])->data); \n } \n if (((st_entry *)stack->elements[i])->varname) { \n efree(((st_entry *)stack->elements[i])->varname); \n } \n efree(stack->elements[i]); \n } \n efree(stack->elements); \n } \n return SUCCESS; \n }",
  "cwe": "CWE-416",
  "codeline": "if (((st_entry *)stack->elements[i])->data) {"
}
{
  "idx": 227,
  "target": 1,
  "vul": "int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj) \n { \n char obj_txt[128]; \n int len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0); \n BIO_write(bio, obj_txt, len); \n BIO_write(bio, \"\\n\", 1); \n return 1; \n }",
  "no_vul": "int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj) \n { \n char obj_txt[128]; \n OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0); \n BIO_printf(bio, \"%s\\n\", obj_txt); \n return 1; \n }",
  "cwe": "CWE-125",
  "codeline": "BIO_write(bio, obj_txt, len);"
}
{
  "idx": 228,
  "target": 1,
  "vul": "static int uas_switch_interface(struct usb_device *udev, \n struct usb_interface *intf) \n { \n int alt; \n alt = uas_find_uas_alt_setting(intf); \n if (alt < 0) \n return alt; \n return usb_set_interface(udev, \n intf->altsetting[0].desc.bInterfaceNumber, alt); \n }",
  "no_vul": "static int uas_switch_interface(struct usb_device *udev, \n struct usb_interface *intf) \n { \n struct usb_host_interface *alt; \n alt = uas_find_uas_alt_setting(intf); \n if (!alt) \n return -ENODEV; \n return usb_set_interface(udev, alt->desc.bInterfaceNumber, \n alt->desc.bAlternateSetting); \n }",
  "cwe": "CWE-125",
  "codeline": "return usb_set_interface(udev, \n intf->altsetting[0].desc.bInterfaceNumber, alt);"
}
{
  "idx": 229,
  "target": 1,
  "vul": "static int put_chars(u32 vtermno, const char *buf, int count) \n { \n struct port *port; \n struct scatterlist sg[1]; \n if (unlikely(early_put_chars)) \n return early_put_chars(vtermno, buf, count); \n port = find_port_by_vtermno(vtermno); \n if (!port) \n return -EPIPE; \n sg_init_one(sg, buf, count); \n return __send_to_port(port, sg, 1, count, (void *)buf, false); \n }",
  "no_vul": "static int put_chars(u32 vtermno, const char *buf, int count) \n { \n struct port *port; \n struct scatterlist sg[1]; \n void *data; \n int ret; \n if (unlikely(early_put_chars)) \n return early_put_chars(vtermno, buf, count); \n port = find_port_by_vtermno(vtermno); \n if (!port) \n return -EPIPE; \n data = kmemdup(buf, count, GFP_ATOMIC); \n if (!data) \n return -ENOMEM; \n sg_init_one(sg, data, count); \n ret = __send_to_port(port, sg, 1, count, data, false); \n kfree(data); \n return ret; \n }",
  "cwe": "CWE-119",
  "codeline": "sg_init_one(sg, buf, count);"
}
{
  "idx": 230,
  "target": 1,
  "vul": "static int nfc_genl_deactivate_target(struct sk_buff *skb, \n struct genl_info *info) \n { \n struct nfc_dev *dev; \n u32 device_idx, target_idx; \n int rc; \n if (!info->attrs[NFC_ATTR_DEVICE_INDEX]) \n return -EINVAL; \n device_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]); \n dev = nfc_get_device(device_idx); \n if (!dev) \n return -ENODEV; \n target_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]); \n rc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP); \n nfc_put_device(dev); \n return rc; \n }",
  "no_vul": "static int nfc_genl_deactivate_target(struct sk_buff *skb, \n struct genl_info *info) \n { \n struct nfc_dev *dev; \n u32 device_idx, target_idx; \n int rc; \n if (!info->attrs[NFC_ATTR_DEVICE_INDEX] || \n !info->attrs[NFC_ATTR_TARGET_INDEX]) \n return -EINVAL; \n device_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]); \n dev = nfc_get_device(device_idx); \n if (!dev) \n return -ENODEV; \n target_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]); \n rc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP); \n nfc_put_device(dev); \n return rc; \n }",
  "cwe": "CWE-476",
  "codeline": "target_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);"
}
{
  "idx": 231,
  "target": 1,
  "vul": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb, \n int rw, char __user *buf, \n unsigned long *nr_segs, \n size_t len, \n struct iovec *iovec) \n { \n if (unlikely(!access_ok(!rw, buf, len))) \n return -EFAULT; \n iovec->iov_base = buf; \n iovec->iov_len = len; \n *nr_segs = 1; \n return 0; \n }",
  "no_vul": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb, \n int rw, char __user *buf, \n unsigned long *nr_segs, \n size_t len, \n struct iovec *iovec, \n struct iov_iter *iter) \n { \n if (len > MAX_RW_COUNT) \n len = MAX_RW_COUNT; \n if (unlikely(!access_ok(!rw, buf, len))) \n return -EFAULT; \n iovec->iov_base = buf; \n iovec->iov_len = len; \n *nr_segs = 1; \n iov_iter_init(iter, rw, iovec, *nr_segs, len); \n return 0; \n }",
  "cwe": "CWE-703",
  "codeline": "if (unlikely(!access_ok(!rw, buf, len))) \n return -EFAULT;"
}
{
  "idx": 232,
  "target": 1,
  "vul": "void BeginInstallWithManifestFunction::OnParseSuccess( \n const SkBitmap& icon, DictionaryValue* parsed_manifest) { \n CHECK(parsed_manifest); \n icon_ = icon; \n parsed_manifest_.reset(parsed_manifest); \n std::string init_errors; \n dummy_extension_ = Extension::Create( \n FilePath(), \n Extension::INTERNAL, \n *static_cast<DictionaryValue*>(parsed_manifest_.get()), \n Extension::NO_FLAGS, \n &init_errors); \n if (!dummy_extension_.get()) { \n OnParseFailure(MANIFEST_ERROR, std::string(kInvalidManifestError)); \n return; \n } \n if (icon_.empty()) \n icon_ = Extension::GetDefaultIcon(dummy_extension_->is_app()); \n ShowExtensionInstallDialog(profile(), \n this, \n dummy_extension_.get(), \n &icon_, \n dummy_extension_->GetPermissionMessageStrings(), \n ExtensionInstallUI::INSTALL_PROMPT); \n }",
  "no_vul": "void BeginInstallWithManifestFunction::OnParseSuccess( \n const SkBitmap& icon, DictionaryValue* parsed_manifest) { \n CHECK(parsed_manifest); \n icon_ = icon; \n parsed_manifest_.reset(parsed_manifest); \n std::string init_errors; \n dummy_extension_ = Extension::Create( \n FilePath(), \n Extension::INTERNAL, \n *static_cast<DictionaryValue*>(parsed_manifest_.get()), \n Extension::NO_FLAGS, \n &init_errors); \n if (!dummy_extension_.get()) { \n OnParseFailure(MANIFEST_ERROR, std::string(kInvalidManifestError)); \n return; \n } \n if (icon_.empty()) \n icon_ = Extension::GetDefaultIcon(dummy_extension_->is_app()); \n if (auto_confirm_for_tests != DO_NOT_SKIP) { \n if (auto_confirm_for_tests == PROCEED) \n this->InstallUIProceed(); \n else \n this->InstallUIAbort(); \n return; \n } \n ShowExtensionInstallDialog(profile(), \n this, \n dummy_extension_.get(), \n &icon_, \n dummy_extension_->GetPermissionMessageStrings(), \n ExtensionInstallUI::INSTALL_PROMPT); \n }",
  "cwe": "CWE-20",
  "codeline": "dummy_extension_ = Extension::Create( \n FilePath(), \n Extension::INTERNAL, \n *static_cast<DictionaryValue*>(parsed_manifest_.get()), \n Extension::NO_FLAGS, \n &init_errors);"
}
{
  "idx": 233,
  "target": 1,
  "vul": "MediaStreamImpl::~MediaStreamImpl() { \n DCHECK(!peer_connection_handler_); \n if (dependency_factory_.get()) \n dependency_factory_->ReleasePeerConnectionFactory(); \n if (network_manager_) { \n if (chrome_worker_thread_.IsRunning()) { \n chrome_worker_thread_.message_loop()->PostTask(FROM_HERE, base::Bind( \n &MediaStreamImpl::DeleteIpcNetworkManager, \n base::Unretained(this))); \n } else { \n NOTREACHED() << \"Worker thread not running.\"; \n } \n } \n }",
  "no_vul": "MediaStreamImpl::~MediaStreamImpl() { \n DCHECK(!peer_connection_handler_); \n if (dependency_factory_.get()) \n dependency_factory_->ReleasePeerConnectionFactory(); \n if (network_manager_) { \n if (chrome_worker_thread_.IsRunning()) { \n chrome_worker_thread_.message_loop()->PostTask(FROM_HERE, base::Bind( \n &MediaStreamImpl::DeleteIpcNetworkManager, \n base::Unretained(this))); \n chrome_worker_thread_.Stop(); \n } else { \n NOTREACHED() << \"Worker thread not running.\"; \n } \n } \n }",
  "cwe": "CWE-399",
  "codeline": "chrome_worker_thread_.Stop();"
}
{
  "idx": 234,
  "target": 1,
  "vul": "void SystemClipboard::WriteImage(Image* image, \n const KURL& url, \n const String& title) { \n DCHECK(image); \n PaintImage paint_image = image->PaintImageForCurrentFrame(); \n SkBitmap bitmap; \n if (sk_sp<SkImage> sk_image = paint_image.GetSkImage()) \n sk_image->asLegacyBitmap(&bitmap); \n if (bitmap.isNull()) \n return; \n if (!bitmap.getPixels()) \n return; \n clipboard_->WriteImage(mojom::ClipboardBuffer::kStandard, bitmap); \n if (url.IsValid() && !url.IsEmpty()) { \n #if !defined(OS_MACOSX) \n clipboard_->WriteBookmark(mojom::ClipboardBuffer::kStandard, \n url.GetString(), NonNullString(title)); \n #endif \n clipboard_->WriteHtml(mojom::ClipboardBuffer::kStandard, \n URLToImageMarkup(url, title), KURL()); \n } \n clipboard_->CommitWrite(mojom::ClipboardBuffer::kStandard); \n }",
  "no_vul": "void SystemClipboard::WriteImage(Image* image, \n const KURL& url, \n const String& title) { \n DCHECK(image); \n PaintImage paint_image = image->PaintImageForCurrentFrame(); \n SkBitmap bitmap; \n if (sk_sp<SkImage> sk_image = paint_image.GetSkImage()) \n sk_image->asLegacyBitmap(&bitmap); \n if (bitmap.isNull()) \n return; \n CHECK(bitmap.getPixels()); \n clipboard_->WriteImage(mojom::ClipboardBuffer::kStandard, bitmap); \n if (url.IsValid() && !url.IsEmpty()) { \n #if !defined(OS_MACOSX) \n clipboard_->WriteBookmark(mojom::ClipboardBuffer::kStandard, \n url.GetString(), NonNullString(title)); \n #endif \n clipboard_->WriteHtml(mojom::ClipboardBuffer::kStandard, \n URLToImageMarkup(url, title), KURL()); \n } \n clipboard_->CommitWrite(mojom::ClipboardBuffer::kStandard); \n }",
  "cwe": "CWE-119",
  "codeline": "if (!bitmap.getPixels()) \nreturn;"
}
{
  "idx": 235,
  "target": 1,
  "vul": "std::string GetUploadData(const std::string& brand) { \n DCHECK(!brand.empty()); \n std::string data(kPostXml); \n const std::string placeholder(\"__BRANDCODE_PLACEHOLDER__\"); \n size_t placeholder_pos = data.find(placeholder); \n DCHECK(placeholder_pos != std::string::npos); \n data.replace(placeholder_pos, placeholder.size(), brand); \n return data; \n }",
  "no_vul": "std::string GetUploadData(const std::string& brand) { \n std::string app_id(kDefaultAppID); \n #if defined(OS_WIN) \n app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid()); \n #endif \n DCHECK(!brand.empty()); \n return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str()); \n }",
  "cwe": "CWE-79",
  "codeline": "data.replace(placeholder_pos, placeholder.size(), brand);"
}
{
  "idx": 236,
  "target": 1,
  "vul": "void RenderWidgetHostImpl::DidNavigate(uint32_t next_source_id) { \n current_content_source_id_ = next_source_id; \n did_receive_first_frame_after_navigation_ = false; \n if (enable_surface_synchronization_) { \n visual_properties_ack_pending_ = false; \n viz::LocalSurfaceId old_surface_id = view_->GetLocalSurfaceId(); \n if (view_) \n view_->DidNavigate(); \n viz::LocalSurfaceId new_surface_id = view_->GetLocalSurfaceId(); \n if (old_surface_id == new_surface_id) \n return; \n } else { \n if (last_received_content_source_id_ >= current_content_source_id_) \n return; \n } \n if (!new_content_rendering_timeout_) \n return; \n new_content_rendering_timeout_->Start(new_content_rendering_delay_); \n }",
  "no_vul": "void RenderWidgetHostImpl::DidNavigate(uint32_t next_source_id) { \n current_content_source_id_ = next_source_id; \n did_receive_first_frame_after_navigation_ = false; \n if (enable_surface_synchronization_) { \n visual_properties_ack_pending_ = false; \n if (view_) \n view_->DidNavigate(); \n } else { \n if (last_received_content_source_id_ >= current_content_source_id_) \n return; \n } \n if (!new_content_rendering_timeout_) \n return; \n new_content_rendering_timeout_->Start(new_content_rendering_delay_); \n }",
  "cwe": "CWE-20",
  "codeline": "viz::LocalSurfaceId old_surface_id = view_->GetLocalSurfaceId();"
}
{
  "idx": 237,
  "target": 1,
  "vul": "void MimeHandlerViewContainer::OnReady() { \n if (!render_frame() || !is_embedded_) \n return; \n blink::WebLocalFrame* frame = render_frame()->GetWebFrame(); \n blink::WebAssociatedURLLoaderOptions options; \n DCHECK(!loader_); \n loader_.reset(frame->CreateAssociatedURLLoader(options)); \n blink::WebURLRequest request(original_url_); \n request.SetRequestContext(blink::WebURLRequest::kRequestContextObject); \n loader_->LoadAsynchronously(request, this); \n }",
  "no_vul": "void MimeHandlerViewContainer::OnReady() { \n if (!render_frame() || !is_embedded_) \n return; \n blink::WebLocalFrame* frame = render_frame()->GetWebFrame(); \n blink::WebAssociatedURLLoaderOptions options; \n DCHECK(!loader_); \n loader_.reset(frame->CreateAssociatedURLLoader(options)); \n blink::WebURLRequest request(original_url_); \n request.SetRequestContext(blink::WebURLRequest::kRequestContextObject); \n request.SetServiceWorkerMode(blink::WebURLRequest::ServiceWorkerMode::kNone); \n loader_->LoadAsynchronously(request, this); \n }",
  "cwe": "CWE-20",
  "codeline": "loader_->LoadAsynchronously(request, this);"
}
{
  "idx": 238,
  "target": 1,
  "vul": "void MediaStreamDispatcherHost::DoOpenDevice( \n int32_t page_request_id, \n const std::string& device_id, \n blink::MediaStreamType type, \n OpenDeviceCallback callback, \n MediaDeviceSaltAndOrigin salt_and_origin) { \n DCHECK_CURRENTLY_ON(BrowserThread::IO); \n if (!MediaStreamManager::IsOriginAllowed(render_process_id_, \n salt_and_origin.origin)) { \n std::move(callback).Run(false , std::string(), \n blink::MediaStreamDevice()); \n return; \n } \n media_stream_manager_->OpenDevice( \n render_process_id_, render_frame_id_, page_request_id, requester_id_, \n device_id, type, std::move(salt_and_origin), std::move(callback), \n base::BindRepeating(&MediaStreamDispatcherHost::OnDeviceStopped, \n weak_factory_.GetWeakPtr())); \n }",
  "no_vul": "void MediaStreamDispatcherHost::DoOpenDevice( \n int32_t page_request_id, \n const std::string& device_id, \n blink::MediaStreamType type, \n OpenDeviceCallback callback, \n MediaDeviceSaltAndOrigin salt_and_origin) { \n DCHECK_CURRENTLY_ON(BrowserThread::IO); \n if (!MediaStreamManager::IsOriginAllowed(render_process_id_, \n salt_and_origin.origin)) { \n std::move(callback).Run(false , std::string(), \n blink::MediaStreamDevice()); \n return; \n } \n media_stream_manager_->OpenDevice( \n render_process_id_, render_frame_id_, requester_id_, page_request_id, \n device_id, type, std::move(salt_and_origin), std::move(callback), \n base::BindRepeating(&MediaStreamDispatcherHost::OnDeviceStopped, \n weak_factory_.GetWeakPtr())); \n }",
  "cwe": "CWE-119",
  "codeline": "media_stream_manager_->OpenDevice( \n render_process_id_, render_frame_id_, page_request_id, requester_id_, \n device_id, type, std::move(salt_and_origin), std::move(callback), \n base::BindRepeating(&MediaStreamDispatcherHost::OnDeviceStopped, \n weak_factory_.GetWeakPtr()));"
}
{
  "idx": 239,
  "target": 1,
  "vul": "std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) { \n std::string func_name = GetFunctionNameRaw(pc, offset); \n if (!func_name.empty()) { \n #if defined(__APPLE__) \n if (func_name[0] != '_') { \n return func_name; \n } \n #endif \n char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0); \n if (name) { \n func_name = name; \n free(name); \n } \n } \n return func_name; \n }",
  "no_vul": "std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) { \n std::string func_name = GetFunctionNameRaw(pc, offset); \n return func_name; \n }",
  "cwe": "CWE-264",
  "codeline": "char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);"
}
{
  "idx": 240,
  "target": 1,
  "vul": "void phar_add_virtual_dirs(phar_archive_data *phar, char *filename, int filename_len TSRMLS_DC) \n { \n const char *s; \n while ((s = zend_memrchr(filename, '/', filename_len))) { \n filename_len = s - filename; \n if (FAILURE == zend_hash_add_empty_element(&phar->virtual_dirs, filename, filename_len)) { \n break; \n } \n } \n }",
  "no_vul": "void phar_add_virtual_dirs(phar_archive_data *phar, char *filename, int filename_len TSRMLS_DC) \n { \n const char *s; \n while ((s = zend_memrchr(filename, '/', filename_len))) { \n filename_len = s - filename; \n if (!filename_len || FAILURE == zend_hash_add_empty_element(&phar->virtual_dirs, filename, filename_len)) { \n break; \n } \n } \n }",
  "cwe": "CWE-189",
  "codeline": "if (FAILURE == zend_hash_add_empty_element(&phar->virtual_dirs, filename, filename_len)) {"
}
{
  "idx": 241,
  "target": 1,
  "vul": "static void coroutine_fn v9fs_wstat(void *opaque) \n { \n int32_t fid; \n int err = 0; \n int16_t unused; \n V9fsStat v9stat; \n size_t offset = 7; \n struct stat stbuf; \n V9fsFidState *fidp; \n V9fsPDU *pdu = opaque; \n v9fs_stat_init(&v9stat); \n err = pdu_unmarshal(pdu, offset, \"dwS\", &fid, &unused, &v9stat); \n goto out_nofid; \n }",
  "no_vul": "static void coroutine_fn v9fs_wstat(void *opaque) \n { \n int32_t fid; \n int err = 0; \n int16_t unused; \n V9fsStat v9stat; \n size_t offset = 7; \n struct stat stbuf; \n V9fsFidState *fidp; \n V9fsPDU *pdu = opaque; \n V9fsState *s = pdu->s; \n v9fs_stat_init(&v9stat); \n err = pdu_unmarshal(pdu, offset, \"dwS\", &fid, &unused, &v9stat); \n goto out_nofid; \n }",
  "cwe": "CWE-362",
  "codeline": "goto out_nofid;"
}
{
  "idx": 242,
  "target": 1,
  "vul": "static PHP_GINIT_FUNCTION(libxml) \n { \n libxml_globals->stream_context = NULL; \n libxml_globals->error_buffer.c = NULL; \n libxml_globals->error_list = NULL; \n }",
  "no_vul": "static PHP_GINIT_FUNCTION(libxml) \n { \n libxml_globals->stream_context = NULL; \n libxml_globals->error_buffer.c = NULL; \n libxml_globals->error_list = NULL; \n libxml_globals->entity_loader_disabled = 0; \n }",
  "cwe": "CWE-200",
  "codeline": "libxml_globals->error_buffer.c = NULL;"
}
{
  "idx": 243,
  "target": 1,
  "vul": "static int bmdma_prepare_buf(IDEDMA *dma, int is_write) \n { \n BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma); \n IDEState *s = bmdma_active_if(bm); \n uint32_t size; \n } prd;",
  "no_vul": "static int bmdma_prepare_buf(IDEDMA *dma, int is_write) \n static int32_t bmdma_prepare_buf(IDEDMA *dma, int is_write) \n { \n BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma); \n IDEState *s = bmdma_active_if(bm); \n uint32_t size; \n } prd;",
  "cwe": "CWE-399",
  "codeline": "static int bmdma_prepare_buf(IDEDMA *dma, int is_write)"
}
{
  "idx": 244,
  "target": 1,
  "vul": "void v9fs_device_unrealize_common(V9fsState *s, Error **errp) \n { \n g_free(s->ctx.fs_root); \n g_free(s->tag); \n }",
  "no_vul": "void v9fs_device_unrealize_common(V9fsState *s, Error **errp) \n { \n g_free(s->tag); \n g_free(s->ctx.fs_root); \n }",
  "cwe": "CWE-400",
  "codeline": "g_free(s->ctx.fs_root);"
}
{
  "idx": 245,
  "target": 1,
  "vul": "pvscsi_ring_pop_req_descr(PVSCSIRingInfo *mgr) \n { \n uint32_t ready_ptr = RS_GET_FIELD(mgr, reqProdIdx); \n if (ready_ptr != mgr->consumed_ptr) { \n uint32_t next_ready_ptr = \n mgr->consumed_ptr++ & mgr->txr_len_mask; \n uint32_t next_ready_page = \n return mgr->req_ring_pages_pa[next_ready_page] + \n inpage_idx * sizeof(PVSCSIRingReqDesc); \n } else { \n return 0; \n } \n }",
  "no_vul": "pvscsi_ring_pop_req_descr(PVSCSIRingInfo *mgr) \n { \n uint32_t ready_ptr = RS_GET_FIELD(mgr, reqProdIdx); \n uint32_t ring_size = PVSCSI_MAX_NUM_PAGES_REQ_RING \n * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE; \n if (ready_ptr != mgr->consumed_ptr \n && ready_ptr - mgr->consumed_ptr < ring_size) { \n uint32_t next_ready_ptr = \n mgr->consumed_ptr++ & mgr->txr_len_mask; \n uint32_t next_ready_page = \n return mgr->req_ring_pages_pa[next_ready_page] + \n inpage_idx * sizeof(PVSCSIRingReqDesc); \n } else { \n return 0; \n } \n }",
  "cwe": "CWE-399",
  "codeline": "if (ready_ptr != mgr->consumed_ptr) {"
}
{
  "idx": 246,
  "target": 1,
  "vul": "size_t mptsas_config_ioc_0(MPTSASState *s, uint8_t **data, int address) \n { \n PCIDeviceClass *pcic = PCI_DEVICE_GET_CLASS(s); \n return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_IOC, 0x01, \n \"*l*lwwb*b*b*blww\", \n pcic->vendor_id, pcic->device_id, pcic->revision, \n pcic->subsystem_vendor_id, \n pcic->subsystem_id); \n }",
  "no_vul": "size_t mptsas_config_ioc_0(MPTSASState *s, uint8_t **data, int address) \n { \n PCIDeviceClass *pcic = PCI_DEVICE_GET_CLASS(s); \n return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_IOC, 0x01, \n \"*l*lwwb*b*b*blww\", \n pcic->vendor_id, pcic->device_id, pcic->revision, \n pcic->class_id, pcic->subsystem_vendor_id, \n pcic->subsystem_id); \n }",
  "cwe": "CWE-20",
  "codeline": "pcic->subsystem_vendor_id, pcic->subsystem_id);"
}
{
  "idx": 247,
  "target": 1,
  "vul": "size_t mptsas_config_manufacturing_1(MPTSASState *s, uint8_t **data, int address) \n { \n return MPTSAS_CONFIG_PACK(1, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00, \n \"s256\"); \n }",
  "no_vul": "size_t mptsas_config_manufacturing_1(MPTSASState *s, uint8_t **data, int address) \n { \n return MPTSAS_CONFIG_PACK(1, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00, \n \"*s256\"); \n }",
  "cwe": "CWE-20",
  "codeline": "return MPTSAS_CONFIG_PACK(1, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00, \n \"s256\");"
}
{
  "idx": 248,
  "target": 1,
  "vul": "pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri) \n { \n int i; \n uint32_t txr_len_log2, rxr_len_log2; \n uint32_t req_ring_size, cmp_ring_size; \n m->rs_pa = ri->ringsStatePPN << VMW_PAGE_SHIFT; \n if ((ri->reqRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES) \n || (ri->cmpRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)) { \n return -1; \n } \n req_ring_size = ri->reqRingNumPages * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE; \n cmp_ring_size = ri->cmpRingNumPages * PVSCSI_MAX_NUM_CMP_ENTRIES_PER_PAGE; \n txr_len_log2 = pvscsi_log2(req_ring_size - 1); \n }",
  "no_vul": "pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri) \n { \n int i; \n uint32_t txr_len_log2, rxr_len_log2; \n uint32_t req_ring_size, cmp_ring_size; \n m->rs_pa = ri->ringsStatePPN << VMW_PAGE_SHIFT; \n req_ring_size = ri->reqRingNumPages * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE; \n cmp_ring_size = ri->cmpRingNumPages * PVSCSI_MAX_NUM_CMP_ENTRIES_PER_PAGE; \n txr_len_log2 = pvscsi_log2(req_ring_size - 1); \n }",
  "cwe": "CWE-125",
  "codeline": "if ((ri->reqRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES) \n || (ri->cmpRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)) { \n return -1; \n }"
}
{
  "idx": 249,
  "target": 1,
  "vul": "static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx) \n { \n struct Vmxnet3_TxCompDesc txcq_descr; \n PCIDevice *d = PCI_DEVICE(s); \n VMXNET3_RING_DUMP(VMW_RIPRN, \"TXC\", qidx, &s->txq_descr[qidx].comp_ring); \n txcq_descr.txdIdx = tx_ridx; \n txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring); \n smp_wmb(); \n vmxnet3_inc_tx_completion_counter(s, qidx); \n vmxnet3_trigger_interrupt(s, s->txq_descr[qidx].intr_idx); \n }",
  "no_vul": "static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx) \n { \n struct Vmxnet3_TxCompDesc txcq_descr; \n PCIDevice *d = PCI_DEVICE(s); \n VMXNET3_RING_DUMP(VMW_RIPRN, \"TXC\", qidx, &s->txq_descr[qidx].comp_ring); \n memset(&txcq_descr, 0, sizeof(txcq_descr)); \n txcq_descr.txdIdx = tx_ridx; \n txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring); \n smp_wmb(); \n vmxnet3_inc_tx_completion_counter(s, qidx); \n vmxnet3_trigger_interrupt(s, s->txq_descr[qidx].intr_idx); \n }",
  "cwe": "CWE-200",
  "codeline": "txcq_descr.txdIdx = tx_ridx;"
}
{
  "idx": 250,
  "target": 1,
  "vul": "static void esp_do_dma(ESPState *s) \n { \n uint32_t len; \n int to_device; \n len = s->dma_left; \n if (s->do_cmd) { \n trace_esp_do_dma(s->cmdlen, len); \n s->dma_memory_read(s->dma_opaque, &s->cmdbuf[s->cmdlen], len); \n return; \n } \n return; \n }",
  "no_vul": "static void esp_do_dma(ESPState *s) \n { \n uint32_t len; \n int to_device; \n len = s->dma_left; \n if (s->do_cmd) { \n trace_esp_do_dma(s->cmdlen, len); \n assert (s->cmdlen <= sizeof(s->cmdbuf) && \n len <= sizeof(s->cmdbuf) - s->cmdlen); \n s->dma_memory_read(s->dma_opaque, &s->cmdbuf[s->cmdlen], len); \n return; \n } \n return; \n }",
  "cwe": "CWE-787",
  "codeline": "s->dma_memory_read(s->dma_opaque, &s->cmdbuf[s->cmdlen], len);"
}
{
  "idx": 251,
  "target": 1,
  "vul": "static void virgl_resource_attach_backing(VirtIOGPU *g, \n struct virtio_gpu_ctrl_command *cmd) \n { \n struct virtio_gpu_resource_attach_backing att_rb; \n struct iovec *res_iovs; \n int ret; \n VIRTIO_GPU_FILL_CMD(att_rb); \n trace_virtio_gpu_cmd_res_back_attach(att_rb.resource_id); \n ret = virtio_gpu_create_mapping_iov(&att_rb, cmd, NULL, &res_iovs); \n if (ret != 0) { \n cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC; \n return; \n } \n virgl_renderer_resource_attach_iov(att_rb.resource_id, \n res_iovs, att_rb.nr_entries); \n }",
  "no_vul": "static void virgl_resource_attach_backing(VirtIOGPU *g, \n struct virtio_gpu_ctrl_command *cmd) \n { \n struct virtio_gpu_resource_attach_backing att_rb; \n struct iovec *res_iovs; \n int ret; \n VIRTIO_GPU_FILL_CMD(att_rb); \n trace_virtio_gpu_cmd_res_back_attach(att_rb.resource_id); \n ret = virtio_gpu_create_mapping_iov(&att_rb, cmd, NULL, &res_iovs); \n if (ret != 0) { \n cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC; \n return; \n } \n ret = virgl_renderer_resource_attach_iov(att_rb.resource_id, \n res_iovs, att_rb.nr_entries); \n if (ret != 0) \n virtio_gpu_cleanup_mapping_iov(res_iovs, att_rb.nr_entries); \n }",
  "cwe": "CWE-772",
  "codeline": "virgl_renderer_resource_attach_iov(att_rb.resource_id, res_iovs, att_rb.nr_entries);"
}
{
  "idx": 252,
  "target": 1,
  "vul": "static int ne2000_buffer_full(NE2000State *s) \n { \n int avail, index, boundary; \n index = s->curpag << 8; \n boundary = s->boundary << 8; \n if (index < boundary) \n return 1; \n return 0; \n }",
  "no_vul": "static int ne2000_buffer_full(NE2000State *s) \n { \n int avail, index, boundary; \n if (s->stop <= s->start) { \n return 1; \n } \n index = s->curpag << 8; \n boundary = s->boundary << 8; \n if (index < boundary) \n return 1; \n return 0; \n }",
  "cwe": "CWE-20",
  "codeline": "index = s->curpag << 8;"
}
{
  "idx": 253,
  "target": 1,
  "vul": "static int vmxnet3_post_load(void *opaque, int version_id) \n { \n VMXNET3State *s = opaque; \n PCIDevice *d = PCI_DEVICE(s); \n vmxnet_tx_pkt_init(&s->tx_pkt, s->max_tx_frags, s->peer_has_vhdr); \n vmxnet_rx_pkt_init(&s->rx_pkt, s->peer_has_vhdr); \n if (s->msix_used) { \n if (!vmxnet3_use_msix_vectors(s, VMXNET3_MAX_INTRS)) { \n VMW_WRPRN(\"Failed to re-use MSI-X vectors\"); \n msix_uninit(d, &s->msix_bar, &s->msix_bar); \n s->msix_used = false; \n return -1; \n } \n } \n return 0; \n }",
  "no_vul": "static int vmxnet3_post_load(void *opaque, int version_id) \n { \n VMXNET3State *s = opaque; \n PCIDevice *d = PCI_DEVICE(s); \n vmxnet_tx_pkt_init(&s->tx_pkt, s->max_tx_frags, s->peer_has_vhdr); \n vmxnet_rx_pkt_init(&s->rx_pkt, s->peer_has_vhdr); \n if (s->msix_used) { \n if (!vmxnet3_use_msix_vectors(s, VMXNET3_MAX_INTRS)) { \n VMW_WRPRN(\"Failed to re-use MSI-X vectors\"); \n msix_uninit(d, &s->msix_bar, &s->msix_bar); \n s->msix_used = false; \n return -1; \n } \n } \n vmxnet3_validate_interrupts(s); \n return 0; \n }",
  "cwe": "CWE-20",
  "codeline": "if (!vmxnet3_use_msix_vectors(s, VMXNET3_MAX_INTRS)) {"
}
{
  "idx": 254,
  "target": 1,
  "vul": "static int get_int32_le(QEMUFile *f, void *pv, size_t size) \n { \n int32_t loaded; \n int32_t loaded; \n qemu_get_sbe32s(f, &loaded); \n if (loaded <= *cur) { \n *cur = loaded; \n return 0; \n } \n }",
  "no_vul": "static int get_int32_le(QEMUFile *f, void *pv, size_t size) \n { \n int32_t loaded; \n int32_t loaded; \n qemu_get_sbe32s(f, &loaded); \n if (loaded >= 0 && loaded <= *cur) { \n *cur = loaded; \n return 0; \n } \n }",
  "cwe": "CWE-119",
  "codeline": "if (loaded <= *cur) {"
}
{
  "idx": 255,
  "target": 1,
  "vul": "static int bdrv_check_request(BlockDriverState *bs, int64_t sector_num, \n int nb_sectors) \n { \n return bdrv_check_byte_request(bs, sector_num * BDRV_SECTOR_SIZE, \n nb_sectors * BDRV_SECTOR_SIZE); \n }",
  "no_vul": "static int bdrv_check_request(BlockDriverState *bs, int64_t sector_num, \n int nb_sectors) \n { \n if (nb_sectors > INT_MAX / BDRV_SECTOR_SIZE) { \n return -EIO; \n } \n return bdrv_check_byte_request(bs, sector_num * BDRV_SECTOR_SIZE, \n nb_sectors * BDRV_SECTOR_SIZE); \n }",
  "cwe": "CWE-190",
  "codeline": "return bdrv_check_byte_request(bs, sector_num * BDRV_SECTOR_SIZE, \n nb_sectors * BDRV_SECTOR_SIZE);"
}
{
  "idx": 256,
  "target": 1,
  "vul": "static int local_name_to_path(FsContext *ctx, V9fsPath *dir_path, \n const char *name, V9fsPath *target) \n { \n if (dir_path) { \n v9fs_path_sprintf(target, \"%s/%s\", dir_path->data, name); \n } else { \n v9fs_path_sprintf(target, \"%s\", name); \n } \n return 0; \n }",
  "no_vul": "static int local_name_to_path(FsContext *ctx, V9fsPath *dir_path, \n const char *name, V9fsPath *target) \n { \n if (dir_path) { \n v9fs_path_sprintf(target, \"%s/%s\", dir_path->data, name); \n } else if (strcmp(name, \"/\")) { \n v9fs_path_sprintf(target, \"%s\", name); \n } else { \n v9fs_path_sprintf(target, \"%s\", \".\"); \n } \n return 0; \n }",
  "cwe": "CWE-732",
  "codeline": "v9fs_path_sprintf(target, \"%s\", name);"
}
{
  "idx": 257,
  "target": 1,
  "vul": "static void check_pointer_type_change(Notifier *notifier, void *data) \n { \n VncState *vs = container_of(notifier, VncState, mouse_mode_notifier); \n int absolute = qemu_input_is_absolute(); \n if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE) && vs->absolute != absolute) { \n vnc_write_u8(vs, 0); \n vnc_write_u16(vs, 1); \n vnc_framebuffer_update(vs, absolute, 0, \n surface_width(vs->vd->ds), \n surface_height(vs->vd->ds), \n VNC_ENCODING_POINTER_TYPE_CHANGE); \n vnc_unlock_output(vs); \n vnc_flush(vs); \n vnc_unlock_output(vs); \n vnc_flush(vs); \n } \n vs->absolute = absolute; \n }",
  "no_vul": "static void check_pointer_type_change(Notifier *notifier, void *data) \n { \n VncState *vs = container_of(notifier, VncState, mouse_mode_notifier); \n int absolute = qemu_input_is_absolute(); \n if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE) && vs->absolute != absolute) { \n vnc_write_u8(vs, 0); \n vnc_write_u16(vs, 1); \n vnc_framebuffer_update(vs, absolute, 0, \n pixman_image_get_width(vs->vd->server), \n pixman_image_get_height(vs->vd->server), \n VNC_ENCODING_POINTER_TYPE_CHANGE); \n vnc_unlock_output(vs); \n vnc_flush(vs); \n vnc_unlock_output(vs); \n vnc_flush(vs); \n } \n vs->absolute = absolute; \n }",
  "cwe": "CWE-125",
  "codeline": "surface_width(vs->vd->ds)"
}
{
  "idx": 258,
  "target": 1,
  "vul": "matchCurrentInput( \n const InString *input, int pos, const widechar *passInstructions, int passIC) { \n int k; \n int kk = pos; \n for (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++) \n if (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++]) \n return 0; \n return 1; \n }",
  "no_vul": "matchCurrentInput( \n const InString *input, int pos, const widechar *passInstructions, int passIC) { \n int k; \n int kk = pos; \n for (k = passIC + 2; \n ((k < passIC + 2 + passInstructions[passIC + 1]) && (kk < input->length)); \n k++) \n if (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++]) \n return 0; \n return 1; \n }",
  "cwe": "CWE-125",
  "codeline": "for (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)"
}
{
  "idx": 259,
  "target": 1,
  "vul": "static void cliRefreshPrompt(void) { \n int len; \n if (config.eval_ldb) return; \n if (config.hostsocket != NULL) \n len = snprintf(config.prompt,sizeof(config.prompt),\"redis %s\", \n config.hostsocket); \n else \n len = anetFormatAddr(config.prompt, sizeof(config.prompt), \n config.hostip, config.hostport); \n if (config.dbnum != 0) \n len += snprintf(config.prompt+len,sizeof(config.prompt)-len,\"[%d]\", \n config.dbnum); \n snprintf(config.prompt+len,sizeof(config.prompt)-len,\"> \"); \n }",
  "no_vul": "static void cliRefreshPrompt(void) { \n if (config.eval_ldb) return; \n sds prompt = sdsempty(); \n if (config.hostsocket != NULL) { \n prompt = sdscatfmt(prompt,\"redis %s\",config.hostsocket); \n } else { \n char addr[256]; \n anetFormatAddr(addr, sizeof(addr), config.hostip, config.hostport); \n prompt = sdscatlen(prompt,addr,strlen(addr)); \n } \n if (config.dbnum != 0) \n prompt = sdscatfmt(prompt,\"[%i]\",config.dbnum); \n prompt = sdscatlen(prompt,\"> \",2); \n snprintf(config.prompt,sizeof(config.prompt),\"%s\",prompt); \n sdsfree(prompt); \n }",
  "cwe": "CWE-119",
  "codeline": "snprintf(config.prompt+len,sizeof(config.prompt)-len,\"> \");"
}
{
  "idx": 260,
  "target": 1,
  "vul": "static struct mobj *alloc_ta_mem(size_t size) \n { \n #ifdef CFG_PAGED_USER_TA \n return mobj_paged_alloc(size); \n #else \n struct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr); \n if (mobj) \n memset(mobj_get_va(mobj, 0), 0, size); \n return mobj; \n #endif \n }",
  "no_vul": "static struct mobj *alloc_ta_mem(size_t size) \n { \n #ifdef CFG_PAGED_USER_TA \n return mobj_paged_alloc(size); \n #else \n struct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr); \n if (mobj) { \n size_t granularity = BIT(tee_mm_sec_ddr.shift); \n memset(mobj_get_va(mobj, 0), 0, ROUNDUP(size, granularity)); \n } \n return mobj; \n #endif \n }",
  "cwe": "CWE-189",
  "codeline": "memset(mobj_get_va(mobj, 0), 0, size);"
}
{
  "idx": 261,
  "target": 1,
  "vul": "static TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem, \n struct param_mem *mem) \n { \n uint64_t shm_ref = READ_ONCE(rmem->shm_ref); \n mem->mobj = mobj_reg_shm_get_by_cookie(shm_ref); \n if (!mem->mobj) \n return TEE_ERROR_BAD_PARAMETERS; \n mem->offs = READ_ONCE(rmem->offs); \n mem->size = READ_ONCE(rmem->size); \n return TEE_SUCCESS; \n }",
  "no_vul": "static TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem, \n struct param_mem *mem) \n { \n size_t req_size = 0; \n uint64_t shm_ref = READ_ONCE(rmem->shm_ref); \n mem->mobj = mobj_reg_shm_get_by_cookie(shm_ref); \n if (!mem->mobj) \n return TEE_ERROR_BAD_PARAMETERS; \n mem->offs = READ_ONCE(rmem->offs); \n mem->size = READ_ONCE(rmem->size); \n if (ADD_OVERFLOW(mem->offs, mem->size, &req_size) || \n mem->mobj->size < req_size) \n return TEE_ERROR_SECURITY; \n return TEE_SUCCESS; \n }",
  "cwe": "CWE-119",
  "codeline": "mem->size = READ_ONCE(rmem->size);"
}
{
  "idx": 262,
  "target": 1,
  "vul": "void pin_remove(struct fs_pin *pin) \n { \n spin_lock(&pin_lock); \n hlist_del(&pin->m_list); \n hlist_del(&pin->s_list); \n spin_unlock(&pin_lock); \n spin_lock_irq(&pin->wait.lock); \n pin->done = 1; \n wake_up_locked(&pin->wait); \n spin_unlock_irq(&pin->wait.lock); \n }",
  "no_vul": "void pin_remove(struct fs_pin *pin) \n { \n spin_lock(&pin_lock); \n hlist_del_init(&pin->m_list); \n hlist_del_init(&pin->s_list); \n spin_unlock(&pin_lock); \n spin_lock_irq(&pin->wait.lock); \n pin->done = 1; \n wake_up_locked(&pin->wait); \n spin_unlock_irq(&pin->wait.lock); \n }",
  "cwe": "CWE-703",
  "codeline": "hlist_del(&pin->m_list); \nhlist_del(&pin->s_list);"
}
{
  "idx": 263,
  "target": 1,
  "vul": "static int er_supported(ERContext *s) \n { \n if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice || \n !s->cur_pic.f || \n s->cur_pic.field_picture || \n s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO \n ) \n return 0; \n return 1; \n }",
  "no_vul": "static int er_supported(ERContext *s) \n { \n if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice || \n !s->cur_pic.f || \n s->cur_pic.field_picture \n ) \n return 0; \n return 1; \n }",
  "cwe": "CWE-617",
  "codeline": "s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO"
}
{
  "idx": 264,
  "target": 1,
  "vul": "static bool blit_is_unsafe(struct CirrusVGAState *s) \n { \n assert(s->cirrus_blt_width > 0); \n assert(s->cirrus_blt_height > 0); \n if (blit_region_is_unsafe(s, s->cirrus_blt_dstpitch, \n s->cirrus_blt_dstaddr & s->cirrus_addr_mask)) { \n return true; \n } \n if (blit_region_is_unsafe(s, s->cirrus_blt_srcpitch, \n s->cirrus_blt_srcaddr & s->cirrus_addr_mask)) { \n return true; \n } \n return false; \n }",
  "no_vul": "static bool blit_is_unsafe(struct CirrusVGAState *s) \n { \n assert(s->cirrus_blt_width > 0); \n assert(s->cirrus_blt_height > 0); \n if (s->cirrus_blt_width > CIRRUS_BLTBUFSIZE) { \n return true; \n } \n if (blit_region_is_unsafe(s, s->cirrus_blt_dstpitch, \n s->cirrus_blt_dstaddr & s->cirrus_addr_mask)) { \n return true; \n } \n return false; \n }",
  "cwe": "CWE-119",
  "codeline": "if (blit_region_is_unsafe(s, s->cirrus_blt_srcpitch, \n s->cirrus_blt_srcaddr & s->cirrus_addr_mask)) {"
}
{
  "idx": 265,
  "target": 1,
  "vul": "*/ \n int sock_queue_err_skb(struct sock *sk, struct sk_buff *skb) \n { \n if (atomic_read(&sk->sk_rmem_alloc) + skb->truesize >= \n (unsigned int)sk->sk_rcvbuf) \n return -ENOMEM; \n skb_orphan(skb); \n skb->sk = sk; \n skb->destructor = sock_rmem_free; \n atomic_add(skb->truesize, &sk->sk_rmem_alloc); \n skb_dst_force(skb); \n skb_queue_tail(&sk->sk_error_queue, skb); \n if (!sock_flag(sk, SOCK_DEAD)) \n sk->sk_data_ready(sk); \n return 0;",
  "no_vul": "int sock_queue_err_skb(struct sock *sk, struct sk_buff *skb) \n { \n if (atomic_read(&sk->sk_rmem_alloc) + skb->truesize >= \n (unsigned int)sk->sk_rcvbuf) \n return -ENOMEM; \n skb_orphan(skb); \n skb->sk = sk; \n skb->destructor = sock_rmem_free; \n atomic_add(skb->truesize, &sk->sk_rmem_alloc); \n skb_set_err_queue(skb); \n skb_dst_force(skb); \n skb_queue_tail(&sk->sk_error_queue, skb); \n if (!sock_flag(sk, SOCK_DEAD)) \n sk->sk_data_ready(sk); \n return 0; \n }",
  "cwe": "CWE-125",
  "codeline": "skb_queue_tail(&sk->sk_error_queue, skb);"
}
{
  "idx": 266,
  "target": 1,
  "vul": "static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) \n { \n va_list va; \n char *message = NULL; \n va_start(va, format); \n zend_vspprintf(&message, 0, format, va); \n if (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) { \n zend_throw_error(exception_ce, message); \n } else { \n zend_error(E_ERROR, \"%s\", message); \n } \n efree(message); \n va_end(va); \n }",
  "no_vul": "static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) \n { \n va_list va; \n char *message = NULL; \n va_start(va, format); \n zend_vspprintf(&message, 0, format, va); \n if (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) { \n zend_throw_error(exception_ce, \"%s\", message); \n } else { \n zend_error(E_ERROR, \"%s\", message); \n } \n efree(message); \n va_end(va); \n }",
  "cwe": "CWE-134",
  "codeline": "zend_throw_error(exception_ce, message);"
}
{
  "idx": 267,
  "target": 1,
  "vul": "void vrend_renderer_context_create_internal(uint32_t handle, uint32_t nlen, \n const char *debug_name) \n { \n struct vrend_decode_ctx *dctx; \n if (handle >= VREND_MAX_CTX) \n return; \n dctx = malloc(sizeof(struct vrend_decode_ctx)); \n if (!dctx) \n return; \n dctx->grctx = vrend_create_context(handle, nlen, debug_name); \n if (!dctx->grctx) { \n free(dctx); \n return; \n } \n dctx->ds = &dctx->ids; \n dec_ctx[handle] = dctx; \n }",
  "no_vul": "void vrend_renderer_context_create_internal(uint32_t handle, uint32_t nlen, \n const char *debug_name) \n { \n struct vrend_decode_ctx *dctx; \n if (handle >= VREND_MAX_CTX) \n return; \n dctx = dec_ctx[handle]; \n if (dctx) \n return; \n dctx = malloc(sizeof(struct vrend_decode_ctx)); \n if (!dctx) \n return; \n return; \n }",
  "cwe": "CWE-399",
  "codeline": "dec_ctx[handle] = dctx;"
}
{
  "idx": 268,
  "target": 1,
  "vul": "static Status ValidateSavedTensors(const GraphDef& graph_def) { \n for (const auto& node : graph_def.node()) { \n TF_RETURN_IF_ERROR(ValidateNode(node)); \n } \n if (graph_def.has_library()) { \n const FunctionDefLibrary& library = graph_def.library(); \n for (const auto& function : library.function()) { \n for (const auto& node : function.node_def()) { \n TF_RETURN_IF_ERROR(ValidateNode(node)); \n } \n } \n } \n return Status::OK(); \n }",
  "no_vul": "static Status ValidateSavedTensors(const GraphDef& graph_def) { \n for (const auto& node : graph_def.node()) { \n TF_RETURN_IF_ERROR(ValidateNode(node)); \n } \n if (graph_def.has_library()) { \n const FunctionDefLibrary& library = graph_def.library(); \n for (const auto& function : library.function()) { \n for (const auto& node : function.node_def()) { \n TF_RETURN_IF_ERROR(ValidateNode(node)); \n } \n TF_RETURN_IF_ERROR(ValidateFunctionNotRecursive(function)); \n } \n } \n return Status::OK(); \n }",
  "cwe": "CWE-400",
  "codeline": "TF_RETURN_IF_ERROR(ValidateNode(node));"
}
{
  "idx": 269,
  "target": 1,
  "vul": "void Compute(OpKernelContext* context) override { \n const float min_input = context->input(1).flat<float>()(0); \n const float max_input = context->input(2).flat<float>()(0); \n MaxPoolingOp<Device, T>::Compute(context); \n Tensor* output_min = nullptr; \n OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min)); \n output_min->flat<float>()(0) = min_input; \n Tensor* output_max = nullptr; \n OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max)); \n output_max->flat<float>()(0) = max_input; \n }",
  "no_vul": "void Compute(OpKernelContext* context) override { \n auto min_input_tensor = context->input(1); \n auto max_input_tensor = context->input(2); \n OP_REQUIRES( \n context, min_input_tensor.NumElements() == 1, \n errors::InvalidArgument( \n \"min_input must be a scalar float value, got tensor with shape \", \n min_input_tensor.shape())); \n OP_REQUIRES( \n context, max_input_tensor.NumElements() == 1, \n errors::InvalidArgument( \n \"max_input must be a scalar float value, got tensor with shape \", \n max_input_tensor.shape())); \n const float min_input = context->input(1).flat<float>()(0); \n const float max_input = context->input(2).flat<float>()(0); \n MaxPoolingOp<Device, T>::Compute(context); \n Tensor* output_min = nullptr; \n OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min)); \n output_min->flat<float>()(0) = min_input; \n Tensor* output_max = nullptr; \n OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max)); \n output_max->flat<float>()(0) = max_input; \n }",
  "cwe": "CWE-476",
  "codeline": "const float min_input = context->input(1).flat<float>()(0); \nconst float max_input = context->input(2).flat<float>()(0);"
}
{
  "idx": 270,
  "target": 1,
  "vul": "AP4_DataAtom::AP4_DataAtom(AP4_UI32 size, AP4_ByteStream& stream) : \n AP4_Atom(AP4_ATOM_TYPE_DATA, size) \n { \n if (size < AP4_ATOM_HEADER_SIZE+8) return; \n AP4_UI32 i; \n stream.ReadUI32(i); m_DataType = (DataType)i; \n stream.ReadUI32(i); m_DataLang = (DataLang)i; \n AP4_Position data_offset; \n stream.Tell(data_offset); \n AP4_Size data_size = size-AP4_ATOM_HEADER_SIZE-8; \n m_Source = new AP4_SubStream(stream, data_offset, data_size); \n }",
  "no_vul": "AP4_DataAtom::AP4_DataAtom(AP4_UI32 size, AP4_ByteStream& stream) : \n AP4_Atom(AP4_ATOM_TYPE_DATA, size), \n m_Source(NULL) \n { \n if (size < AP4_ATOM_HEADER_SIZE+8) return; \n AP4_UI32 i; \n stream.ReadUI32(i); m_DataType = (DataType)i; \n stream.ReadUI32(i); m_DataLang = (DataLang)i; \n AP4_Position data_offset; \n stream.Tell(data_offset); \n AP4_Size data_size = size-AP4_ATOM_HEADER_SIZE-8; \n m_Source = new AP4_SubStream(stream, data_offset, data_size); \n }",
  "cwe": "CWE-476",
  "codeline": "m_Source = new AP4_SubStream(stream, data_offset, data_size);"
}
{
  "idx": 271,
  "target": 1,
  "vul": "void FastCGITransport::onHeader(std::unique_ptr<folly::IOBuf> key_chain, \n std::unique_ptr<folly::IOBuf> value_chain) { \n Cursor keyCur(key_chain.get()); \n auto key = keyCur.readFixedString(key_chain->computeChainDataLength()); \n Cursor valCur(value_chain.get()); \n auto value = valCur.readFixedString(value_chain->computeChainDataLength()); \n m_requestParams[key] = value; \n }",
  "no_vul": "void FastCGITransport::onHeader(std::unique_ptr<folly::IOBuf> key_chain, \n std::unique_ptr<folly::IOBuf> value_chain) { \n Cursor keyCur(key_chain.get()); \n auto key = keyCur.readFixedString(key_chain->computeChainDataLength()); \n if (strcasecmp(key.c_str(), \"HTTP_PROXY\") == 0) return; \n Cursor valCur(value_chain.get()); \n auto value = valCur.readFixedString(value_chain->computeChainDataLength()); \n m_requestParams[key] = value; \n }",
  "cwe": "CWE-665",
  "codeline": "m_requestParams[key] = value;"
}
{
  "idx": 272,
  "target": 1,
  "vul": "explicit HashContext(const HashContext* ctx) { \n assert(ctx->ops); \n assert(ctx->ops->context_size >= 0); \n ops = ctx->ops; \n context = malloc(ops->context_size); \n ops->hash_copy(context, ctx->context); \n options = ctx->options; \n key = ctx->key ? strdup(ctx->key) : nullptr; \n }",
  "no_vul": "explicit HashContext(const HashContext* ctx) { \n assert(ctx->ops); \n assert(ctx->ops->context_size >= 0); \n ops = ctx->ops; \n context = malloc(ops->context_size); \n ops->hash_copy(context, ctx->context); \n options = ctx->options; \n if (ctx->key) { \n key = static_cast<char*>(malloc(ops->block_size)); \n memcpy(key, ctx->key, ops->block_size); \n } else { \n key = nullptr; \n } \n }",
  "cwe": "CWE-200",
  "codeline": "key = ctx->key ? strdup(ctx->key) : nullptr;"
}
{
  "idx": 273,
  "target": 1,
  "vul": "static inline void get_page(struct page *page) \n { \n page = compound_head(page); \n VM_BUG_ON_PAGE(page_ref_count(page) <= 0, page); \n page_ref_inc(page); \n }",
  "no_vul": "static inline void get_page(struct page *page) \n { \n page = compound_head(page); \n VM_BUG_ON_PAGE(page_ref_zero_or_close_to_overflow(page), page); \n page_ref_inc(page); \n }",
  "cwe": "CWE-416",
  "codeline": "VM_BUG_ON_PAGE(page_ref_count(page) <= 0, page);"
}
{
  "idx": 274,
  "target": 1,
  "vul": "xmlNodePtr SimpleXMLElement_exportNode(const Object& sxe) { \n assert(sxe->instanceof(SimpleXMLElement_classof())); \n auto data = Native::data<SimpleXMLElement>(sxe.get()); \n return php_sxe_get_first_node(data, data->nodep()); \n }",
  "no_vul": "xmlNodePtr SimpleXMLElement_exportNode(const Object& sxe) { \n if (!sxe->instanceof(SimpleXMLElement_classof())) return nullptr; \n auto data = Native::data<SimpleXMLElement>(sxe.get()); \n return php_sxe_get_first_node(data, data->nodep()); \n }",
  "cwe": "CWE-345",
  "codeline": "assert(sxe->instanceof(SimpleXMLElement_classof()));"
}
{
  "idx": 275,
  "target": 1,
  "vul": "static void do_change_user(FILE *fin, FILE *fout) { \n std::string uname; \n lwp_read(fin, uname); \n if (uname.length() > 0) { \n struct passwd *pw = getpwnam(uname.c_str()); \n if (pw) { \n if (pw->pw_gid) { \n setgid(pw->pw_gid); \n } \n if (pw->pw_uid) { \n setuid(pw->pw_uid); \n } \n } \n } \n }",
  "no_vul": "static void do_change_user(FILE *fin, FILE *fout) { \n std::string uname; \n lwp_read(fin, uname); \n if (uname.length() > 0) { \n struct passwd *pw = getpwnam(uname.c_str()); \n if (pw) { \n if (pw->pw_gid) { \n initgroups(pw->pw_name, pw->pw_gid); \n setgid(pw->pw_gid); \n } \n if (pw->pw_uid) { \n setuid(pw->pw_uid); \n } \n } \n } \n }",
  "cwe": "CWE-264",
  "codeline": "if (pw->pw_gid) { \n setgid(pw->pw_gid); \n }"
}
{
  "idx": 276,
  "target": 1,
  "vul": "int64_t OutputFile::readImpl(char* , int64_t ) { \n raise_warning(\"cannot read from a php://output stream\"); \n return -1; \n }",
  "no_vul": "int64_t OutputFile::readImpl(char* , int64_t ) { \n raise_warning(\"cannot read from a php://output stream\"); \n return 0; \n }",
  "cwe": "CWE-125",
  "codeline": "return -1;"
}
{
  "idx": 277,
  "target": 1,
  "vul": "SilenceMessage(const std::string& mask, const std::string& flags) \n : ClientProtocol::Message(\"SILENCE\") \n { \n PushParam(mask); \n PushParamRef(flags); \n }",
  "no_vul": "SilenceMessage(const std::string& mask, const std::string& flags) \n : ClientProtocol::Message(\"SILENCE\") \n { \n PushParam(mask); \n PushParam(flags); \n }",
  "cwe": "CWE-416",
  "codeline": "PushParamRef(flags);"
}
{
  "idx": 278,
  "target": 1,
  "vul": "void Compute(OpKernelContext* context) override { \n ReshapeSparseTensor<Device>(context, context->input(0), context->input(1), \n context->input(2), 0 , \n 1 ); \n }",
  "no_vul": "void Compute(OpKernelContext* context) override { \n const Tensor& input_indices_in = context->input(0); \n const Tensor& input_shape_in = context->input(1); \n OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices_in.shape()), \n errors::InvalidArgument(\"Input must be a matrix.\")); \n OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape_in.shape()), \n errors::InvalidArgument(\"Input shape must be a vector.\")); \n OP_REQUIRES(context, \n input_indices_in.dim_size(1) == input_shape_in.dim_size(0), \n errors::InvalidArgument( \n \"Input tensor rank must match input shape length.\")); \n ReshapeSparseTensor<Device>(context, context->input(0), context->input(1), \n context->input(2), 0 , \n 1 ); \n }",
  "cwe": "CWE-369",
  "codeline": "ReshapeSparseTensor<Device>(context, context->input(0), context->input(1), \n context->input(2), 0 , \n 1 );"
}
{
  "idx": 279,
  "target": 1,
  "vul": "void pb_controller::play_file(const std::string& file) { \n std::string cmdline; \n std::string player = cfg->get_configvalue(\"player\"); \n if (player == \"\") \n return; \n cmdline.append(player); \n cmdline.append(\" \\\"\"); \n cmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\")); \n cmdline.append(\"\\\"\"); \n stfl::reset(); \n utils::run_interactively(cmdline, \"pb_controller::play_file\"); \n }",
  "no_vul": "void pb_controller::play_file(const std::string& file) { \n std::string cmdline; \n std::string player = cfg->get_configvalue(\"player\"); \n if (player == \"\") \n return; \n cmdline.append(player); \n cmdline.append(\" '\"); \n cmdline.append(utils::replace_all(file,\"'\", \"%27\")); \n cmdline.append(\"'\"); \n stfl::reset(); \n utils::run_interactively(cmdline, \"pb_controller::play_file\"); \n }",
  "cwe": "CWE-78",
  "codeline": "cmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));"
}
{
  "idx": 280,
  "target": 1,
  "vul": "long WebPImage::getHeaderOffset(byte *data, long data_size, \n byte *header, long header_size) { \n long pos = -1; \n for (long i=0; i < data_size - header_size; i++) { \n if (memcmp(header, &data[i], header_size) == 0) { \n pos = i; \n break; \n } \n } \n return pos; \n }",
  "no_vul": "long WebPImage::getHeaderOffset(byte* data, long data_size, byte* header, long header_size) \n { \n if (data_size < header_size) { return -1; } \n long pos = -1; \n for (long i=0; i < data_size - header_size; i++) { \n if (memcmp(header, &data[i], header_size) == 0) { \n pos = i; \n break; \n } \n } \n return pos; \n }",
  "cwe": "CWE-190",
  "codeline": "for (long i=0; i < data_size - header_size; i++) {"
}
{
  "idx": 281,
  "target": 1,
  "vul": "void Compute(OpKernelContext* c) override { \n PartialTensorShape element_shape; \n OP_REQUIRES_OK(c, TensorShapeFromTensor(c->input(0), &element_shape)); \n int32 num_elements = c->input(1).scalar<int32>()(); \n TensorList output; \n output.element_shape = element_shape; \n output.element_dtype = element_dtype_; \n output.tensors().resize(num_elements, Tensor(DT_INVALID)); \n Tensor* result; \n AllocatorAttributes attr; \n attr.set_on_host(true); \n OP_REQUIRES_OK(c, c->allocate_output(0, TensorShape{}, &result, attr)); \n result->scalar<Variant>()() = std::move(output); \n }",
  "no_vul": "void Compute(OpKernelContext* c) override { \n PartialTensorShape element_shape; \n OP_REQUIRES_OK(c, TensorShapeFromTensor(c->input(0), &element_shape)); \n int32 num_elements = c->input(1).scalar<int32>()(); \n OP_REQUIRES(c, num_elements >= 0, \n errors::InvalidArgument(\"The num_elements to reserve must be a \" \n \"non negative number, but got \", \n num_elements)); \n TensorList output; \n output.element_shape = element_shape; \n output.element_dtype = element_dtype_; \n output.tensors().resize(num_elements, Tensor(DT_INVALID)); \n Tensor* result; \n AllocatorAttributes attr; \n attr.set_on_host(true); \n OP_REQUIRES_OK(c, c->allocate_output(0, TensorShape{}, &result, attr)); \n result->scalar<Variant>()() = std::move(output); \n }",
  "cwe": "CWE-369",
  "codeline": "int32 num_elements = c->input(1).scalar<int32>()();"
}
{
  "idx": 282,
  "target": 1,
  "vul": "static void credential_write_item(FILE *fp, const char *key, const char *value) \n { \n if (!value) \n return; \n fprintf(fp, \"%s=%s\\n\", key, value); \n }",
  "no_vul": "static void credential_write_item(FILE *fp, const char *key, const char *value) \n { \n if (!value) \n return; \n if (strchr(value, '\\n')) \n die(\"credential value for %s contains newline\", key); \n fprintf(fp, \"%s=%s\\n\", key, value); \n }",
  "cwe": "CWE-61",
  "codeline": "fprintf(fp, \"%s=%s\\n\", key, value);"
}
{
  "idx": 283,
  "target": 1,
  "vul": "int linenoiseHistorySave(const char* filename) { \n FILE* fp = fopen(filename, \"wt\"); \n if (fp == NULL) { \n return -1; \n } \n for (int j = 0; j < historyLen; ++j) { \n if (history[j][0] != '\\0') { \n fprintf(fp, \"%s\\n\", history[j]); \n } \n } \n fclose(fp); \n return 0; \n }",
  "no_vul": "int linenoiseHistorySave(const char* filename) { \n FILE* fp; \n #if _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _POSIX_SOURCE \n int fd = open(filename, O_CREAT, S_IRUSR | S_IWUSR); \n if (fd == -1) { \n return -1; \n } \n fp = fdopen(fd, \"wt\"); \n #else \n fp = fopen(filename, \"wt\"); \n #endif \n if (fp == NULL) { \n return -1; \n } \n for (int j = 0; j < historyLen; ++j) { \n if (history[j][0] != '\\0') { \n fprintf(fp, \"%s\\n\", history[j]); \n } \n } \n fclose(fp); \n return 0; \n }",
  "cwe": "CWE-200",
  "codeline": "FILE* fp = fopen(filename, \"wt\");"
}
{
  "idx": 284,
  "target": 1,
  "vul": "void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id) \n { \n streamIterator si; \n int64_t numfields; \n streamIteratorStart(&si,s,NULL,NULL,!first); \n si.skip_tombstones = skip_tombstones; \n int found = streamIteratorGetID(&si,edge_id,&numfields); \n if (!found) { \n streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX}; \n *edge_id = first ? max_id : min_id; \n } \n }",
  "no_vul": "void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id) \n { \n streamIterator si; \n int64_t numfields; \n streamIteratorStart(&si,s,NULL,NULL,!first); \n si.skip_tombstones = skip_tombstones; \n int found = streamIteratorGetID(&si,edge_id,&numfields); \n if (!found) { \n streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX}; \n *edge_id = first ? max_id : min_id; \n } \n streamIteratorStop(&si); \n }",
  "cwe": "CWE-703",
  "codeline": "streamIteratorStop(&si);"
}
{
  "idx": 285,
  "target": 1,
  "vul": "ssize_t enc_untrusted_read(int fd, void *buf, size_t count) { \n return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall( \n asylo::system_call::kSYS_read, fd, buf, count)); \n }",
  "no_vul": "ssize_t enc_untrusted_read(int fd, void *buf, size_t count) { \n ssize_t ret = static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall( \n asylo::system_call::kSYS_read, fd, buf, count)); \n if (ret != -1 && ret > count) { \n ::asylo::primitives::TrustedPrimitives::BestEffortAbort( \n \"enc_untrusted_read: read result exceeds requested\"); \n } \n return ret; \n }",
  "cwe": "CWE-125",
  "codeline": "return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall( \n asylo::system_call::kSYS_read, fd, buf, count));"
}
{
  "idx": 286,
  "target": 1,
  "vul": "static int zr364xx_vidioc_querycap(struct file *file, void *priv, \n struct v4l2_capability *cap) \n { \n struct zr364xx_camera *cam = video_drvdata(file); \n strscpy(cap->driver, DRIVER_DESC, sizeof(cap->driver)); \n strscpy(cap->card, cam->udev->product, sizeof(cap->card)); \n strscpy(cap->bus_info, dev_name(&cam->udev->dev), \n sizeof(cap->bus_info)); \n cap->device_caps = V4L2_CAP_VIDEO_CAPTURE | \n V4L2_CAP_READWRITE | \n V4L2_CAP_STREAMING; \n cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS; \n return 0; \n }",
  "no_vul": "static int zr364xx_vidioc_querycap(struct file *file, void *priv, \n struct v4l2_capability *cap) \n { \n struct zr364xx_camera *cam = video_drvdata(file); \n strscpy(cap->driver, DRIVER_DESC, sizeof(cap->driver)); \n if (cam->udev->product) \n strscpy(cap->card, cam->udev->product, sizeof(cap->card)); \n strscpy(cap->bus_info, dev_name(&cam->udev->dev), \n sizeof(cap->bus_info)); \n cap->device_caps = V4L2_CAP_VIDEO_CAPTURE | \n V4L2_CAP_READWRITE | \n V4L2_CAP_STREAMING; \n cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS; \n return 0; \n }",
  "cwe": "CWE-476",
  "codeline": "strscpy(cap->card, cam->udev->product, sizeof(cap->card));"
}
{
  "idx": 287,
  "target": 1,
  "vul": "int main() \n { \n initialize_environment(); \n test_format_wrong_size(); \n test_blit_info_format_check(); \n test_blit_info_format_check_null_format(); \n test_format_is_plain_nullptr_deref_trigger(); \n test_format_util_format_is_rgb_nullptr_deref_trigger_illegal_resource(); \n test_format_util_format_is_rgb_nullptr_deref_trigger(); \n test_double_free_in_vrend_renderer_blit_int_trigger_invalid_formats(); \n test_double_free_in_vrend_renderer_blit_int_trigger(); \n test_format_is_has_alpha_nullptr_deref_trigger_original(); \n test_format_is_has_alpha_nullptr_deref_trigger_legal_resource(); \n test_heap_overflow_vrend_renderer_transfer_write_iov(); \n virgl_renderer_context_destroy(ctx_id); \n virgl_renderer_cleanup(&cookie); \n virgl_egl_destroy(test_egl); \n return 0; \n }",
  "no_vul": "int main() \n { \n initialize_environment(); \n test_format_wrong_size(); \n test_blit_info_format_check(); \n test_blit_info_format_check_null_format(); \n test_format_is_plain_nullptr_deref_trigger(); \n test_format_util_format_is_rgb_nullptr_deref_trigger_illegal_resource(); \n test_format_util_format_is_rgb_nullptr_deref_trigger(); \n test_double_free_in_vrend_renderer_blit_int_trigger_invalid_formats(); \n test_double_free_in_vrend_renderer_blit_int_trigger(); \n test_format_is_has_alpha_nullptr_deref_trigger_original(); \n test_format_is_has_alpha_nullptr_deref_trigger_legal_resource(); \n test_heap_overflow_vrend_renderer_transfer_write_iov(); \n test_heap_overflow_vrend_renderer_transfer_write_iov_compressed_tex(); \n virgl_renderer_context_destroy(ctx_id); \n virgl_renderer_cleanup(&cookie); \n virgl_egl_destroy(test_egl); \n return 0; \n }",
  "cwe": "CWE-787",
  "codeline": "test_heap_overflow_vrend_renderer_transfer_write_iov();"
}
{
  "idx": 288,
  "target": 1,
  "vul": "int jas_stream_printf(jas_stream_t *stream, const char *fmt, ...) \n { \n va_list ap; \n char buf[4096]; \n int ret; \n va_start(ap, fmt); \n ret = vsprintf(buf, fmt, ap); \n jas_stream_puts(stream, buf); \n va_end(ap); \n return ret; \n }",
  "no_vul": "int jas_stream_printf(jas_stream_t *stream, const char *fmt, ...) \n { \n va_list ap; \n char buf[4096]; \n int ret; \n va_start(ap, fmt); \n ret = vsnprintf(buf, sizeof buf, fmt, ap); \n jas_stream_puts(stream, buf); \n va_end(ap); \n return ret; \n }",
  "cwe": "CWE-119",
  "codeline": "ret = vsprintf(buf, fmt, ap);"
}
{
  "idx": 289,
  "target": 1,
  "vul": "bool format_go_output(const string& file_path) { \n const string command = \"gofmt -w \" + file_path; \n if (system(command.c_str()) == 0) { \n return true; \n } \n fprintf(stderr, \"WARNING - Running '%s' failed.\\n\", command.c_str()); \n return false; \n }",
  "no_vul": "bool format_go_output(const string& file_path) { \n (void) file_path; \n return false; \n }",
  "cwe": "CWE-77",
  "codeline": "const string command = \"gofmt -w \" + file_path;"
}
{
  "idx": 290,
  "target": 1,
  "vul": "static void __dvb_frontend_free(struct dvb_frontend *fe) \n { \n struct dvb_frontend_private *fepriv = fe->frontend_priv; \n if (fepriv) \n dvb_free_device(fepriv->dvbdev); \n dvb_frontend_invoke_release(fe, fe->ops.release); \n if (fepriv) \n kfree(fepriv); \n }",
  "no_vul": "static void __dvb_frontend_free(struct dvb_frontend *fe) \n { \n struct dvb_frontend_private *fepriv = fe->frontend_priv; \n if (fepriv) \n dvb_free_device(fepriv->dvbdev); \n dvb_frontend_invoke_release(fe, fe->ops.release); \n kfree(fepriv); \n }",
  "cwe": "CWE-416",
  "codeline": "if (fepriv) \n kfree(fepriv);"
}
{
  "idx": 291,
  "target": 1,
  "vul": "static __inline__ void scm_set_cred(struct scm_cookie *scm, \n struct pid *pid, const struct cred *cred) \n { \n scm->pid = get_pid(pid); \n scm->cred = cred ? get_cred(cred) : NULL; \n scm->creds.pid = pid_vnr(pid); \n scm->creds.uid = cred ? cred->euid : INVALID_UID; \n scm->creds.gid = cred ? cred->egid : INVALID_GID; \n }",
  "no_vul": "static __inline__ void scm_set_cred(struct scm_cookie *scm, \n struct pid *pid, const struct cred *cred) \n { \n scm->pid = get_pid(pid); \n scm->cred = cred ? get_cred(cred) : NULL; \n scm->creds.pid = pid_vnr(pid); \n scm->creds.uid = cred ? cred->uid : INVALID_UID; \n scm->creds.gid = cred ? cred->gid : INVALID_GID; \n }",
  "cwe": "CWE-284",
  "codeline": "scm->creds.uid = cred ? cred->euid : INVALID_UID; \nscm->creds.gid = cred ? cred->egid : INVALID_GID;"
}
{
  "idx": 292,
  "target": 1,
  "vul": "BOOL security_fips_decrypt(BYTE* data, size_t length, rdpRdp* rdp) \n { \n size_t olen; \n if (!winpr_Cipher_Update(rdp->fips_decrypt, data, length, data, &olen)) \n return FALSE; \n return TRUE; \n }",
  "no_vul": "BOOL security_fips_decrypt(BYTE* data, size_t length, rdpRdp* rdp) \n { \n size_t olen; \n if (!rdp || !rdp->fips_decrypt) \n return FALSE; \n if (!winpr_Cipher_Update(rdp->fips_decrypt, data, length, data, &olen)) \n return FALSE; \n return TRUE; \n }",
  "cwe": "CWE-787",
  "codeline": "if (!winpr_Cipher_Update(rdp->fips_decrypt, data, length, data, &olen))"
}
{
  "idx": 293,
  "target": 1,
  "vul": "bool ZipCommon::isValidPath(const std::string& path) \n { \n if (path == \"..\") \n return false; \n if (path.compare(0, 3, \"../\") == 0) \n return false; \n if (path.compare(0, 3, \"..\\\\\") == 0) \n return false; \n if (path.find(\"/..\") != std::string::npos) \n return false; \n if (path.find(\"\\\\..\") != std::string::npos) \n return false; \n return true; \n }",
  "no_vul": "bool ZipCommon::isValidPath(const std::string& path) \n { \n try \n { \n if (Path(path, Path::PATH_UNIX).isAbsolute() || Path(path, Path::PATH_WINDOWS).isAbsolute()) \n return false; \n } \n catch (...) \n { \n return false; \n } \n if (path == \"..\") \n return false; \n if ((path.size() >= 3) && path.compare(0, 3, \"../\") == 0) \n return false; \n if ((path.size() >= 3) && path.compare(0, 3, \"..\\\\\") == 0) \n return false; \n if (path.find(\"/../\") != std::string::npos) \n return false; \n if (path.find(\"\\\\..\\\\\") != std::string::npos) \n return false; \n if (path.find(\"/..\\\\\") != std::string::npos) \n return false; \n if (path.find(\"\\\\../\") != std::string::npos) \n return false; \n if ((path.size() >= 2) && path.compare(0, 2, \"~/\") == 0) \n return false; \n return true; \n }",
  "cwe": "CWE-22",
  "codeline": "if (path.find(\"/..\") != std::string::npos) \n return false; \n if (path.find(\"\\\\..\") != std::string::npos) \n return false;"
}
{
  "idx": 294,
  "target": 1,
  "vul": "inline bool SegmentReader::containsInterval(const void* from, const void* to) { \n return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to && \n readLimiter->canRead( \n intervalLength(reinterpret_cast<const byte*>(from), \n reinterpret_cast<const byte*>(to), \n MAX_SEGMENT_WORDS * BYTES_PER_WORD) \n / BYTES_PER_WORD, \n arena); \n }",
  "no_vul": "inline bool SegmentReader::containsInterval(const void* from, const void* to) { \n uintptr_t start = reinterpret_cast<uintptr_t>(from) - reinterpret_cast<uintptr_t>(ptr.begin()); \n uintptr_t end = reinterpret_cast<uintptr_t>(to) - reinterpret_cast<uintptr_t>(ptr.begin()); \n uintptr_t bound = ptr.size() * sizeof(capnp::word); \n return start <= bound && end <= bound && start <= end && \n readLimiter->canRead( \n intervalLength(reinterpret_cast<const byte*>(from), \n reinterpret_cast<const byte*>(to), \n MAX_SEGMENT_WORDS * BYTES_PER_WORD) \n / BYTES_PER_WORD, \n arena); \n }",
  "cwe": "CWE-20",
  "codeline": "return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to && \n readLimiter->canRead( \n intervalLength(reinterpret_cast<const byte*>(from), \n reinterpret_cast<const byte*>(to), \n MAX_SEGMENT_WORDS * BYTES_PER_WORD) \n / BYTES_PER_WORD, \n arena);"
}
{
  "idx": 295,
  "target": 1,
  "vul": "plugin_init (Ekiga::KickStart& kickstart) \n { \n #ifdef DEBUG \n gchar* path = g_build_path (G_DIR_SEPARATOR_S, \n g_get_tmp_dir (), \"ekiga_debug_plugins\", NULL); \n plugin_parse_directory (kickstart, path); \n g_free (path); \n #else \n plugin_parse_directory (kickstart, \n EKIGA_PLUGIN_DIR); \n #endif \n }",
  "no_vul": "plugin_init (Ekiga::KickStart& kickstart) \n { \n #if DEBUG \n gchar* path = g_build_path (G_DIR_SEPARATOR_S, \n g_get_tmp_dir (), \"ekiga_debug_plugins\", NULL); \n plugin_parse_directory (kickstart, path); \n g_free (path); \n #else \n plugin_parse_directory (kickstart, \n EKIGA_PLUGIN_DIR); \n #endif \n }",
  "cwe": "CWE-94",
  "codeline": "plugin_parse_directory (kickstart, path);"
}
{
  "idx": 296,
  "target": 1,
  "vul": "static MagickBooleanType WriteMSLImage(const ImageInfo *image_info,Image *image, \n ExceptionInfo *exception) \n { \n Image \n *msl_image; \n assert(image_info != (const ImageInfo *) NULL); \n assert(image_info->signature == MagickCoreSignature); \n assert(image != (Image *) NULL); \n assert(image->signature == MagickCoreSignature); \n if (image->debug != MagickFalse) \n (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n msl_image=CloneImage(image,0,0,MagickTrue,exception); \n return(ProcessMSLScript(image_info,&msl_image,exception)); \n }",
  "no_vul": "static MagickBooleanType WriteMSLImage(const ImageInfo *image_info,Image *image, \n ExceptionInfo *exception) \n { \n Image \n *msl_image; \n MagickBooleanType \n status; \n assert(image_info != (const ImageInfo *) NULL); \n assert(image_info->signature == MagickCoreSignature); \n assert(image != (Image *) NULL); \n assert(image->signature == MagickCoreSignature); \n if (image->debug != MagickFalse) \n (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n msl_image=CloneImage(image,0,0,MagickTrue,exception); \n status=ProcessMSLScript(image_info,&msl_image,exception); \n msl_image=DestroyImageList(msl_image); \n return(status); \n }",
  "cwe": "CWE-772",
  "codeline": "msl_image=CloneImage(image,0,0,MagickTrue,exception);"
}
{
  "idx": 297,
  "target": 1,
  "vul": "static void adu_disconnect(struct usb_interface *interface) \n { \n struct adu_device *dev; \n dev = usb_get_intfdata(interface); \n mutex_lock(&dev->mtx); \n dev->udev = NULL; \n usb_deregister_dev(interface, &adu_class); \n mutex_unlock(&dev->mtx); \n mutex_lock(&adutux_mutex); \n usb_set_intfdata(interface, NULL); \n if (!dev->open_count) \n adu_delete(dev); \n mutex_unlock(&adutux_mutex); \n }",
  "no_vul": "static void adu_disconnect(struct usb_interface *interface) \n { \n struct adu_device *dev; \n dev = usb_get_intfdata(interface); \n usb_deregister_dev(interface, &adu_class); \n mutex_lock(&adutux_mutex); \n usb_set_intfdata(interface, NULL); \n mutex_lock(&dev->mtx); \n dev->udev = NULL; \n mutex_unlock(&dev->mtx); \n if (!dev->open_count) \n adu_delete(dev); \n mutex_unlock(&adutux_mutex); \n }",
  "cwe": "CWE-416",
  "codeline": "dev->udev = NULL;"
}
{
  "idx": 298,
  "target": 1,
  "vul": "writefile(const char *name, struct string *s) \n { \n FILE *f; \n int ret; \n f = fopen(name, \"w\"); \n if (!f) { \n warn(\"open %s:\", name); \n return -1; \n } \n ret = 0; \n if (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) { \n warn(\"write %s:\", name); \n ret = -1; \n } \n fclose(f); \n return ret; \n }",
  "no_vul": "writefile(const char *name, struct string *s) \n { \n FILE *f; \n int ret; \n f = fopen(name, \"w\"); \n if (!f) { \n warn(\"open %s:\", name); \n return -1; \n } \n ret = 0; \n if (s && (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0)) { \n warn(\"write %s:\", name); \n ret = -1; \n } \n fclose(f); \n return ret; \n }",
  "cwe": "CWE-284",
  "codeline": "if (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {"
}
{
  "idx": 299,
  "target": 1,
  "vul": "static void sunkbd_reinit(struct work_struct *work) \n { \n struct sunkbd *sunkbd = container_of(work, struct sunkbd, tq); \n wait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ); \n serio_write(sunkbd->serio, SUNKBD_CMD_SETLED); \n serio_write(sunkbd->serio, \n (!!test_bit(LED_CAPSL, sunkbd->dev->led) << 3) | \n (!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) | \n (!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) | \n !!test_bit(LED_NUML, sunkbd->dev->led)); \n serio_write(sunkbd->serio, \n SUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd)); \n serio_write(sunkbd->serio, \n SUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd)); \n }",
  "no_vul": "static void sunkbd_set_leds_beeps(struct sunkbd *sunkbd) \n { \n serio_write(sunkbd->serio, SUNKBD_CMD_SETLED); \n serio_write(sunkbd->serio, \n (!!test_bit(LED_CAPSL, sunkbd->dev->led) << 3) | \n (!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) | \n (!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) | \n !!test_bit(LED_NUML, sunkbd->dev->led)); \n serio_write(sunkbd->serio, \n SUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd)); \n serio_write(sunkbd->serio, \n SUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd)); \n }",
  "cwe": "CWE-416",
  "codeline": "wait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);"
}
{
  "idx": 300,
  "target": 1,
  "vul": "static punycode_uint decode_digit(punycode_uint cp) \n { \n return cp - 48 < 10 ? cp - 22 : cp - 65 < 26 ? cp - 65 : \n cp - 97 < 26 ? cp - 97 : base; \n }",
  "no_vul": "static unsigned decode_digit(int cp) \n { \n return (unsigned) (cp - 48 < 10 ? cp - 22 : cp - 65 < 26 ? cp - 65 : \n cp - 97 < 26 ? cp - 97 : base); \n }",
  "cwe": "CWE-190",
  "codeline": "return cp - 48 < 10 ? cp - 22 : cp - 65 < 26 ? cp - 65 : \n cp - 97 < 26 ? cp - 97 : base;"
}
{
  "idx": 301,
  "target": 1,
  "vul": "int LibarchivePlugin::extractionFlags() const \n { \n int result = ARCHIVE_EXTRACT_TIME; \n result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT; \n return result; \n }",
  "no_vul": "int LibarchivePlugin::extractionFlags() const \n { \n return ARCHIVE_EXTRACT_TIME \n | ARCHIVE_EXTRACT_SECURE_NODOTDOT \n | ARCHIVE_EXTRACT_SECURE_SYMLINKS; \n }",
  "cwe": "CWE-61",
  "codeline": "result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;"
}
{
  "idx": 302,
  "target": 1,
  "vul": "SpawnPreparationInfo prepareSpawn(const Options &options) { \n TRACE_POINT(); \n SpawnPreparationInfo info; \n prepareChroot(info, options); \n info.userSwitching = prepareUserSwitching(options); \n prepareSwitchingWorkingDirectory(info, options); \n inferApplicationInfo(info); \n return info; \n }",
  "no_vul": "SpawnPreparationInfo prepareSpawn(const Options &options) { \n TRACE_POINT(); \n SpawnPreparationInfo info; \n prepareChroot(info, options); \n info.userSwitching = prepareUserSwitching(options); \n prepareSwitchingWorkingDirectory(info, options); \n return info; \n }",
  "cwe": "CWE-61",
  "codeline": "inferApplicationInfo(info);"
}
{
  "idx": 303,
  "target": 1,
  "vul": "void dvb_usb_device_exit(struct usb_interface *intf) \n { \n struct dvb_usb_device *d = usb_get_intfdata(intf); \n const char *name = \"generic DVB-USB module\"; \n usb_set_intfdata(intf, NULL); \n if (d != NULL && d->desc != NULL) { \n name = d->desc->name; \n dvb_usb_exit(d); \n } \n info(\"%s successfully deinitialized and disconnected.\", name); \n }",
  "no_vul": "void dvb_usb_device_exit(struct usb_interface *intf) \n { \n struct dvb_usb_device *d = usb_get_intfdata(intf); \n const char *default_name = \"generic DVB-USB module\"; \n char name[40]; \n usb_set_intfdata(intf, NULL); \n if (d != NULL && d->desc != NULL) { \n strscpy(name, d->desc->name, sizeof(name)); \n dvb_usb_exit(d); \n } else { \n strscpy(name, default_name, sizeof(name)); \n } \n info(\"%s successfully deinitialized and disconnected.\", name); \n }",
  "cwe": "CWE-416",
  "codeline": "name = d->desc->name;"
}
{
  "idx": 304,
  "target": 1,
  "vul": "struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6, \n const struct sk_buff *skb, \n int flags, pol_lookup_t lookup) \n { \n struct rt6_info *rt; \n rt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags); \n if (rt->dst.error == -EAGAIN) { \n ip6_rt_put_flags(rt, flags); \n rt = net->ipv6.ip6_null_entry; \n if (!(flags | RT6_LOOKUP_F_DST_NOREF)) \n dst_hold(&rt->dst); \n } \n return &rt->dst; \n }",
  "no_vul": "struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6, \n const struct sk_buff *skb, \n int flags, pol_lookup_t lookup) \n { \n struct rt6_info *rt; \n rt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags); \n if (rt->dst.error == -EAGAIN) { \n ip6_rt_put_flags(rt, flags); \n rt = net->ipv6.ip6_null_entry; \n if (!(flags & RT6_LOOKUP_F_DST_NOREF)) \n dst_hold(&rt->dst); \n } \n return &rt->dst; \n }",
  "cwe": "CWE-755",
  "codeline": "if (!(flags | RT6_LOOKUP_F_DST_NOREF))"
}
{
  "idx": 305,
  "target": 1,
  "vul": "void xfrm_state_fini(struct net *net) \n { \n unsigned int sz; \n flush_work(&net->xfrm.state_hash_work); \n flush_work(&xfrm_state_gc_work); \n xfrm_state_flush(net, IPSEC_PROTO_ANY, false, true); \n WARN_ON(!list_empty(&net->xfrm.state_all)); \n sz = (net->xfrm.state_hmask + 1) * sizeof(struct hlist_head); \n WARN_ON(!hlist_empty(net->xfrm.state_byspi)); \n xfrm_hash_free(net->xfrm.state_byspi, sz); \n WARN_ON(!hlist_empty(net->xfrm.state_bysrc)); \n xfrm_hash_free(net->xfrm.state_bysrc, sz); \n WARN_ON(!hlist_empty(net->xfrm.state_bydst)); \n xfrm_hash_free(net->xfrm.state_bydst, sz); \n }",
  "no_vul": "void xfrm_state_fini(struct net *net) \n { \n unsigned int sz; \n flush_work(&net->xfrm.state_hash_work); \n flush_work(&xfrm_state_gc_work); \n xfrm_state_flush(net, 0, false, true); \n WARN_ON(!list_empty(&net->xfrm.state_all)); \n sz = (net->xfrm.state_hmask + 1) * sizeof(struct hlist_head); \n WARN_ON(!hlist_empty(net->xfrm.state_byspi)); \n xfrm_hash_free(net->xfrm.state_byspi, sz); \n WARN_ON(!hlist_empty(net->xfrm.state_bysrc)); \n xfrm_hash_free(net->xfrm.state_bysrc, sz); \n WARN_ON(!hlist_empty(net->xfrm.state_bydst)); \n xfrm_hash_free(net->xfrm.state_bydst, sz); \n }",
  "cwe": "CWE-416",
  "codeline": "xfrm_state_flush(net, IPSEC_PROTO_ANY, false, true);"
}
{
  "idx": 306,
  "target": 1,
  "vul": "static inline Quantum GetPixelChannel(const Image *magick_restrict image, \n const PixelChannel channel,const Quantum *magick_restrict pixel) \n { \n if (image->channel_map[channel].traits == UndefinedPixelTrait) \n return((Quantum) 0); \n return(pixel[image->channel_map[channel].offset]); \n }",
  "no_vul": "static inline Quantum GetPixelChannel(const Image *magick_restrict image, \n const PixelChannel channel,const Quantum *magick_restrict pixel) \n { \n if (image->channel_map[image->channel_map[channel].offset].traits == UndefinedPixelTrait) \n return((Quantum) 0); \n return(pixel[image->channel_map[channel].offset]); \n }",
  "cwe": "CWE-20",
  "codeline": "if (image->channel_map[channel].traits == UndefinedPixelTrait) \nreturn((Quantum) 0);"
}
{
  "idx": 307,
  "target": 1,
  "vul": "bool PamBackend::start(const QString &user) { \n bool result; \n QString service = QStringLiteral(\"sddm\"); \n if (user == QStringLiteral(\"sddm\") && m_greeter) \n service = QStringLiteral(\"sddm-greeter\"); \n else if (m_app->session()->path().isEmpty()) \n service = QStringLiteral(\"sddm-check\"); \n else if (m_autologin) \n service = QStringLiteral(\"sddm-autologin\"); \n result = m_pam->start(service, user); \n if (!result) \n m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL); \n return result; \n }",
  "no_vul": "bool PamBackend::start(const QString &user) { \n bool result; \n QString service = QStringLiteral(\"sddm\"); \n if (user == QStringLiteral(\"sddm\") && m_greeter) \n service = QStringLiteral(\"sddm-greeter\"); \n else if (m_autologin) \n service = QStringLiteral(\"sddm-autologin\"); \n result = m_pam->start(service, user); \n if (!result) \n m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL); \n return result; \n }",
  "cwe": "CWE-284",
  "codeline": "else if (m_app->session()->path().isEmpty()) \n service = QStringLiteral(\"sddm-check\");"
}
{
  "idx": 308,
  "target": 1,
  "vul": "static inline void phar_set_inode(phar_entry_info *entry TSRMLS_DC) \n { \n char tmp[MAXPATHLEN]; \n int tmp_len; \n tmp_len = entry->filename_len + entry->phar->fname_len; \n memcpy(tmp, entry->phar->fname, entry->phar->fname_len); \n memcpy(tmp + entry->phar->fname_len, entry->filename, entry->filename_len); \n entry->inode = (unsigned short)zend_get_hash_value(tmp, tmp_len); \n }",
  "no_vul": "static inline void phar_set_inode(phar_entry_info *entry TSRMLS_DC) \n { \n char tmp[MAXPATHLEN]; \n int tmp_len; \n size_t len; \n tmp_len = MIN(MAXPATHLEN, entry->filename_len + entry->phar->fname_len); \n len = MIN(entry->phar->fname_len, tmp_len); \n memcpy(tmp, entry->phar->fname, len); \n len = MIN(tmp_len - len, entry->filename_len); \n memcpy(tmp + entry->phar->fname_len, entry->filename, len); \n entry->inode = (unsigned short)zend_get_hash_value(tmp, tmp_len); \n }",
  "cwe": "CWE-119",
  "codeline": "tmp_len = entry->filename_len + entry->phar->fname_len;"
}
{
  "idx": 309,
  "target": 1,
  "vul": "static void* OGRExpatRealloc( void *ptr, size_t size ) \n { \n if( CanAlloc(size) ) \n return realloc(ptr, size); \n free(ptr); \n return nullptr; \n }",
  "no_vul": "static void* OGRExpatRealloc( void *ptr, size_t size ) \n { \n if( CanAlloc(size) ) \n return realloc(ptr, size); \n return nullptr; \n }",
  "cwe": "CWE-415",
  "codeline": "free(ptr);"
}
{
  "idx": 310,
  "target": 1,
  "vul": "MagickExport MagickBooleanType SetImageExtent(Image *image,const size_t columns, \n const size_t rows,ExceptionInfo *exception) \n { \n if ((columns == 0) || (rows == 0)) \n ThrowBinaryException(ImageError,\"NegativeOrZeroImageSize\",image->filename); \n image->columns=columns; \n image->rows=rows; \n if ((image->depth == 0) || (image->depth > (8*sizeof(MagickSizeType)))) \n ThrowBinaryException(ImageError,\"ImageDepthNotSupported\",image->filename); \n return(SyncImagePixelCache(image,exception)); \n }",
  "no_vul": "MagickExport MagickBooleanType SetImageExtent(Image *image,const size_t columns, \n const size_t rows,ExceptionInfo *exception) \n { \n if ((columns == 0) || (rows == 0)) \n ThrowBinaryException(ImageError,\"NegativeOrZeroImageSize\",image->filename); \n image->columns=columns; \n image->rows=rows; \n if (image->depth == 0) \n { \n image->depth=8; \n (void) ThrowMagickException(exception,GetMagickModule(),ImageError, \n \"ImageDepthNotSupported\",\"`%s'\",image->filename); \n } \n if (image->depth > (8*sizeof(MagickSizeType))) \n { \n image->depth=8*sizeof(MagickSizeType); \n (void) ThrowMagickException(exception,GetMagickModule(),ImageError, \n \"ImageDepthNotSupported\",\"`%s'\",image->filename); \n } \n return(SyncImagePixelCache(image,exception)); \n }",
  "cwe": "CWE-401",
  "codeline": "if ((image->depth == 0) || (image->depth > (8*sizeof(MagickSizeType)))) \nThrowBinaryException(ImageError,\"ImageDepthNotSupported\",image->filename);"
}
{
  "idx": 311,
  "target": 1,
  "vul": "void hid_reset(HIDState *hs) \n { \n switch (hs->kind) { \n case HID_KEYBOARD: \n memset(hs->kbd.keycodes, 0, sizeof(hs->kbd.keycodes)); \n memset(hs->kbd.key, 0, sizeof(hs->kbd.key)); \n hs->kbd.keys = 0; \n break; \n case HID_MOUSE: \n case HID_TABLET: \n memset(hs->ptr.queue, 0, sizeof(hs->ptr.queue)); \n break; \n } \n hs->head = 0; \n hs->n = 0; \n hs->protocol = 1; \n hs->idle = 0; \n hs->idle_pending = false; \n hid_del_idle_timer(hs); \n }",
  "no_vul": "void hid_reset(HIDState *hs) \n { \n switch (hs->kind) { \n case HID_KEYBOARD: \n memset(hs->kbd.keycodes, 0, sizeof(hs->kbd.keycodes)); \n memset(hs->kbd.key, 0, sizeof(hs->kbd.key)); \n hs->kbd.keys = 0; \n hs->kbd.modifiers = 0; \n break; \n case HID_MOUSE: \n case HID_TABLET: \n memset(hs->ptr.queue, 0, sizeof(hs->ptr.queue)); \n break; \n } \n hs->head = 0; \n hs->n = 0; \n hs->protocol = 1; \n hs->idle = 0; \n hs->idle_pending = false; \n hid_del_idle_timer(hs); \n }",
  "cwe": "CWE-772",
  "codeline": "hs->kbd.keys = 0;"
}
{
  "idx": 312,
  "target": 1,
  "vul": "int is_ntfs_dotgit(const char *name) \n { \n size_t len; \n for (len = 0; ; len++) \n if (!name[len] || name[len] == '\\\\' || is_dir_sep(name[len])) { \n if (only_spaces_and_periods(name, len, 4) && \n !strncasecmp(name, \".git\", 4)) \n return 1; \n if (only_spaces_and_periods(name, len, 5) && \n !strncasecmp(name, \"git~1\", 5)) \n return 1; \n return 0; \n } \n }",
  "no_vul": "int is_ntfs_dotgit(const char *name) \n { \n size_t len; \n for (len = 0; ; len++) \n if (!name[len] || name[len] == '\\\\' || is_dir_sep(name[len]) || \n name[len] == ':') { \n if (only_spaces_and_periods(name, len, 4) && \n !strncasecmp(name, \".git\", 4)) \n return 1; \n if (only_spaces_and_periods(name, len, 5) && \n !strncasecmp(name, \"git~1\", 5)) \n return 1; \n return 0; \n } \n }",
  "cwe": "CWE-20",
  "codeline": "if (!name[len] || name[len] == '\\\\' || is_dir_sep(name[len])) {"
}
{
  "idx": 313,
  "target": 1,
  "vul": "static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu) \n { \n if (!kvm_apic_hw_enabled(vcpu->arch.apic)) \n return; \n bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256); \n if (irqchip_split(vcpu->kvm)) \n kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors); \n else { \n if (vcpu->arch.apicv_active) \n kvm_x86_ops->sync_pir_to_irr(vcpu); \n kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors); \n } \n if (is_guest_mode(vcpu)) \n vcpu->arch.load_eoi_exitmap_pending = true; \n else \n kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu); \n }",
  "no_vul": "static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu) \n { \n if (!kvm_apic_hw_enabled(vcpu->arch.apic)) \n return; \n bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256); \n if (irqchip_split(vcpu->kvm)) \n kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors); \n else { \n if (vcpu->arch.apicv_active) \n kvm_x86_ops->sync_pir_to_irr(vcpu); \n if (ioapic_in_kernel(vcpu->kvm)) \n kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors); \n } \n if (is_guest_mode(vcpu)) \n vcpu->arch.load_eoi_exitmap_pending = true; \n else \n kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu); \n }",
  "cwe": "CWE-476",
  "codeline": "kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);"
}
{
  "idx": 314,
  "target": 1,
  "vul": "struct resource_pool *dce112_create_resource_pool( \n uint8_t num_virtual_links, \n struct dc *dc) \n { \n struct dce110_resource_pool *pool = \n kzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL); \n if (!pool) \n return NULL; \n if (construct(num_virtual_links, dc, pool)) \n return &pool->base; \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "no_vul": "struct resource_pool *dce120_create_resource_pool( \n uint8_t num_virtual_links, \n struct dc *dc) \n { \n struct dce110_resource_pool *pool = \n kzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL); \n if (!pool) \n return NULL; \n if (construct(num_virtual_links, dc, pool)) \n return &pool->base; \n kfree(pool); \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "cwe": "CWE-401",
  "codeline": "if (construct(num_virtual_links, dc, pool)) \n return &pool->base;"
}
{
  "idx": 315,
  "target": 1,
  "vul": "struct resource_pool *dce120_create_resource_pool( \n uint8_t num_virtual_links, \n struct dc *dc) \n { \n struct dce110_resource_pool *pool = \n kzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL); \n if (!pool) \n return NULL; \n if (construct(num_virtual_links, dc, pool)) \n return &pool->base; \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "no_vul": "struct resource_pool *dce120_create_resource_pool( \n uint8_t num_virtual_links, \n struct dc *dc) \n { \n struct dce110_resource_pool *pool = \n kzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL); \n if (!pool) \n return NULL; \n if (construct(num_virtual_links, dc, pool)) \n return &pool->base; \n kfree(pool); \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "cwe": "CWE-401",
  "codeline": "if (construct(num_virtual_links, dc, pool)) \n return &pool->base;"
}
{
  "idx": 316,
  "target": 1,
  "vul": "struct resource_pool *dce110_create_resource_pool( \n uint8_t num_virtual_links, \n struct dc *dc, \n struct hw_asic_id asic_id) \n { \n struct dce110_resource_pool *pool = \n kzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL); \n if (!pool) \n return NULL; \n if (construct(num_virtual_links, dc, pool, asic_id)) \n return &pool->base; \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "no_vul": "struct resource_pool *dce110_create_resource_pool( \n uint8_t num_virtual_links, \n struct dc *dc, \n struct hw_asic_id asic_id) \n { \n struct dce110_resource_pool *pool = \n kzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL); \n if (!pool) \n return NULL; \n if (construct(num_virtual_links, dc, pool, asic_id)) \n return &pool->base; \n kfree(pool); \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "cwe": "CWE-401",
  "codeline": "return &pool->base;"
}
{
  "idx": 317,
  "target": 1,
  "vul": "struct resource_pool *dce100_create_resource_pool( \n uint8_t num_virtual_links, \n struct dc *dc) \n { \n struct dce110_resource_pool *pool = \n kzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL); \n if (!pool) \n return NULL; \n if (construct(num_virtual_links, dc, pool)) \n return &pool->base; \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "no_vul": "struct resource_pool *dce100_create_resource_pool( \n uint8_t num_virtual_links, \n struct dc *dc) \n { \n struct dce110_resource_pool *pool = \n kzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL); \n if (!pool) \n return NULL; \n if (construct(num_virtual_links, dc, pool)) \n return &pool->base; \n kfree(pool); \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "cwe": "CWE-401",
  "codeline": "if (construct(num_virtual_links, dc, pool)) \n return &pool->base;"
}
{
  "idx": 318,
  "target": 1,
  "vul": "struct resource_pool *dcn10_create_resource_pool( \n const struct dc_init_data *init_data, \n struct dc *dc) \n { \n struct dcn10_resource_pool *pool = \n kzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL); \n if (!pool) \n return NULL; \n if (construct(init_data->num_virtual_links, dc, pool)) \n return &pool->base; \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "no_vul": "struct resource_pool *dcn10_create_resource_pool( \n const struct dc_init_data *init_data, \n struct dc *dc) \n { \n struct dcn10_resource_pool *pool = \n kzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL); \n if (!pool) \n return NULL; \n if (construct(init_data->num_virtual_links, dc, pool)) \n return &pool->base; \n kfree(pool); \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "cwe": "CWE-401",
  "codeline": "if (construct(init_data->num_virtual_links, dc, pool)) \n return &pool->base;"
}
{
  "idx": 319,
  "target": 1,
  "vul": "static void do_client_disconnect(void) \n { \n if (client_connected) { \n udscs_server_write_all(server, VDAGENTD_CLIENT_DISCONNECTED, 0, 0, \n NULL, 0); \n client_connected = false; \n } \n }",
  "no_vul": "static void do_client_disconnect(void) \n { \n g_hash_table_remove_all(active_xfers); \n if (client_connected) { \n udscs_server_write_all(server, VDAGENTD_CLIENT_DISCONNECTED, 0, 0, \n NULL, 0); \n client_connected = false; \n } \n }",
  "cwe": "CWE-200",
  "codeline": "udscs_server_write_all(server, VDAGENTD_CLIENT_DISCONNECTED, 0, 0, NULL, 0);"
}
{
  "idx": 320,
  "target": 1,
  "vul": "static rfbBool MallocFrameBuffer(rfbClient* client) { \n if(client->frameBuffer) \n free(client->frameBuffer); \n client->frameBuffer=malloc(client->width*client->height*client->format.bitsPerPixel/8); \n return client->frameBuffer?TRUE:FALSE; \n }",
  "no_vul": "static rfbBool MallocFrameBuffer(rfbClient* client) { \n uint64_t allocSize; \n if(client->frameBuffer) \n free(client->frameBuffer); \n allocSize = (uint64_t)client->width * client->height * client->format.bitsPerPixel/8; \n if (allocSize >= SIZE_MAX) { \n rfbClientErr(\"CRITICAL: cannot allocate frameBuffer, requested size is too large\\n\"); \n return FALSE; \n } \n client->frameBuffer=malloc( (size_t)allocSize ); \n if (client->frameBuffer == NULL) \n rfbClientErr(\"CRITICAL: frameBuffer allocation failed, requested size too large or not enough memory?\\n\"); \n return client->frameBuffer?TRUE:FALSE; \n }",
  "cwe": "CWE-189",
  "codeline": "client->frameBuffer=malloc(client->width*client->height*client->format.bitsPerPixel/8);"
}
{
  "idx": 321,
  "target": 1,
  "vul": "void jbd2_journal_wait_updates(journal_t *journal) \n { \n transaction_t *commit_transaction = journal->j_running_transaction; \n if (!commit_transaction) \n return; \n spin_lock(&commit_transaction->t_handle_lock); \n while (atomic_read(&commit_transaction->t_updates)) { \n DEFINE_WAIT(wait); \n prepare_to_wait(&journal->j_wait_updates, &wait, \n TASK_UNINTERRUPTIBLE); \n if (atomic_read(&commit_transaction->t_updates)) { \n spin_unlock(&commit_transaction->t_handle_lock); \n write_unlock(&journal->j_state_lock); \n schedule(); \n write_lock(&journal->j_state_lock); \n spin_lock(&commit_transaction->t_handle_lock); \n } \n finish_wait(&journal->j_wait_updates, &wait); \n } \n spin_unlock(&commit_transaction->t_handle_lock); \n }",
  "no_vul": "void jbd2_journal_wait_updates(journal_t *journal) \n { \n DEFINE_WAIT(wait); \n while (1) { \n transaction_t *transaction = journal->j_running_transaction; \n if (!transaction) \n break; \n spin_lock(&transaction->t_handle_lock); \n prepare_to_wait(&journal->j_wait_updates, &wait, \n TASK_UNINTERRUPTIBLE); \n if (!atomic_read(&transaction->t_updates)) { \n spin_unlock(&transaction->t_handle_lock); \n finish_wait(&journal->j_wait_updates, &wait); \n break; \n } \n spin_unlock(&transaction->t_handle_lock); \n write_unlock(&journal->j_state_lock); \n schedule(); \n finish_wait(&journal->j_wait_updates, &wait); \n write_lock(&journal->j_state_lock); \n } \n }",
  "cwe": "CWE-416",
  "codeline": "spin_unlock(&commit_transaction->t_handle_lock);"
}
{
  "idx": 322,
  "target": 1,
  "vul": "static void cpia2_usb_disconnect(struct usb_interface *intf) \n { \n struct camera_data *cam = usb_get_intfdata(intf); \n usb_set_intfdata(intf, NULL); \n DBG(\"Stopping stream\\n\"); \n cpia2_usb_stream_stop(cam); \n mutex_lock(&cam->v4l2_lock); \n DBG(\"Unregistering camera\\n\"); \n cpia2_unregister_camera(cam); \n v4l2_device_disconnect(&cam->v4l2_dev); \n mutex_unlock(&cam->v4l2_lock); \n v4l2_device_put(&cam->v4l2_dev); \n if(cam->buffers) { \n DBG(\"Wakeup waiting processes\\n\"); \n cam->curbuff->status = FRAME_READY; \n cam->curbuff->length = 0; \n wake_up_interruptible(&cam->wq_stream); \n } \n LOG(\"CPiA2 camera disconnected.\\n\"); \n }",
  "no_vul": "static void cpia2_usb_disconnect(struct usb_interface *intf) \n { \n struct camera_data *cam = usb_get_intfdata(intf); \n usb_set_intfdata(intf, NULL); \n DBG(\"Stopping stream\\n\"); \n cpia2_usb_stream_stop(cam); \n mutex_lock(&cam->v4l2_lock); \n DBG(\"Unregistering camera\\n\"); \n cpia2_unregister_camera(cam); \n v4l2_device_disconnect(&cam->v4l2_dev); \n mutex_unlock(&cam->v4l2_lock); \n if(cam->buffers) { \n DBG(\"Wakeup waiting processes\\n\"); \n cam->curbuff->status = FRAME_READY; \n cam->curbuff->length = 0; \n wake_up_interruptible(&cam->wq_stream); \n } \n v4l2_device_put(&cam->v4l2_dev); \n LOG(\"CPiA2 camera disconnected.\\n\"); \n }",
  "cwe": "CWE-416",
  "codeline": "v4l2_device_put(&cam->v4l2_dev);"
}
{
  "idx": 323,
  "target": 1,
  "vul": "static efi_status_t __init phys_efi_set_virtual_address_map( \n unsigned long memory_map_size, \n unsigned long descriptor_size, \n u32 descriptor_version, \n efi_memory_desc_t *virtual_map) \n { \n efi_status_t status; \n unsigned long flags; \n pgd_t *save_pgd; \n save_pgd = efi_call_phys_prolog(); \n local_irq_save(flags); \n status = efi_call_phys(efi_phys.set_virtual_address_map, \n memory_map_size, descriptor_size, \n descriptor_version, virtual_map); \n local_irq_restore(flags); \n efi_call_phys_epilog(save_pgd); \n return status; \n }",
  "no_vul": "static efi_status_t __init phys_efi_set_virtual_address_map( \n unsigned long memory_map_size, \n unsigned long descriptor_size, \n u32 descriptor_version, \n efi_memory_desc_t *virtual_map) \n { \n efi_status_t status; \n unsigned long flags; \n pgd_t *save_pgd; \n save_pgd = efi_call_phys_prolog(); \n if (!save_pgd) \n return EFI_ABORTED; \n local_irq_save(flags); \n status = efi_call_phys(efi_phys.set_virtual_address_map, \n memory_map_size, descriptor_size, \n descriptor_version, virtual_map); \n local_irq_restore(flags); \n efi_call_phys_epilog(save_pgd); \n return status; \n }",
  "cwe": "CWE-388",
  "codeline": "save_pgd = efi_call_phys_prolog();"
}
{
  "idx": 324,
  "target": 1,
  "vul": "static void drop_sysctl_table(struct ctl_table_header *header) \n { \n struct ctl_dir *parent = header->parent; \n if (--header->nreg) \n return; \n if (parent) \n put_links(header); \n start_unregistering(header); \n if (!--header->count) \n kfree_rcu(header, rcu); \n if (parent) \n drop_sysctl_table(&parent->header); \n }",
  "no_vul": "static void drop_sysctl_table(struct ctl_table_header *header) \n { \n struct ctl_dir *parent = header->parent; \n if (--header->nreg) \n return; \n if (parent) { \n put_links(header); \n start_unregistering(header); \n } \n if (!--header->count) \n kfree_rcu(header, rcu); \n if (parent) \n drop_sysctl_table(&parent->header); \n }",
  "cwe": "CWE-476",
  "codeline": "if (parent) \n put_links(header); \n start_unregistering(header);"
}
{
  "idx": 325,
  "target": 1,
  "vul": "ByteVector ByteVector::mid(uint index, uint length) const \n { \n ByteVector v; \n if(index > size()) \n return v; \n ConstIterator endIt; \n if(length < 0xffffffff && length + index < size()) \n endIt = d->data.begin() + index + length; \n else \n endIt = d->data.end(); \n v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt); \n v.d->size = v.d->data.size(); \n return v; \n }",
  "no_vul": "ByteVector ByteVector::mid(uint index, uint length) const \n { \n ByteVector v; \n if(index > size()) \n return v; \n ConstIterator endIt; \n if(length < size() - index) \n endIt = d->data.begin() + index + length; \n else \n endIt = d->data.end(); \n v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt); \n v.d->size = v.d->data.size(); \n return v; \n }",
  "cwe": "CWE-189",
  "codeline": "if(length < 0xffffffff && length + index < size())"
}
{
  "idx": 326,
  "target": 1,
  "vul": "static int HistogramCompare(const void *x,const void *y) \n { \n const PixelInfo \n *color_1, \n *color_2; \n color_1=(const PixelInfo *) x; \n color_2=(const PixelInfo *) y; \n if (color_2->red != color_1->red) \n return((int) color_1->red-(int) color_2->red); \n if (color_2->green != color_1->green) \n return((int) color_1->green-(int) color_2->green); \n if (color_2->blue != color_1->blue) \n return((int) color_1->blue-(int) color_2->blue); \n return((int) color_2->count-(int) color_1->count); \n }",
  "no_vul": "static int HistogramCompare(const void *x,const void *y) \n { \n const PixelInfo \n *color_1, \n *color_2; \n color_1=(const PixelInfo *) x; \n color_2=(const PixelInfo *) y; \n if (color_2->red != color_1->red) \n return((int) ((ssize_t) color_1->red-(ssize_t) color_2->red)); \n if (color_2->green != color_1->green) \n return((int) ((ssize_t) color_1->green-(ssize_t) color_2->green)); \n if (color_2->blue != color_1->blue) \n return((int) ((ssize_t) color_1->blue-(ssize_t) color_2->blue)); \n return((int) ((ssize_t) color_2->count-(ssize_t) color_1->count)); \n }",
  "cwe": "CWE-190",
  "codeline": "return((int) color_1->red-(int) color_2->red);"
}
{
  "idx": 327,
  "target": 1,
  "vul": "_gnutls_x509_oid2mac_algorithm (const char *oid) \n { \n gnutls_mac_algorithm_t ret = 0; \n GNUTLS_HASH_LOOP (if (strcmp (oid, p->oid) == 0) \n { \n ret = p->id; break;} \n ); \n if (ret == 0) \n return GNUTLS_MAC_UNKNOWN; \n return ret; \n }",
  "no_vul": "_gnutls_x509_oid2mac_algorithm (const char *oid) \n { \n gnutls_mac_algorithm_t ret = 0; \n GNUTLS_HASH_LOOP (if (p->oid && strcmp (oid, p->oid) == 0) \n { \n ret = p->id; break;} \n ); \n if (ret == 0) \n return GNUTLS_MAC_UNKNOWN; \n return ret; \n }",
  "cwe": "CWE-310",
  "codeline": "if (strcmp (oid, p->oid) == 0)"
}
{
  "idx": 328,
  "target": 1,
  "vul": "static inline int init_new_context(struct task_struct *tsk, \n struct mm_struct *mm) \n { \n #ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS \n if (cpu_feature_enabled(X86_FEATURE_OSPKE)) { \n mm->context.pkey_allocation_map = 0x1; \n mm->context.execute_only_pkey = -1; \n } \n #endif \n init_new_context_ldt(tsk, mm); \n return 0; \n }",
  "no_vul": "static inline int init_new_context(struct task_struct *tsk, \n struct mm_struct *mm) \n { \n #ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS \n if (cpu_feature_enabled(X86_FEATURE_OSPKE)) { \n mm->context.pkey_allocation_map = 0x1; \n mm->context.execute_only_pkey = -1; \n } \n #endif \n return init_new_context_ldt(tsk, mm); \n }",
  "cwe": "CWE-416",
  "codeline": "init_new_context_ldt(tsk, mm);"
}
{
  "idx": 329,
  "target": 1,
  "vul": "void pb_controller::play_file(const std::string& file) { \n std::string cmdline; \n std::string player = cfg->get_configvalue(\"player\"); \n if (player == \"\") \n return; \n cmdline.append(player); \n cmdline.append(\" \\\"\"); \n cmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\")); \n cmdline.append(\"\\\"\"); \n stfl::reset(); \n LOG(LOG_DEBUG, \"pb_controller::play_file: running `%s'\", cmdline.c_str()); \n ::system(cmdline.c_str()); \n }",
  "no_vul": "void pb_controller::play_file(const std::string& file) { \n std::string cmdline; \n std::string player = cfg->get_configvalue(\"player\"); \n if (player == \"\") \n return; \n cmdline.append(player); \n cmdline.append(\" \\'\"); \n cmdline.append(utils::replace_all(file,\"'\", \"%27\")); \n cmdline.append(\"\\'\"); \n stfl::reset(); \n LOG(LOG_DEBUG, \"pb_controller::play_file: running `%s'\", cmdline.c_str()); \n ::system(cmdline.c_str()); \n }",
  "cwe": "CWE-78",
  "codeline": "cmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));"
}
{
  "idx": 330,
  "target": 1,
  "vul": "int snd_usb_pipe_sanity_check(struct usb_device *dev, unsigned int pipe) \n { \n static const int pipetypes[4] = { \n PIPE_CONTROL, PIPE_ISOCHRONOUS, PIPE_BULK, PIPE_INTERRUPT \n }; \n struct usb_host_endpoint *ep; \n ep = usb_pipe_endpoint(dev, pipe); \n if (usb_pipetype(pipe) != pipetypes[usb_endpoint_type(&ep->desc)]) \n return -EINVAL; \n return 0; \n }",
  "no_vul": "int snd_usb_pipe_sanity_check(struct usb_device *dev, unsigned int pipe) \n { \n static const int pipetypes[4] = { \n PIPE_CONTROL, PIPE_ISOCHRONOUS, PIPE_BULK, PIPE_INTERRUPT \n }; \n struct usb_host_endpoint *ep; \n ep = usb_pipe_endpoint(dev, pipe); \n if (!ep || usb_pipetype(pipe) != pipetypes[usb_endpoint_type(&ep->desc)]) \n return -EINVAL; \n return 0; \n }",
  "cwe": "CWE-476",
  "codeline": "if (usb_pipetype(pipe) != pipetypes[usb_endpoint_type(&ep->desc)]) \nreturn -EINVAL;"
}
{
  "idx": 331,
  "target": 1,
  "vul": "static int keyring_detect_cycle_iterator(const void *object, \n void *iterator_data) \n { \n struct keyring_search_context *ctx = iterator_data; \n const struct key *key = keyring_ptr_to_key(object); \n kenter(\"{%d}\", key->serial); \n BUG_ON(key != ctx->match_data); \n ctx->result = ERR_PTR(-EDEADLK); \n return 1; \n }",
  "no_vul": "static int keyring_detect_cycle_iterator(const void *object, \n void *iterator_data) \n { \n struct keyring_search_context *ctx = iterator_data; \n const struct key *key = keyring_ptr_to_key(object); \n kenter(\"{%d}\", key->serial); \n if (key != ctx->match_data) \n return 0; \n ctx->result = ERR_PTR(-EDEADLK); \n return 1; \n }",
  "cwe": "CWE-310",
  "codeline": "BUG_ON(key != ctx->match_data);"
}
{
  "idx": 332,
  "target": 1,
  "vul": "void __init aarp_proto_init(void) \n { \n aarp_dl = register_snap_client(aarp_snap_id, aarp_rcv); \n if (!aarp_dl) \n printk(KERN_CRIT \"Unable to register AARP with SNAP.\\n\"); \n timer_setup(&aarp_timer, aarp_expire_timeout, 0); \n aarp_timer.expires = jiffies + sysctl_aarp_expiry_time; \n add_timer(&aarp_timer); \n register_netdevice_notifier(&aarp_notifier); \n }",
  "no_vul": "int __init aarp_proto_init(void) \n { \n int rc; \n aarp_dl = register_snap_client(aarp_snap_id, aarp_rcv); \n if (!aarp_dl) { \n printk(KERN_CRIT \"Unable to register AARP with SNAP.\\n\"); \n return -ENOMEM; \n } \n timer_setup(&aarp_timer, aarp_expire_timeout, 0); \n aarp_timer.expires = jiffies + sysctl_aarp_expiry_time; \n add_timer(&aarp_timer); \n rc = register_netdevice_notifier(&aarp_notifier); \n if (rc) { \n del_timer_sync(&aarp_timer); \n unregister_snap_client(aarp_dl); \n } \n return rc; \n }",
  "cwe": "CWE-476",
  "codeline": "if (!aarp_dl) \n printk(KERN_CRIT \"Unable to register AARP with SNAP.\\n\");"
}
{
  "idx": 333,
  "target": 1,
  "vul": "int af_alg_release(struct socket *sock) \n { \n if (sock->sk) \n sock_put(sock->sk); \n return 0; \n }",
  "no_vul": "int af_alg_release(struct socket *sock) \n { \n if (sock->sk) { \n sock_put(sock->sk); \n sock->sk = NULL; \n } \n return 0; \n }",
  "cwe": "CWE-416",
  "codeline": "if (sock->sk) \nsock_put(sock->sk);"
}
{
  "idx": 334,
  "target": 1,
  "vul": "setup_server_realm(struct server_handle *handle, krb5_principal sprinc) \n { \n kdc_realm_t *newrealm; \n kdc_realm_t **kdc_realmlist = handle->kdc_realmlist; \n int kdc_numrealms = handle->kdc_numrealms; \n if (kdc_numrealms > 1) { \n if (!(newrealm = find_realm_data(handle, sprinc->realm.data, \n (krb5_ui_4) sprinc->realm.length))) \n return NULL; \n else \n return newrealm; \n } \n else \n return kdc_realmlist[0]; \n }",
  "no_vul": "setup_server_realm(struct server_handle *handle, krb5_principal sprinc) \n { \n kdc_realm_t *newrealm; \n kdc_realm_t **kdc_realmlist = handle->kdc_realmlist; \n int kdc_numrealms = handle->kdc_numrealms; \n if (sprinc == NULL) \n return NULL; \n if (kdc_numrealms > 1) { \n if (!(newrealm = find_realm_data(handle, sprinc->realm.data, \n (krb5_ui_4) sprinc->realm.length))) \n return NULL; \n else \n return newrealm; \n } \n else \n return kdc_realmlist[0]; \n }",
  "cwe": "CWE-476",
  "codeline": "if (!(newrealm = find_realm_data(handle, sprinc->realm.data, \n (krb5_ui_4) sprinc->realm.length)))"
}
{
  "idx": 335,
  "target": 1,
  "vul": "static ssize_t driver_override_show(struct device *_dev, \n struct device_attribute *attr, char *buf) \n { \n struct amba_device *dev = to_amba_device(_dev); \n return sprintf(buf, \"%s\\n\", dev->driver_override); \n }",
  "no_vul": "static ssize_t driver_override_show(struct device *_dev, \n struct device_attribute *attr, char *buf) \n { \n struct amba_device *dev = to_amba_device(_dev); \n ssize_t len; \n device_lock(_dev); \n len = sprintf(buf, \"%s\\n\", dev->driver_override); \n device_unlock(_dev); \n return len; \n }",
  "cwe": "CWE-415",
  "codeline": "return sprintf(buf, \"%s\\n\", dev->driver_override);"
}
{
  "idx": 336,
  "target": 1,
  "vul": "static void hidp_process_report(struct hidp_session *session, \n int type, const u8 *data, int len, int intr) \n { \n if (len > HID_MAX_BUFFER_SIZE) \n len = HID_MAX_BUFFER_SIZE; \n memcpy(session->input_buf, data, len); \n hid_input_report(session->hid, type, session->input_buf, len, intr); \n }",
  "no_vul": "static void hidp_process_report(struct hidp_session *session, int type, \n const u8 *data, unsigned int len, int intr) \n { \n if (len > HID_MAX_BUFFER_SIZE) \n len = HID_MAX_BUFFER_SIZE; \n memcpy(session->input_buf, data, len); \n hid_input_report(session->hid, type, session->input_buf, len, intr); \n }",
  "cwe": "CWE-787",
  "codeline": "memcpy(session->input_buf, data, len);"
}
{
  "idx": 337,
  "target": 1,
  "vul": "START_TEST(test_tm_adopt_ispidowner) \n { \n fail_unless(TRUE == ispidowner(getpid())); \n fail_unless(FALSE == ispidowner(1)); \n }",
  "no_vul": "START_TEST(test_tm_adopt_ispidowner) \n { \n fail_unless(TRUE == ispidowner(getpid())); \n if (getuid() != 0) \n fail_unless(FALSE == ispidowner(1)); \n }",
  "cwe": "CWE-264",
  "codeline": "fail_unless(FALSE == ispidowner(1));"
}
{
  "idx": 338,
  "target": 1,
  "vul": "resolve_iffeature(struct lys_iffeature *expr) \n { \n int index_e = 0, index_f = 0; \n if (expr->expr) { \n return resolve_iffeature_recursive(expr, &index_e, &index_f); \n } \n return 0; \n }",
  "no_vul": "resolve_iffeature(struct lys_iffeature *expr) \n { \n int index_e = 0, index_f = 0; \n if (expr->expr && expr->features[0]) { \n return resolve_iffeature_recursive(expr, &index_e, &index_f); \n } \n return 0; \n }",
  "cwe": "CWE-119",
  "codeline": "if (expr->expr) {"
}
{
  "idx": 339,
  "target": 1,
  "vul": "int PackLinuxElf32::canUnpack() \n { \n if (super::canUnpack()) { \n return true; \n } \n if (Elf32_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) { \n PackLinuxElf32help1(fi); \n } \n return false; \n }",
  "no_vul": "int PackLinuxElf32::canUnpack() \n { \n if (checkEhdr(&ehdri)) { \n return false; \n } \n if (Elf32_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) { \n PackLinuxElf32help1(fi); \n } \n if (super::canUnpack()) { \n return true; \n } \n return false; \n }",
  "cwe": "CWE-415",
  "codeline": "if (Elf32_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) { \n PackLinuxElf32help1(fi); \n }"
}
{
  "idx": 340,
  "target": 1,
  "vul": "static int sony_init_ff(struct sony_sc *sc) \n { \n struct hid_input *hidinput = list_entry(sc->hdev->inputs.next, \n struct hid_input, list); \n struct input_dev *input_dev = hidinput->input; \n input_set_capability(input_dev, EV_FF, FF_RUMBLE); \n return input_ff_create_memless(input_dev, NULL, sony_play_effect); \n }",
  "no_vul": "static int sony_init_ff(struct sony_sc *sc) \n { \n struct hid_input *hidinput; \n struct input_dev *input_dev; \n if (list_empty(&sc->hdev->inputs)) { \n hid_err(sc->hdev, \"no inputs found\\n\"); \n return -ENODEV; \n } \n hidinput = list_entry(sc->hdev->inputs.next, struct hid_input, list); \n input_dev = hidinput->input; \n input_set_capability(input_dev, EV_FF, FF_RUMBLE); \n return input_ff_create_memless(input_dev, NULL, sony_play_effect); \n }",
  "cwe": "CWE-787",
  "codeline": "struct hid_input *hidinput = list_entry(sc->hdev->inputs.next, \n struct hid_input, list);"
}
{
  "idx": 341,
  "target": 1,
  "vul": "GetNumWrongData(const byte * curPtr, const int maxnum) \n { \n int count = 0; \n if (1 == maxnum) { \n return (1); \n } \n while (*(curPtr + count) != *(curPtr + count + 1) && maxnum > count) { \n count++; \n } \n return (count); \n }",
  "no_vul": "GetNumWrongData(const byte * curPtr, const int maxnum) \n { \n int count = 0; \n if (1 == maxnum) { \n return (1); \n } \n while (maxnum > count+1 && *(curPtr + count) != *(curPtr + count + 1)) { \n count++; \n } \n return (count); \n }",
  "cwe": "CWE-787",
  "codeline": "while (*(curPtr + count) != *(curPtr + count + 1) && maxnum > count) {"
}
{
  "idx": 342,
  "target": 1,
  "vul": "check_vim9_unlet(char_u *name) \n { \n if (name[1] != ':' || vim_strchr((char_u *)\"gwtb\", *name) == NULL) \n { \n if (*name == 's' && !script_is_vim9()) \n return OK; \n semsg(_(e_cannot_unlet_str), name); \n return FAIL; \n } \n return OK; \n }",
  "no_vul": "check_vim9_unlet(char_u *name) \n { \n if (*name == NUL) \n { \n semsg(_(e_argument_required_for_str), \"unlet\"); \n return FAIL; \n } \n if (name[1] != ':' || vim_strchr((char_u *)\"gwtb\", *name) == NULL) \n { \n if (*name == 's' && !script_is_vim9()) \n return OK; \n semsg(_(e_cannot_unlet_str), name); \n return FAIL; \n } \n return OK; \n }",
  "cwe": "CWE-125",
  "codeline": "if (name[1] != ':' || vim_strchr((char_u *)\"gwtb\", *name) == NULL)"
}
{
  "idx": 343,
  "target": 1,
  "vul": "static int wrap_nettle_hash_fast(gnutls_digest_algorithm_t algo, \n const void *text, size_t text_size, \n void *digest) \n { \n struct nettle_hash_ctx ctx; \n int ret; \n ret = _ctx_init(algo, &ctx); \n if (ret < 0) \n return gnutls_assert_val(ret); \n ctx.update(&ctx, text_size, text); \n ctx.digest(&ctx, ctx.length, digest); \n return 0; \n }",
  "no_vul": "static int wrap_nettle_hash_fast(gnutls_digest_algorithm_t algo, \n const void *text, size_t text_size, \n void *digest) \n { \n struct nettle_hash_ctx ctx; \n int ret; \n ret = _ctx_init(algo, &ctx); \n if (ret < 0) \n return gnutls_assert_val(ret); \n if (text_size > 0) { \n ctx.update(&ctx, text_size, text); \n } \n ctx.digest(&ctx, ctx.length, digest); \n return 0; \n }",
  "cwe": "CWE-476",
  "codeline": "ctx.update(&ctx, text_size, text);"
}
{
  "idx": 344,
  "target": 1,
  "vul": "static inline bool can_follow_write_pmd(pmd_t pmd, unsigned int flags) \n { \n return pmd_write(pmd) || \n ((flags & FOLL_FORCE) && (flags & FOLL_COW) && pmd_dirty(pmd)); \n }",
  "no_vul": "static inline bool can_follow_write_pte(pte_t pte, unsigned int flags) \n { \n return pte_write(pte) || ((flags & FOLL_COW) && pte_dirty(pte)); \n }",
  "cwe": "CWE-362",
  "codeline": "return pmd_write(pmd) || ((flags & FOLL_FORCE) && (flags & FOLL_COW) && pmd_dirty(pmd));"
}
{
  "idx": 345,
  "target": 1,
  "vul": "static int cirrus_bitblt_videotovideo_copy(CirrusVGAState * s) \n { \n if (s->ds->dpy_copy) { \n cirrus_do_copy(s, s->cirrus_blt_dstaddr - s->start_addr, \n s->cirrus_blt_srcaddr - s->start_addr, \n s->cirrus_blt_width, s->cirrus_blt_height); \n } else { \n if (BLTUNSAFE(s)) \n return 0; \n (*s->cirrus_rop) (s, s->vram_ptr + \n (s->cirrus_blt_dstaddr & s->cirrus_addr_mask), \n s->vram_ptr + \n (s->cirrus_blt_srcaddr & s->cirrus_addr_mask), \n s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch, \n s->cirrus_blt_width, s->cirrus_blt_height); \n cirrus_invalidate_region(s, s->cirrus_blt_dstaddr, \n s->cirrus_blt_dstpitch, s->cirrus_blt_width, \n s->cirrus_blt_height); \n } \n return 1; \n }",
  "no_vul": "static int cirrus_bitblt_videotovideo_copy(CirrusVGAState * s) \n { \n if (BLTUNSAFE(s)) \n return 0; \n if (s->ds->dpy_copy) { \n cirrus_do_copy(s, s->cirrus_blt_dstaddr - s->start_addr, \n s->cirrus_blt_srcaddr - s->start_addr, \n s->cirrus_blt_width, s->cirrus_blt_height); \n } else { \n (*s->cirrus_rop) (s, s->vram_ptr + \n (s->cirrus_blt_dstaddr & s->cirrus_addr_mask), \n s->vram_ptr + \n (s->cirrus_blt_srcaddr & s->cirrus_addr_mask), \n s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch, \n s->cirrus_blt_width, s->cirrus_blt_height); \n cirrus_invalidate_region(s, s->cirrus_blt_dstaddr, \n s->cirrus_blt_dstpitch, s->cirrus_blt_width, \n s->cirrus_blt_height); \n } \n return 1; \n }",
  "cwe": "CWE-787",
  "codeline": "if (s->ds->dpy_copy) { \ncirrus_do_copy(s, s->cirrus_blt_dstaddr - s->start_addr, \ns->cirrus_blt_srcaddr - s->start_addr, \ns->cirrus_blt_width, s->cirrus_blt_height); \n} else { \nif (BLTUNSAFE(s)) \nreturn 0; \n(*s->cirrus_rop) (s, s->vram_ptr + \n(s->cirrus_blt_dstaddr & s->cirrus_addr_mask), \ns->vram_ptr + \n(s->cirrus_blt_srcaddr & s->cirrus_addr_mask), \ns->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch, \ns->cirrus_blt_width, s->cirrus_blt_height); \ncirrus_invalidate_region(s, s->cirrus_blt_dstaddr, \ns->cirrus_blt_dstpitch, s->cirrus_blt_width, \ns->cirrus_blt_height); \n}"
}
{
  "idx": 346,
  "target": 1,
  "vul": "static int pcan_usb_pro_drv_loaded(struct peak_usb_device *dev, int loaded) \n { \n u8 *buffer; \n int err; \n buffer = kmalloc(PCAN_USBPRO_FCT_DRVLD_REQ_LEN, GFP_KERNEL); \n if (!buffer) \n return -ENOMEM; \n buffer[0] = 0; \n buffer[1] = !!loaded; \n err = pcan_usb_pro_send_req(dev, PCAN_USBPRO_REQ_FCT, \n PCAN_USBPRO_FCT_DRVLD, buffer, \n PCAN_USBPRO_FCT_DRVLD_REQ_LEN); \n kfree(buffer); \n return err; \n }",
  "no_vul": "static int pcan_usb_pro_drv_loaded(struct peak_usb_device *dev, int loaded) \n { \n u8 *buffer; \n int err; \n buffer = kzalloc(PCAN_USBPRO_FCT_DRVLD_REQ_LEN, GFP_KERNEL); \n if (!buffer) \n return -ENOMEM; \n buffer[0] = 0; \n buffer[1] = !!loaded; \n err = pcan_usb_pro_send_req(dev, PCAN_USBPRO_REQ_FCT, \n PCAN_USBPRO_FCT_DRVLD, buffer, \n PCAN_USBPRO_FCT_DRVLD_REQ_LEN); \n kfree(buffer); \n return err; \n }",
  "cwe": "CWE-909",
  "codeline": "buffer = kmalloc(PCAN_USBPRO_FCT_DRVLD_REQ_LEN, GFP_KERNEL);"
}
{
  "idx": 347,
  "target": 1,
  "vul": "void gfs2_clear_rgrpd(struct gfs2_sbd *sdp) \n { \n struct rb_node *n; \n struct gfs2_rgrpd *rgd; \n struct gfs2_glock *gl; \n while ((n = rb_first(&sdp->sd_rindex_tree))) { \n rgd = rb_entry(n, struct gfs2_rgrpd, rd_node); \n gl = rgd->rd_gl; \n rb_erase(n, &sdp->sd_rindex_tree); \n if (gl) { \n spin_lock(&gl->gl_lockref.lock); \n gl->gl_object = NULL; \n spin_unlock(&gl->gl_lockref.lock); \n gfs2_glock_add_to_lru(gl); \n gfs2_glock_put(gl); \n } \n gfs2_free_clones(rgd); \n kfree(rgd->rd_bits); \n return_all_reservations(rgd); \n kmem_cache_free(gfs2_rgrpd_cachep, rgd); \n } \n }",
  "no_vul": "void gfs2_clear_rgrpd(struct gfs2_sbd *sdp) \n { \n struct rb_node *n; \n struct gfs2_rgrpd *rgd; \n struct gfs2_glock *gl; \n while ((n = rb_first(&sdp->sd_rindex_tree))) { \n rgd = rb_entry(n, struct gfs2_rgrpd, rd_node); \n gl = rgd->rd_gl; \n rb_erase(n, &sdp->sd_rindex_tree); \n if (gl) { \n spin_lock(&gl->gl_lockref.lock); \n gl->gl_object = NULL; \n spin_unlock(&gl->gl_lockref.lock); \n gfs2_glock_add_to_lru(gl); \n gfs2_glock_put(gl); \n } \n gfs2_free_clones(rgd); \n kfree(rgd->rd_bits); \n rgd->rd_bits = NULL; \n return_all_reservations(rgd); \n kmem_cache_free(gfs2_rgrpd_cachep, rgd); \n } \n }",
  "cwe": "CWE-416",
  "codeline": "kfree(rgd->rd_bits);"
}
{
  "idx": 348,
  "target": 1,
  "vul": "static void close_all_connections(struct Curl_multi *multi) \n { \n struct connectdata *conn; \n conn = Curl_conncache_find_first_connection(&multi->conn_cache); \n while(conn) { \n SIGPIPE_VARIABLE(pipe_st); \n conn->data = multi->closure_handle; \n sigpipe_ignore(conn->data, &pipe_st); \n (void)Curl_disconnect(conn, FALSE); \n sigpipe_restore(&pipe_st); \n conn = Curl_conncache_find_first_connection(&multi->conn_cache); \n } \n }",
  "no_vul": "static void close_all_connections(struct Curl_multi *multi) \n { \n struct connectdata *conn; \n conn = Curl_conncache_find_first_connection(&multi->conn_cache); \n while(conn) { \n SIGPIPE_VARIABLE(pipe_st); \n conn->data = multi->closure_handle; \n sigpipe_ignore(conn->data, &pipe_st); \n conn->data->easy_conn = NULL; \n (void)Curl_disconnect(conn, FALSE); \n sigpipe_restore(&pipe_st); \n conn = Curl_conncache_find_first_connection(&multi->conn_cache); \n } \n }",
  "cwe": "CWE-416",
  "codeline": "conn->data = multi->closure_handle;"
}
{
  "idx": 349,
  "target": 1,
  "vul": "static size_t php_bz2iop_read(php_stream *stream, char *buf, size_t count TSRMLS_DC) \n { \n struct php_bz2_stream_data_t *self = (struct php_bz2_stream_data_t *) stream->abstract; \n size_t ret; \n ret = BZ2_bzread(self->bz_file, buf, count); \n if (ret == 0) { \n stream->eof = 1; \n } \n return ret; \n }",
  "no_vul": "static size_t php_bz2iop_read(php_stream *stream, char *buf, size_t count TSRMLS_DC) \n { \n struct php_bz2_stream_data_t *self = (struct php_bz2_stream_data_t *) stream->abstract; \n int bz2_ret; \n bz2_ret = BZ2_bzread(self->bz_file, buf, count); \n if (bz2_ret < 0) { \n stream->eof = 1; \n return -1; \n } \n if (bz2_ret == 0) { \n stream->eof = 1; \n } \n return (size_t)bz2_ret; \n }",
  "cwe": "CWE-787",
  "codeline": "ret = BZ2_bzread(self->bz_file, buf, count);"
}
{
  "idx": 350,
  "target": 1,
  "vul": "int detach_capi_ctr(struct capi_ctr *ctr) \n { \n int err = 0; \n mutex_lock(&capi_controller_lock); \n ctr_down(ctr, CAPI_CTR_DETACHED); \n if (capi_controller[ctr->cnr - 1] != ctr) { \n err = -EINVAL; \n goto unlock_out; \n } \n capi_controller[ctr->cnr - 1] = NULL; \n ncontrollers--; \n if (ctr->procent) \n remove_proc_entry(ctr->procfn, NULL); \n printk(KERN_NOTICE \"kcapi: controller [%03d]: %s unregistered\\n\", \n ctr->cnr, ctr->name); \n unlock_out: \n mutex_unlock(&capi_controller_lock); \n return err; \n }",
  "no_vul": "int detach_capi_ctr(struct capi_ctr *ctr) \n { \n int err = 0; \n mutex_lock(&capi_controller_lock); \n ctr_down(ctr, CAPI_CTR_DETACHED); \n if (ctr->cnr < 1 || ctr->cnr - 1 >= CAPI_MAXCONTR) { \n err = -EINVAL; \n goto unlock_out; \n } \n if (capi_controller[ctr->cnr - 1] != ctr) { \n err = -EINVAL; \n goto unlock_out; \n } \n capi_controller[ctr->cnr - 1] = NULL; \n ncontrollers--; \n if (ctr->procent) \n remove_proc_entry(ctr->procfn, NULL); \n printk(KERN_NOTICE \"kcapi: controller [%03d]: %s unregistered\\n\", \n ctr->cnr, ctr->name); \n unlock_out: \n mutex_unlock(&capi_controller_lock); \n return err; \n }",
  "cwe": "CWE-125",
  "codeline": "if (capi_controller[ctr->cnr - 1] != ctr) {"
}
{
  "idx": 351,
  "target": 1,
  "vul": "RsaAdjustPrimeCandidate( \n bigNum prime, \n SEED_COMPAT_LEVEL seedCompatLevel \n ) \n { \n switch (seedCompatLevel) { \n case SEED_COMPAT_LEVEL_ORIGINAL: \n RsaAdjustPrimeCandidate_PreRev155(prime); \n break; \n case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX: \n RsaAdjustPrimeCandidate_New(prime); \n break; \n default: \n FAIL(FATAL_ERROR_INTERNAL); \n } \n }",
  "no_vul": "RsaAdjustPrimeCandidate( \n bigNum prime, \n SEED_COMPAT_LEVEL seedCompatLevel \n ) \n { \n switch (seedCompatLevel) { \n case SEED_COMPAT_LEVEL_ORIGINAL: \n RsaAdjustPrimeCandidate_PreRev155(prime); \n break; \n case SEED_COMPAT_LEVEL_LAST: \n RsaAdjustPrimeCandidate_New(prime); \n break; \n default: \n FAIL(FATAL_ERROR_INTERNAL); \n } \n }",
  "cwe": "CWE-331",
  "codeline": "case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX: \n RsaAdjustPrimeCandidate_New(prime); \n break;"
}
{
  "idx": 352,
  "target": 1,
  "vul": "BGD_DECLARE(void *) gdImageBmpPtr(gdImagePtr im, int *size, int compression) \n { \n void *rv; \n gdIOCtx *out = gdNewDynamicCtx(2048, NULL); \n if (out == NULL) return NULL; \n gdImageBmpCtx(im, out, compression); \n rv = gdDPExtractData(out, size); \n out->gd_free(out); \n return rv; \n }",
  "no_vul": "BGD_DECLARE(void *) gdImageBmpPtr(gdImagePtr im, int *size, int compression) \n { \n void *rv; \n gdIOCtx *out = gdNewDynamicCtx(2048, NULL); \n if (out == NULL) return NULL; \n if (!_gdImageBmpCtx(im, out, compression)) \n rv = gdDPExtractData(out, size); \n else \n rv = NULL; \n out->gd_free(out); \n return rv; \n }",
  "cwe": "CWE-415",
  "codeline": "rv = gdDPExtractData(out, size);"
}
{
  "idx": 353,
  "target": 1,
  "vul": "static int do_insn_fetch(struct x86_emulate_ctxt *ctxt, \n struct x86_emulate_ops *ops, \n unsigned long eip, void *dest, unsigned size) \n { \n int rc = 0; \n eip += ctxt->cs_base; \n while (size--) { \n rc = do_fetch_insn_byte(ctxt, ops, eip++, dest++); \n if (rc) \n return rc; \n } \n return 0; \n }",
  "no_vul": "static int do_insn_fetch(struct x86_emulate_ctxt *ctxt, \n struct x86_emulate_ops *ops, \n unsigned long eip, void *dest, unsigned size) \n { \n int rc = 0; \n if (eip + size - ctxt->decode.eip_orig > 15) \n return X86EMUL_UNHANDLEABLE; \n eip += ctxt->cs_base; \n while (size--) { \n rc = do_fetch_insn_byte(ctxt, ops, eip++, dest++); \n if (rc) \n return rc; \n } \n return 0; \n }",
  "cwe": "CWE-20",
  "codeline": "while (size--) { \n rc = do_fetch_insn_byte(ctxt, ops, eip++, dest++); \n if (rc) \n return rc; \n }"
}
{
  "idx": 354,
  "target": 1,
  "vul": "jio_snprintf(char * str, int n, const char * format, ...) \n { \n va_list args; \n int result; \n Trc_SC_snprintf_Entry(); \n va_start(args, format); \n #if defined(WIN32) && !defined(WIN32_IBMC) \n result = _vsnprintf( str, n, format, args ); \n #else \n result = vsprintf( str, format, args ); \n #endif \n va_end(args); \n Trc_SC_snprintf_Exit(result); \n return result; \n }",
  "no_vul": "jio_snprintf(char * str, int n, const char * format, ...) \n { \n va_list args; \n int result; \n Trc_SC_snprintf_Entry(); \n va_start(args, format); \n result = vsnprintf( str, n, format, args ); \n va_end(args); \n Trc_SC_snprintf_Exit(result); \n return result; \n }",
  "cwe": "CWE-119",
  "codeline": "#if defined(WIN32) && !defined(WIN32_IBMC) \nresult = _vsnprintf( str, n, format, args ); \n#else \nresult = vsprintf( str, format, args ); \n#endif"
}
{
  "idx": 355,
  "target": 1,
  "vul": "jio_vsnprintf(char * str, int n, const char * format, va_list args) \n { \n int result; \n Trc_SC_vsnprintf_Entry(str, n, format); \n #if defined(WIN32) && !defined(WIN32_IBMC) \n result = _vsnprintf( str, n, format, args ); \n #else \n result = vsprintf( str, format, args ); \n #endif \n Trc_SC_vsnprintf_Exit(result); \n return result; \n }",
  "no_vul": "jio_vsnprintf(char * str, int n, const char * format, va_list args) \n { \n int result; \n Trc_SC_vsnprintf_Entry(str, n, format); \n result = vsnprintf( str, n, format, args ); \n Trc_SC_vsnprintf_Exit(result); \n return result; \n }",
  "cwe": "CWE-119",
  "codeline": "result = vsprintf( str, format, args );"
}
{
  "idx": 356,
  "target": 1,
  "vul": "_isBidi (const uint32_t *label, size_t llen) \n { \n while (llen-- > 0) { \n int bc = uc_bidi_category (*label++); \n if (bc == UC_BIDI_R || bc == UC_BIDI_AL || bc == UC_BIDI_AN) \n return 1; \n } \n return 0; \n }",
  "no_vul": "_isBidi (const uint32_t *label, size_t llen) \n { \n for (; (ssize_t) llen > 0; llen--) { \n int bc = uc_bidi_category (*label++); \n if (bc == UC_BIDI_R || bc == UC_BIDI_AL || bc == UC_BIDI_AN) \n return 1; \n } \n return 0; \n }",
  "cwe": "CWE-190",
  "codeline": "while (llen-- > 0) {"
}
{
  "idx": 357,
  "target": 1,
  "vul": "BGD_DECLARE(void *) gdImagePngPtr (gdImagePtr im, int *size) \n { \n void *rv; \n gdIOCtx *out = gdNewDynamicCtx (2048, NULL); \n if (out == NULL) return NULL; \n gdImagePngCtxEx (im, out, -1); \n rv = gdDPExtractData (out, size); \n out->gd_free (out); \n return rv; \n }",
  "no_vul": "BGD_DECLARE(void *) gdImagePngPtr (gdImagePtr im, int *size) \n { \n void *rv; \n gdIOCtx *out = gdNewDynamicCtx (2048, NULL); \n if (out == NULL) return NULL; \n if (!_gdImagePngCtxEx (im, out, -1)) { \n rv = gdDPExtractData (out, size); \n } else { \n rv = NULL; \n } \n out->gd_free (out); \n return rv; \n }",
  "cwe": "CWE-415",
  "codeline": "out->gd_free (out);"
}
{
  "idx": 358,
  "target": 1,
  "vul": "static MagickBooleanType WriteMSLImage(const ImageInfo *image_info,Image *image) \n { \n Image \n *msl_image; \n assert(image_info != (const ImageInfo *) NULL); \n assert(image_info->signature == MagickCoreSignature); \n assert(image != (Image *) NULL); \n assert(image->signature == MagickCoreSignature); \n if (image->debug != MagickFalse) \n (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n msl_image=CloneImage(image,0,0,MagickTrue,&image->exception); \n return(ProcessMSLScript(image_info,&msl_image,&image->exception)); \n }",
  "no_vul": "static MagickBooleanType WriteMSLImage(const ImageInfo *image_info,Image *image) \n { \n Image \n *msl_image; \n MagickBooleanType \n status; \n assert(image_info != (const ImageInfo *) NULL); \n assert(image_info->signature == MagickCoreSignature); \n assert(image != (Image *) NULL); \n assert(image->signature == MagickCoreSignature); \n if (image->debug != MagickFalse) \n (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename); \n msl_image=CloneImage(image,0,0,MagickTrue,&image->exception); \n status=ProcessMSLScript(image_info,&msl_image,&image->exception); \n msl_image=DestroyImageList(msl_image); \n return(status); \n }",
  "cwe": "CWE-772",
  "codeline": "msl_image=CloneImage(image,0,0,MagickTrue,&image->exception);"
}
{
  "idx": 359,
  "target": 1,
  "vul": "static int IntensityCompare(const void *x,const void *y) \n { \n PixelPacket \n *color_1, \n *color_2; \n ssize_t \n intensity; \n color_1=(PixelPacket *) x; \n color_2=(PixelPacket *) y; \n intensity=(ssize_t) PixelPacketIntensity(color_1)- \n (ssize_t) PixelPacketIntensity(color_2); \n return((int) intensity); \n }",
  "no_vul": "static int IntensityCompare(const void *x,const void *y) \n { \n PixelPacket \n *color_1, \n *color_2; \n ssize_t \n intensity; \n color_1=(PixelPacket *) x; \n color_2=(PixelPacket *) y; \n intensity=(ssize_t) ConstrainPixelIntensity(PixelPacketIntensity(color_1))- \n (ssize_t) ConstrainPixelIntensity(PixelPacketIntensity(color_2)); \n return((int) intensity); \n }",
  "cwe": "CWE-190",
  "codeline": "intensity=(ssize_t) PixelPacketIntensity(color_1)- (ssize_t) PixelPacketIntensity(color_2);"
}
{
  "idx": 360,
  "target": 1,
  "vul": "regional_create_custom(size_t size) \n { \n struct regional* r = (struct regional*)malloc(size); \n log_assert(sizeof(struct regional) <= size); \n if(!r) return NULL; \n r->first_size = size; \n regional_init(r); \n return r; \n }",
  "no_vul": "regional_create_custom(size_t size) \n { \n struct regional* r = (struct regional*)malloc(size); \n size = ALIGN_UP(size, ALIGNMENT); \n log_assert(sizeof(struct regional) <= size); \n if(!r) return NULL; \n r->first_size = size; \n regional_init(r); \n return r; \n }",
  "cwe": "CWE-190",
  "codeline": "r->first_size = size;"
}
{
  "idx": 361,
  "target": 1,
  "vul": "void ZRtp::storeMsgTemp(ZrtpPacketBase* pkt) { \n int32_t length = pkt->getLength() * ZRTP_WORD_SIZE; \n memset(tempMsgBuffer, 0, sizeof(tempMsgBuffer)); \n memcpy(tempMsgBuffer, (uint8_t*)pkt->getHeaderBase(), length); \n lengthOfMsgData = length; \n }",
  "no_vul": "void ZRtp::storeMsgTemp(ZrtpPacketBase* pkt) { \n uint32_t length = pkt->getLength() * ZRTP_WORD_SIZE; \n length = (length > sizeof(tempMsgBuffer)) ? sizeof(tempMsgBuffer) : length; \n memset(tempMsgBuffer, 0, sizeof(tempMsgBuffer)); \n memcpy(tempMsgBuffer, (uint8_t*)pkt->getHeaderBase(), length); \n lengthOfMsgData = length; \n }",
  "cwe": "CWE-119",
  "codeline": "memcpy(tempMsgBuffer, (uint8_t*)pkt->getHeaderBase(), length);"
}
{
  "idx": 362,
  "target": 1,
  "vul": "int jpc_firstone(int x) \n { \n int n; \n assert(x >= 0); \n n = -1; \n while (x > 0) { \n x >>= 1; \n ++n; \n } \n return n; \n }",
  "no_vul": "int jpc_int_firstone(int x) \n { \n int n; \n assert(x >= 0); \n n = -1; \n while (x > 0) { \n x >>= 1; \n ++n; \n } \n return n; \n }",
  "cwe": "CWE-617",
  "codeline": "The vulnerable code snippet does not contain a line with CWE-617 (Reachable Assertion Violation) because the `assert(x >= 0);` ensures the input is non-negative, and the loop condition `x > 0` prevents infinite looping. However, if the vulnerability were present due to a potential infinite loop or assertion violation, it would likely be in the `while (x > 0)` line, as it could theoretically loop indefinitely if `x` were not properly reduced.\n\nBut based on the provided code, there is no actual vulnerability of CWE-617. Since the non-vulnerable version is identical, the vulnerability cannot be located.\n\nThus, the answer is:  \n`while (x > 0) {`"
}
{
  "idx": 363,
  "target": 1,
  "vul": "void ves_icall_System_Threading_InternalThread_Thread_free_internal (MonoInternalThread *this, HANDLE thread) \n { \n MONO_ARCH_SAVE_REGS; \n THREAD_DEBUG (g_message (\"%s: Closing thread %p, handle %p\", __func__, this, thread)); \n if (thread) \n CloseHandle (thread); \n if (this->synch_cs) { \n DeleteCriticalSection (this->synch_cs); \n g_free (this->synch_cs); \n this->synch_cs = NULL; \n } \n g_free (this->name); \n }",
  "no_vul": "void ves_icall_System_Threading_InternalThread_Thread_free_internal (MonoInternalThread *this, HANDLE thread) \n { \n MONO_ARCH_SAVE_REGS; \n THREAD_DEBUG (g_message (\"%s: Closing thread %p, handle %p\", __func__, this, thread)); \n if (thread) \n CloseHandle (thread); \n if (this->synch_cs) { \n CRITICAL_SECTION *synch_cs = this->synch_cs; \n this->synch_cs = NULL; \n DeleteCriticalSection (synch_cs); \n g_free (synch_cs); \n } \n if (this->name) { \n void *name = this->name; \n this->name = NULL; \n g_free (name); \n } \n }",
  "cwe": "CWE-264",
  "codeline": "if (this->synch_cs) { \n DeleteCriticalSection (this->synch_cs); \n g_free (this->synch_cs); \n this->synch_cs = NULL; \n }"
}
{
  "idx": 364,
  "target": 1,
  "vul": "static int __init cpia2_init(void) \n { \n LOG(\"%s v%s\\n\", \n ABOUT, CPIA_VERSION); \n check_parameters(); \n cpia2_usb_init(); \n return 0; \n }",
  "no_vul": "static int __init cpia2_init(void) \n { \n LOG(\"%s v%s\\n\", \n ABOUT, CPIA_VERSION); \n check_parameters(); \n return cpia2_usb_init(); \n }",
  "cwe": "CWE-416",
  "codeline": "cpia2_usb_init();"
}
{
  "idx": 365,
  "target": 1,
  "vul": "GIT_INLINE(bool) only_spaces_and_dots(const char *path) \n { \n const char *c = path; \n for (;; c++) { \n if (*c == '\\0') \n return true; \n if (*c != ' ' && *c != '.') \n return false; \n } \n return true; \n }",
  "no_vul": "GIT_INLINE(bool) only_spaces_and_dots(const char *path) \n { \n const char *c = path; \n for (;; c++) { \n if (*c == '\\0' || *c == ':') \n return true; \n if (*c != ' ' && *c != '.') \n return false; \n } \n return true; \n }",
  "cwe": "CWE-20",
  "codeline": "if (*c == '\\0') \nreturn true;"
}
{
  "idx": 366,
  "target": 1,
  "vul": "static inline void CheckEventLogging() \n { \n if (IsLinkedListEmpty(log_cache) != MagickFalse) \n event_logging=MagickFalse; \n else \n { \n LogInfo \n *p; \n ResetLinkedListIterator(log_cache); \n p=(LogInfo *) GetNextValueInLinkedList(log_cache); \n event_logging=p->event_mask != NoEvents ? MagickTrue: MagickFalse; \n } \n }",
  "no_vul": "static inline void CheckEventLogging() \n { \n if (IsLinkedListEmpty(log_cache) != MagickFalse) \n event_logging=MagickFalse; \n else \n { \n LogInfo \n *p; \n ResetLinkedListIterator(log_cache); \n p=(LogInfo *) GetNextValueInLinkedList(log_cache); \n event_logging=(p != (LogInfo *) NULL) && (p->event_mask != NoEvents) ? \n MagickTrue: MagickFalse; \n } \n }",
  "cwe": "CWE-476",
  "codeline": "p=(LogInfo *) GetNextValueInLinkedList(log_cache);"
}
{
  "idx": 367,
  "target": 1,
  "vul": "bool EmbFile::save2(FILE *f) { \n int c; \n m_objStr.streamReset(); \n while ((c = m_objStr.streamGetChar()) != EOF) { \n fputc(c, f); \n } \n return true; \n }",
  "no_vul": "bool EmbFile::save2(FILE *f) { \n int c; \n if (unlikely(!m_objStr.isStream())) \n return false; \n m_objStr.streamReset(); \n while ((c = m_objStr.streamGetChar()) != EOF) { \n fputc(c, f); \n } \n return true; \n }",
  "cwe": "CWE-670",
  "codeline": "while ((c = m_objStr.streamGetChar()) != EOF) {"
}
{
  "idx": 368,
  "target": 1,
  "vul": "int SafeMulDims(const matvar_t *matvar, size_t* nelems) \n { \n int i; \n for ( i = 0; i < matvar->rank; i++ ) { \n if ( !psnip_safe_size_mul(nelems, *nelems, matvar->dims[i]) ) { \n *nelems = 0; \n return 1; \n } \n } \n return 0; \n }",
  "no_vul": "int SafeMulDims(const matvar_t *matvar, size_t* nelems) \n { \n int i; \n if ( matvar->rank == 0 ) { \n *nelems = 0; \n return 0; \n } \n for ( i = 0; i < matvar->rank; i++ ) { \n if ( !psnip_safe_size_mul(nelems, *nelems, matvar->dims[i]) ) { \n *nelems = 0; \n return 1; \n } \n } \n return 0; \n }",
  "cwe": "CWE-401",
  "codeline": "if ( !psnip_safe_size_mul(nelems, *nelems, matvar->dims[i]) ) {"
}
{
  "idx": 369,
  "target": 1,
  "vul": "int qemu_can_send_packet(NetClientState *sender) \n { \n int vm_running = runstate_is_running(); \n if (!vm_running) { \n return 0; \n } \n if (!sender->peer) { \n return 1; \n } \n if (sender->peer->receive_disabled) { \n return 0; \n } else if (sender->peer->info->can_receive && \n !sender->peer->info->can_receive(sender->peer)) { \n return 0; \n } \n return 1; \n }",
  "no_vul": "int qemu_can_send_packet(NetClientState *sender) \n { \n int vm_running = runstate_is_running(); \n if (!vm_running) { \n return 0; \n } \n if (!sender->peer) { \n return 1; \n } \n return qemu_can_receive_packet(sender->peer); \n }",
  "cwe": "CWE-835",
  "codeline": "if (sender->peer->info->can_receive && \n !sender->peer->info->can_receive(sender->peer)) { \n return 0; \n }"
}
{
  "idx": 370,
  "target": 1,
  "vul": "nwfilterConnectNumOfNWFilters(virConnectPtr conn) \n { \n if (virConnectNumOfNWFiltersEnsureACL(conn) < 0) \n return -1; \n return virNWFilterObjListNumOfNWFilters(driver->nwfilters, conn, \n virConnectNumOfNWFiltersCheckACL); \n }",
  "no_vul": "nwfilterConnectNumOfNWFilters(virConnectPtr conn) \n { \n int ret; \n if (virConnectNumOfNWFiltersEnsureACL(conn) < 0) \n return -1; \n nwfilterDriverLock(); \n ret = virNWFilterObjListNumOfNWFilters(driver->nwfilters, conn, \n virConnectNumOfNWFiltersCheckACL); \n nwfilterDriverUnlock(); \n return ret; \n }",
  "cwe": "CWE-667",
  "codeline": "if (virConnectNumOfNWFiltersEnsureACL(conn) < 0) \nreturn -1;"
}
{
  "idx": 371,
  "target": 1,
  "vul": "int Dispatcher::getparam( size_t N, int defaultval ) \n { \n int ret = defaultval; \n if ( !parsed ) { \n parse_params(); \n } \n if ( parsed_params.size() > N ) { \n ret = parsed_params[ N ]; \n } \n if ( ret < 1 ) ret = defaultval; \n return ret; \n }",
  "no_vul": "int Dispatcher::getparam( size_t N, int defaultval ) \n { \n int ret = defaultval; \n if ( !parsed ) { \n parse_params(); \n } \n if ( parsed_params.size() > N ) { \n ret = parsed_params[ N ]; \n } \n if ( ret > PARAM_MAX ) { \n ret = defaultval; \n } \n if ( ret < 1 ) ret = defaultval; \n return ret; \n }",
  "cwe": "CWE-399",
  "codeline": "if ( ret < 1 ) ret = defaultval;"
}
{
  "idx": 372,
  "target": 1,
  "vul": "void SoundTouch::setChannels(uint numChannels) \n { \n channels = numChannels; \n pRateTransposer->setChannels((int)numChannels); \n pTDStretch->setChannels((int)numChannels); \n }",
  "no_vul": "void SoundTouch::setChannels(uint numChannels) \n { \n if (!verifyNumberOfChannels(numChannels)) return; \n channels = numChannels; \n pRateTransposer->setChannels((int)numChannels); \n pTDStretch->setChannels((int)numChannels); \n }",
  "cwe": "CWE-617",
  "codeline": "channels = numChannels;"
}
{
  "idx": 373,
  "target": 1,
  "vul": "void RateTransposer::setChannels(int nChannels) \n { \n assert(nChannels > 0); \n if (pTransposer->numChannels == nChannels) return; \n pTransposer->setChannels(nChannels); \n inputBuffer.setChannels(nChannels); \n midBuffer.setChannels(nChannels); \n outputBuffer.setChannels(nChannels); \n }",
  "no_vul": "void RateTransposer::setChannels(int nChannels) \n { \n if (!verifyNumberOfChannels(nChannels) || \n (pTransposer->numChannels == nChannels)) return; \n pTransposer->setChannels(nChannels); \n inputBuffer.setChannels(nChannels); \n midBuffer.setChannels(nChannels); \n outputBuffer.setChannels(nChannels); \n }",
  "cwe": "CWE-617",
  "codeline": "assert(nChannels > 0);"
}
{
  "idx": 374,
  "target": 1,
  "vul": "void FIFOSampleBuffer::setChannels(int numChannels) \n { \n uint usedBytes; \n assert(numChannels > 0); \n usedBytes = channels * samplesInBuffer; \n channels = (uint)numChannels; \n samplesInBuffer = usedBytes / channels; \n }",
  "no_vul": "void FIFOSampleBuffer::setChannels(int numChannels) \n { \n uint usedBytes; \n if (!verifyNumberOfChannels(numChannels)) return; \n usedBytes = channels * samplesInBuffer; \n channels = (uint)numChannels; \n samplesInBuffer = usedBytes / channels; \n }",
  "cwe": "CWE-617",
  "codeline": "assert(numChannels > 0);"
}
{
  "idx": 375,
  "target": 1,
  "vul": "void TDStretch::setChannels(int numChannels) \n { \n assert(numChannels > 0); \n if (channels == numChannels) return; \n channels = numChannels; \n inputBuffer.setChannels(channels); \n outputBuffer.setChannels(channels); \n overlapLength=0; \n setParameters(sampleRate); \n }",
  "no_vul": "void TDStretch::setChannels(int numChannels) \n { \n if (!verifyNumberOfChannels(numChannels) || \n (channels == numChannels)) return; \n channels = numChannels; \n inputBuffer.setChannels(channels); \n outputBuffer.setChannels(channels); \n overlapLength=0; \n setParameters(sampleRate); \n }",
  "cwe": "CWE-617",
  "codeline": "assert(numChannels > 0);"
}
{
  "idx": 376,
  "target": 1,
  "vul": "static inline void native_set_ldt(const void *addr, unsigned int entries) \n { \n if (likely(entries == 0)) \n asm volatile(\"lldt %w0\"::\"q\" (0)); \n else { \n unsigned cpu = smp_processor_id(); \n ldt_desc ldt; \n set_tssldt_descriptor(&ldt, (unsigned long)addr, \n DESC_LDT, entries * sizeof(ldt) - 1); \n write_gdt_entry(get_cpu_gdt_table(cpu), GDT_ENTRY_LDT, \n &ldt, DESC_LDT); \n asm volatile(\"lldt %w0\"::\"q\" (GDT_ENTRY_LDT*8)); \n } \n }",
  "no_vul": "static inline void native_set_ldt(const void *addr, unsigned int entries) \n { \n if (likely(entries == 0)) \n asm volatile(\"lldt %w0\"::\"q\" (0)); \n else { \n unsigned cpu = smp_processor_id(); \n ldt_desc ldt; \n set_tssldt_descriptor(&ldt, (unsigned long)addr, DESC_LDT, \n entries * LDT_ENTRY_SIZE - 1); \n write_gdt_entry(get_cpu_gdt_table(cpu), GDT_ENTRY_LDT, \n &ldt, DESC_LDT); \n asm volatile(\"lldt %w0\"::\"q\" (GDT_ENTRY_LDT*8)); \n } \n }",
  "cwe": "CWE-119",
  "codeline": "entries * sizeof(ldt) - 1"
}
{
  "idx": 377,
  "target": 1,
  "vul": "static long do_splice_from(struct pipe_inode_info *pipe, struct file *out, \n loff_t *ppos, size_t len, unsigned int flags) \n { \n int ret; \n if (unlikely(!out->f_op || !out->f_op->splice_write)) \n return -EINVAL; \n if (unlikely(!(out->f_mode & FMODE_WRITE))) \n return -EBADF; \n ret = rw_verify_area(WRITE, out, ppos, len); \n if (unlikely(ret < 0)) \n return ret; \n return out->f_op->splice_write(pipe, out, ppos, len, flags); \n }",
  "no_vul": "static long do_splice_from(struct pipe_inode_info *pipe, struct file *out, \n loff_t *ppos, size_t len, unsigned int flags) \n { \n int ret; \n if (unlikely(!out->f_op || !out->f_op->splice_write)) \n return -EINVAL; \n if (unlikely(!(out->f_mode & FMODE_WRITE))) \n return -EBADF; \n if (unlikely(out->f_flags & O_APPEND)) \n return -EINVAL; \n ret = rw_verify_area(WRITE, out, ppos, len); \n if (unlikely(ret < 0)) \n return ret; \n return out->f_op->splice_write(pipe, out, ppos, len, flags); \n }",
  "cwe": "CWE-264",
  "codeline": "if (unlikely(out->f_flags & O_APPEND)) \nreturn -EINVAL;"
}
{
  "idx": 378,
  "target": 1,
  "vul": "static inline loff_t ext4_isize(struct ext4_inode *raw_inode) \n { \n return ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) | \n le32_to_cpu(raw_inode->i_size_lo);",
  "no_vul": "static inline loff_t ext4_isize(struct ext4_inode *raw_inode) \n { \n if (S_ISREG(le16_to_cpu(raw_inode->i_mode))) \n return ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) | \n le32_to_cpu(raw_inode->i_size_lo); \n else \n return (loff_t) le32_to_cpu(raw_inode->i_size_lo);",
  "cwe": "CWE-399",
  "codeline": "return ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) | le32_to_cpu(raw_inode->i_size_lo);"
}
{
  "idx": 379,
  "target": 1,
  "vul": "static int raw_getname(struct socket *sock, struct sockaddr *uaddr, \n int *len, int peer) \n { \n struct sockaddr_can *addr = (struct sockaddr_can *)uaddr; \n struct sock *sk = sock->sk; \n struct raw_sock *ro = raw_sk(sk); \n if (peer) \n return -EOPNOTSUPP; \n addr->can_family = AF_CAN; \n addr->can_ifindex = ro->ifindex; \n *len = sizeof(*addr); \n return 0; \n }",
  "no_vul": "static int raw_getname(struct socket *sock, struct sockaddr *uaddr, \n int *len, int peer) \n { \n struct sockaddr_can *addr = (struct sockaddr_can *)uaddr; \n struct sock *sk = sock->sk; \n struct raw_sock *ro = raw_sk(sk); \n if (peer) \n return -EOPNOTSUPP; \n memset(addr, 0, sizeof(*addr)); \n addr->can_family = AF_CAN; \n addr->can_ifindex = ro->ifindex; \n *len = sizeof(*addr); \n return 0; \n }",
  "cwe": "CWE-200",
  "codeline": "struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;"
}
{
  "idx": 380,
  "target": 1,
  "vul": "static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl) \n { \n unsigned char *b = skb->tail; \n struct tc_cbq_ovl opt; \n opt.strategy = cl->ovl_strategy; \n opt.priority2 = cl->priority2+1; \n opt.penalty = (cl->penalty*1000)/HZ; \n RTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt); \n return skb->len; \n rtattr_failure: \n skb_trim(skb, b - skb->data); \n return -1; \n }",
  "no_vul": "static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl) \n { \n unsigned char *b = skb->tail; \n struct tc_cbq_ovl opt; \n opt.strategy = cl->ovl_strategy; \n opt.priority2 = cl->priority2+1; \n opt.pad = 0; \n opt.penalty = (cl->penalty*1000)/HZ; \n RTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt); \n return skb->len; \n rtattr_failure: \n skb_trim(skb, b - skb->data); \n return -1; \n }",
  "cwe": "CWE-200",
  "codeline": "opt.penalty = (cl->penalty*1000)/HZ;"
}
{
  "idx": 381,
  "target": 1,
  "vul": "static void ipmr_destroy_unres(struct mfc_cache *c) \n { \n struct sk_buff *skb; \n atomic_dec(&cache_resolve_queue_len); \n while((skb=skb_dequeue(&c->mfc_un.unres.unresolved))) { \n if (skb->nh.iph->version == 0) { \n struct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct iphdr)); \n nlh->nlmsg_type = NLMSG_ERROR; \n nlh->nlmsg_len = NLMSG_LENGTH(sizeof(struct nlmsgerr)); \n skb_trim(skb, nlh->nlmsg_len); \n ((struct nlmsgerr*)NLMSG_DATA(nlh))->error = -ETIMEDOUT; \n netlink_unicast(rtnl, skb, NETLINK_CB(skb).dst_pid, MSG_DONTWAIT); \n } else \n kfree_skb(skb); \n } \n kmem_cache_free(mrt_cachep, c); \n }",
  "no_vul": "static void ipmr_destroy_unres(struct mfc_cache *c) \n { \n struct sk_buff *skb; \n struct nlmsgerr *e; \n atomic_dec(&cache_resolve_queue_len); \n while((skb=skb_dequeue(&c->mfc_un.unres.unresolved))) { \n if (skb->nh.iph->version == 0) { \n struct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct iphdr)); \n nlh->nlmsg_type = NLMSG_ERROR; \n nlh->nlmsg_len = NLMSG_LENGTH(sizeof(struct nlmsgerr)); \n skb_trim(skb, nlh->nlmsg_len); \n e = NLMSG_DATA(nlh); \n e->error = -ETIMEDOUT; \n memset(&e->msg, 0, sizeof(e->msg)); \n netlink_unicast(rtnl, skb, NETLINK_CB(skb).dst_pid, MSG_DONTWAIT); \n } else \n kfree_skb(skb); \n } \n kmem_cache_free(mrt_cachep, c); \n }",
  "cwe": "CWE-200",
  "codeline": "((struct nlmsgerr*)NLMSG_DATA(nlh))->error = -ETIMEDOUT;"
}
{
  "idx": 382,
  "target": 1,
  "vul": "__rta_reserve(struct sk_buff *skb, int attrtype, int attrlen) \n { \n struct rtattr *rta; \n int size = RTA_LENGTH(attrlen); \n rta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size)); \n rta->rta_type = attrtype; \n rta->rta_len = size; \n return rta; \n }",
  "no_vul": "__rta_reserve(struct sk_buff *skb, int attrtype, int attrlen) \n { \n struct rtattr *rta; \n int size = RTA_LENGTH(attrlen); \n rta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size)); \n rta->rta_type = attrtype; \n rta->rta_len = size; \n memset(RTA_DATA(rta) + attrlen, 0, RTA_ALIGN(size) - size); \n return rta; \n }",
  "cwe": "CWE-200",
  "codeline": "rta->rta_len = size;"
}
{
  "idx": 383,
  "target": 1,
  "vul": "void __rta_fill(struct sk_buff *skb, int attrtype, int attrlen, const void *data) \n { \n struct rtattr *rta; \n int size = RTA_LENGTH(attrlen); \n rta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size)); \n rta->rta_type = attrtype; \n rta->rta_len = size; \n memcpy(RTA_DATA(rta), data, attrlen); \n }",
  "no_vul": "__rta_reserve(struct sk_buff *skb, int attrtype, int attrlen) \n { \n struct rtattr *rta; \n int size = RTA_LENGTH(attrlen); \n rta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size)); \n rta->rta_type = attrtype; \n rta->rta_len = size; \n memset(RTA_DATA(rta) + attrlen, 0, RTA_ALIGN(size) - size); \n return rta; \n }",
  "cwe": "CWE-200",
  "codeline": "memcpy(RTA_DATA(rta), data, attrlen);"
}
{
  "idx": 384,
  "target": 1,
  "vul": "__nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags) \n { \n struct nlmsghdr *nlh; \n int size = NLMSG_LENGTH(len); \n nlh = (struct nlmsghdr*)skb_put(skb, NLMSG_ALIGN(size)); \n nlh->nlmsg_type = type; \n nlh->nlmsg_len = size; \n nlh->nlmsg_flags = flags; \n nlh->nlmsg_pid = pid; \n nlh->nlmsg_seq = seq; \n return nlh; \n }",
  "no_vul": "__nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags) \n { \n struct nlmsghdr *nlh; \n int size = NLMSG_LENGTH(len); \n nlh = (struct nlmsghdr*)skb_put(skb, NLMSG_ALIGN(size)); \n nlh->nlmsg_type = type; \n nlh->nlmsg_len = size; \n nlh->nlmsg_flags = flags; \n nlh->nlmsg_pid = pid; \n nlh->nlmsg_seq = seq; \n memset(NLMSG_DATA(nlh) + len, 0, NLMSG_ALIGN(size) - size); \n return nlh; \n }",
  "cwe": "CWE-200",
  "codeline": "nlh = (struct nlmsghdr*)skb_put(skb, NLMSG_ALIGN(size));"
}
{
  "idx": 385,
  "target": 1,
  "vul": "xfs_ioc_fsgeometry_v1( \n xfs_mount_t *mp, \n void __user *arg) \n { \n xfs_fsop_geom_v1_t fsgeo; \n int error; \n error = xfs_fs_geometry(mp, (xfs_fsop_geom_t *)&fsgeo, 3); \n if (error) \n return -error; \n if (copy_to_user(arg, &fsgeo, sizeof(fsgeo))) \n return -XFS_ERROR(EFAULT); \n return 0; \n }",
  "no_vul": "xfs_ioc_fsgeometry( \n xfs_mount_t *mp, \n void __user *arg) \n { \n xfs_fsop_geom_t fsgeo; \n int error; \n error = xfs_fs_geometry(mp, &fsgeo, 4); \n if (error) \n return -error; \n if (copy_to_user(arg, &fsgeo, sizeof(fsgeo))) \n return -XFS_ERROR(EFAULT); \n return 0; \n }",
  "cwe": "CWE-200",
  "codeline": "error = xfs_fs_geometry(mp, (xfs_fsop_geom_t *)&fsgeo, 3);"
}
{
  "idx": 386,
  "target": 1,
  "vul": "static struct kmem_cache *ccid_kmem_cache_create(int obj_size, char *slab_name_fmt, const char *fmt,...) \n { \n struct kmem_cache *slab; \n va_list args; \n va_start(args, fmt); \n vsnprintf(slab_name_fmt, sizeof(slab_name_fmt), fmt, args); \n va_end(args); \n slab = kmem_cache_create(slab_name_fmt, sizeof(struct ccid) + obj_size, 0, \n SLAB_HWCACHE_ALIGN, NULL); \n return slab; \n }",
  "no_vul": "static struct kmem_cache *ccid_kmem_cache_create(int obj_size, char *slab_name_fmt, const char *fmt,...) \n { \n struct kmem_cache *slab; \n va_list args; \n va_start(args, fmt); \n vsnprintf(slab_name_fmt, CCID_SLAB_NAME_LENGTH, fmt, args); \n va_end(args); \n slab = kmem_cache_create(slab_name_fmt, sizeof(struct ccid) + obj_size, 0, \n SLAB_HWCACHE_ALIGN, NULL); \n return slab; \n }",
  "cwe": "CWE-476",
  "codeline": "vsnprintf(slab_name_fmt, sizeof(slab_name_fmt), fmt, args);"
}
{
  "idx": 387,
  "target": 1,
  "vul": "static void virtio_blk_handle_read(VirtIOBlockReq *req) \n { \n BlockDriverAIOCB *acb; \n uint64_t sector; \n sector = ldq_p(&req->out->sector); \n if (sector & req->dev->sector_mask) { \n virtio_blk_rw_complete(req, -EIO); \n return; \n } \n acb = bdrv_aio_readv(req->dev->bs, sector, &req->qiov, \n req->qiov.size / BDRV_SECTOR_SIZE, \n virtio_blk_rw_complete, req); \n if (!acb) { \n virtio_blk_rw_complete(req, -EIO); \n } \n }",
  "no_vul": "static void virtio_blk_handle_read(VirtIOBlockReq *req) \n { \n BlockDriverAIOCB *acb; \n uint64_t sector; \n sector = ldq_p(&req->out->sector); \n if (sector & req->dev->sector_mask) { \n virtio_blk_rw_complete(req, -EIO); \n return; \n } \n if (req->qiov.size % req->dev->conf->logical_block_size) { \n virtio_blk_rw_complete(req, -EIO); \n return; \n } \n acb = bdrv_aio_readv(req->dev->bs, sector, &req->qiov, \n req->qiov.size / BDRV_SECTOR_SIZE, \n virtio_blk_rw_complete, req); \n if (!acb) { \n virtio_blk_rw_complete(req, -EIO); \n } \n }",
  "cwe": "CWE-119",
  "codeline": "if (sector & req->dev->sector_mask) {"
}
{
  "idx": 388,
  "target": 1,
  "vul": "rfbProcessClientMessage(rfbClientPtr cl) \n { \n switch (cl->state) { \n case RFB_PROTOCOL_VERSION: \n rfbProcessClientProtocolVersion(cl); \n return; \n case RFB_SECURITY_TYPE: \n rfbAuthProcessSecurityTypeMessage(cl); \n return; \n #ifdef VINO_HAVE_GNUTLS \n case RFB_TLS_HANDSHAKE: \n rfbAuthProcessTLSHandshake(cl); \n return; \n #endif \n case RFB_AUTH_TYPE: \n rfbAuthProcessAuthTypeMessage(cl); \n return; \n case RFB_AUTHENTICATION: \n rfbAuthProcessClientMessage(cl); \n return; \n case RFB_AUTH_DEFERRED: \n rfbLog(\"Authentication deferred - ignoring client message\\n\"); \n return; \n case RFB_INITIALISATION: \n rfbProcessClientInitMessage(cl); \n return; \n default: \n rfbProcessClientNormalMessage(cl); \n return; \n } \n }",
  "no_vul": "rfbProcessClientMessage(rfbClientPtr cl) \n { \n switch (cl->state) { \n case RFB_PROTOCOL_VERSION: \n rfbProcessClientProtocolVersion(cl); \n return; \n case RFB_SECURITY_TYPE: \n rfbAuthProcessSecurityTypeMessage(cl); \n return; \n #ifdef VINO_HAVE_GNUTLS \n case RFB_TLS_HANDSHAKE: \n rfbAuthProcessTLSHandshake(cl); \n return; \n #endif \n case RFB_AUTH_TYPE: \n rfbAuthProcessAuthTypeMessage(cl); \n return; \n case RFB_AUTHENTICATION: \n rfbAuthProcessClientMessage(cl); \n return; \n case RFB_AUTH_DEFERRED: \n rfbLog(\"Authentication deferred for this client - closing connection\\n\"); \n rfbCloseClient(cl); \n return; \n case RFB_INITIALISATION: \n rfbProcessClientInitMessage(cl); \n return; \n default: \n rfbProcessClientNormalMessage(cl); \n return; \n } \n }",
  "cwe": "CWE-20",
  "codeline": "rfbLog(\"Authentication deferred - ignoring client message\\n\");"
}
{
  "idx": 389,
  "target": 1,
  "vul": "static void aes_ctr_cleanup(struct ssh_cipher_struct *cipher){ \n explicit_bzero(cipher->aes_key, sizeof(*cipher->aes_key)); \n SAFE_FREE(cipher->aes_key); \n }",
  "no_vul": "static void aes_ctr_cleanup(struct ssh_cipher_struct *cipher){ \n if (cipher != NULL) { \n if (cipher->aes_key != NULL) { \n explicit_bzero(cipher->aes_key, sizeof(*cipher->aes_key)); \n } \n SAFE_FREE(cipher->aes_key); \n } \n }",
  "cwe": "CWE-476",
  "codeline": "explicit_bzero(cipher->aes_key, sizeof(*cipher->aes_key));"
}
{
  "idx": 390,
  "target": 1,
  "vul": "void dtls1_reset_seq_numbers(SSL *s, int rw) \n { \n unsigned char *seq; \n unsigned int seq_bytes = sizeof(s->s3->read_sequence); \n if (rw & SSL3_CC_READ) { \n seq = s->s3->read_sequence; \n s->d1->r_epoch++; \n memcpy(&(s->d1->bitmap), &(s->d1->next_bitmap), sizeof(DTLS1_BITMAP)); \n memset(&(s->d1->next_bitmap), 0x00, sizeof(DTLS1_BITMAP)); \n } else { \n seq = s->s3->write_sequence; \n memcpy(s->d1->last_write_sequence, seq, \n sizeof(s->s3->write_sequence)); \n s->d1->w_epoch++; \n } \n memset(seq, 0x00, seq_bytes); \n }",
  "no_vul": "void dtls1_reset_seq_numbers(SSL *s, int rw) \n { \n unsigned char *seq; \n unsigned int seq_bytes = sizeof(s->s3->read_sequence); \n if (rw & SSL3_CC_READ) { \n seq = s->s3->read_sequence; \n s->d1->r_epoch++; \n memcpy(&(s->d1->bitmap), &(s->d1->next_bitmap), sizeof(DTLS1_BITMAP)); \n memset(&(s->d1->next_bitmap), 0x00, sizeof(DTLS1_BITMAP)); \n dtls1_clear_received_buffer(s); \n } else { \n seq = s->s3->write_sequence; \n memcpy(s->d1->last_write_sequence, seq, \n sizeof(s->s3->write_sequence)); \n s->d1->w_epoch++; \n } \n memset(seq, 0x00, seq_bytes); \n }",
  "cwe": "CWE-399",
  "codeline": "memset(&(s->d1->next_bitmap), 0x00, sizeof(DTLS1_BITMAP));"
}
{
  "idx": 391,
  "target": 1,
  "vul": "static void mysql_prune_stmt_list(MYSQL *mysql) \n { \n LIST *element= mysql->stmts; \n LIST *pruned_list= 0; \n for (; element; element= element->next) \n { \n MYSQL_STMT *stmt= (MYSQL_STMT *) element->data; \n if (stmt->state != MYSQL_STMT_INIT_DONE) \n { \n stmt->mysql= 0; \n stmt->last_errno= CR_SERVER_LOST; \n strmov(stmt->last_error, ER(CR_SERVER_LOST)); \n strmov(stmt->sqlstate, unknown_sqlstate); \n } \n else \n { \n pruned_list= list_add(pruned_list, element); \n } \n } \n mysql->stmts= pruned_list; \n }",
  "no_vul": "static void mysql_prune_stmt_list(MYSQL *mysql) \n { \n LIST *element= mysql->stmts; \n for (; element; element= element->next) \n { \n MYSQL_STMT *stmt= (MYSQL_STMT *) element->data; \n if (stmt->state != MYSQL_STMT_INIT_DONE) \n { \n stmt->mysql= 0; \n stmt->last_errno= CR_SERVER_LOST; \n strmov(stmt->last_error, ER(CR_SERVER_LOST)); \n strmov(stmt->sqlstate, unknown_sqlstate); \n mysql->stmts= list_delete(mysql->stmts, element); \n } \n } \n }",
  "cwe": "CWE-416",
  "codeline": "LIST *pruned_list= 0;"
}
{
  "idx": 392,
  "target": 1,
  "vul": "DECLAREContigPutFunc(putagreytile) \n { \n int samplesperpixel = img->samplesperpixel; \n uint32** BWmap = img->BWmap; \n (void) y; \n while (h-- > 0) { \n for (x = w; x-- > 0;) \n { \n *cp++ = BWmap[*pp][0] & (*(pp+1) << 24 | ~A1); \n pp += samplesperpixel; \n } \n cp += toskew; \n pp += fromskew; \n } \n }",
  "no_vul": "DECLAREContigPutFunc(putagreytile) \n { \n int samplesperpixel = img->samplesperpixel; \n uint32** BWmap = img->BWmap; \n (void) y; \n while (h-- > 0) { \n for (x = w; x-- > 0;) \n { \n *cp++ = BWmap[*pp][0] & ((uint32)*(pp+1) << 24 | ~A1); \n pp += samplesperpixel; \n } \n cp += toskew; \n pp += fromskew; \n } \n }",
  "cwe": "CWE-20",
  "codeline": "*cp++ = BWmap[*pp][0] & (*(pp+1) << 24 | ~A1);"
}
{
  "idx": 393,
  "target": 1,
  "vul": "void SimpleModule::runPull() \n { \n pull(m_outChunk->frameCount); \n run(*m_inChunk, *m_outChunk); \n }",
  "no_vul": "void SimpleModule::runPull() \n { \n pull(m_outChunk->frameCount); \n m_outChunk->frameCount = m_inChunk->frameCount; \n run(*m_inChunk, *m_outChunk); \n }",
  "cwe": "CWE-787",
  "codeline": "pull(m_outChunk->frameCount);"
}
{
  "idx": 394,
  "target": 1,
  "vul": "static int init_sig_algs(SSL *s, unsigned int context) \n { \n OPENSSL_free(s->s3->tmp.peer_sigalgs); \n s->s3->tmp.peer_sigalgs = NULL; \n return 1; \n }",
  "no_vul": "static int init_sig_algs_cert(SSL *s, unsigned int context) \n { \n OPENSSL_free(s->s3->tmp.peer_cert_sigalgs); \n s->s3->tmp.peer_cert_sigalgs = NULL; \n return 1; \n }",
  "cwe": "CWE-476",
  "codeline": "OPENSSL_free(s->s3->tmp.peer_sigalgs);"
}
{
  "idx": 395,
  "target": 1,
  "vul": "void* chk_malloc(size_t bytes) \n { \n char* buffer = (char*)dlmalloc(bytes + CHK_OVERHEAD_SIZE); \n if (buffer) { \n memset(buffer, CHK_SENTINEL_VALUE, bytes + CHK_OVERHEAD_SIZE); \n size_t offset = dlmalloc_usable_size(buffer) - sizeof(size_t); \n *(size_t *)(buffer + offset) = bytes; \n buffer += CHK_SENTINEL_HEAD_SIZE; \n } \n return buffer; \n }",
  "no_vul": "void* chk_malloc(size_t bytes) \n { \n size_t size = bytes + CHK_OVERHEAD_SIZE; \n if (size < bytes) { \n return NULL; \n } \n uint8_t* buffer = (uint8_t*) dlmalloc(size); \n if (buffer) { \n memset(buffer, CHK_SENTINEL_VALUE, bytes + CHK_OVERHEAD_SIZE); \n size_t offset = dlmalloc_usable_size(buffer) - sizeof(size_t); \n *(size_t *)(buffer + offset) = bytes; \n buffer += CHK_SENTINEL_HEAD_SIZE; \n } \n return buffer; \n }",
  "cwe": "CWE-189",
  "codeline": "char* buffer = (char*)dlmalloc(bytes + CHK_OVERHEAD_SIZE);"
}
{
  "idx": 396,
  "target": 1,
  "vul": "NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedpcalloc(nedpool *p, size_t no, size_t size) THROWSPEC \n { \n unsigned flags=NEDMALLOC_FORCERESERVE(p, 0, no*size); \n return nedpmalloc2(p, size*no, 0, M2_ZERO_MEMORY|flags); \n }",
  "no_vul": "NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedpmalloc(nedpool *p, size_t size) THROWSPEC \n { \n unsigned flags=NEDMALLOC_FORCERESERVE(p, 0, size); \n return nedpmalloc2(p, size, 0, flags); \n }",
  "cwe": "CWE-189",
  "codeline": "return nedpmalloc2(p, size*no, 0, M2_ZERO_MEMORY|flags);"
}
{
  "idx": 397,
  "target": 1,
  "vul": "static char x2c(char *hex) { \n register char digit; \n digit = ((hex[0] >= 'A') ? ((hex[0] & 0xdf) - 'A')+10 : (hex[0] - '0')); \n digit *= 16; \n digit += (hex[1] >= 'A' ? ((hex[1] & 0xdf) - 'A')+10 : (hex[1] - '0')); \n return(digit); \n }",
  "no_vul": "static char _x2c(char *hex) { \n register char digit; \n digit = ((hex[0] >= 'A') ? ((hex[0] & 0xdf) - 'A')+10 : (hex[0] - '0')); \n digit *= 16; \n digit += (hex[1] >= 'A' ? ((hex[1] & 0xdf) - 'A')+10 : (hex[1] - '0')); \n return(digit); \n }",
  "cwe": "CWE-125",
  "codeline": "The vulnerability is in the line: `digit = ((hex[0] >= 'A') ? ((hex[0] & 0xdf) - 'A')+10 : (hex[0] - '0'));`"
}
{
  "idx": 398,
  "target": 1,
  "vul": "std::string TarFileReader::extract(const string &_path) { \n if (_path.empty()) THROW(\"path cannot be empty\"); \n if (!hasMore()) THROW(\"No more tar files\"); \n string path = _path; \n if (SystemUtilities::isDirectory(path)) path += \"/\" + getFilename(); \n LOG_DEBUG(5, \"Extracting: \" << path); \n return extract(*SystemUtilities::oopen(path)); \n }",
  "no_vul": "std::string TarFileReader::extract(const string &_path) { \n if (_path.empty()) THROW(\"path cannot be empty\"); \n if (!hasMore()) THROW(\"No more tar files\"); \n string path = _path; \n if (SystemUtilities::isDirectory(path)) { \n path += \"/\" + getFilename(); \n string a = SystemUtilities::getCanonicalPath(_path); \n string b = SystemUtilities::getCanonicalPath(path); \n if (!String::startsWith(b, a)) \n THROW(\"Tar path points outside of the extraction directory: \" << path); \n } \n LOG_DEBUG(5, \"Extracting: \" << path); \n switch (getType()) { \n case NORMAL_FILE: case CONTIGUOUS_FILE: \n return extract(*SystemUtilities::oopen(path)); \n case DIRECTORY: SystemUtilities::ensureDirectory(path); break; \n default: THROW(\"Unsupported tar file type \" << getType()); \n } \n return getFilename(); \n }",
  "cwe": "CWE-22",
  "codeline": "string path = _path; \nif (SystemUtilities::isDirectory(path)) path += \"/\" + getFilename();"
}
{
  "idx": 399,
  "target": 1,
  "vul": "mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b) \n { \n if (a->body.irep) { \n return; \n } \n a->flags = b->flags; \n a->body = b->body; \n a->upper = b->upper; \n if (!MRB_PROC_CFUNC_P(a) && a->body.irep) { \n mrb_irep_incref(mrb, (mrb_irep*)a->body.irep); \n } \n a->e.env = b->e.env; \n }",
  "no_vul": "mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b) \n { \n if (a->body.irep) { \n return; \n } \n if (!MRB_PROC_CFUNC_P(b) && b->body.irep) { \n mrb_irep_incref(mrb, (mrb_irep*)b->body.irep); \n } \n a->flags = b->flags; \n a->body = b->body; \n a->upper = b->upper; \n a->e.env = b->e.env; \n }",
  "cwe": "CWE-122",
  "codeline": "if (!MRB_PROC_CFUNC_P(a) && a->body.irep) { \nmrb_irep_incref(mrb, (mrb_irep*)a->body.irep); \n}"
}
{
  "idx": 400,
  "target": 1,
  "vul": "int64_t TensorByteSize(const TensorProto& t) { \n int64_t num_elems = TensorShape(t.tensor_shape()).num_elements(); \n return num_elems < 0 ? -1 : num_elems * DataTypeSize(t.dtype()); \n }",
  "no_vul": "int64_t TensorByteSize(const TensorProto& t) { \n int64_t num_elems = PartialTensorShape(t.tensor_shape()).num_elements(); \n return num_elems < 0 ? -1 : num_elems * DataTypeSize(t.dtype()); \n }",
  "cwe": "CWE-617",
  "codeline": "int64_t num_elems = TensorShape(t.tensor_shape()).num_elements();"
}
{
  "idx": 401,
  "target": 1,
  "vul": "void sqlite3Fts5UnicodeAscii(u8 *aArray, u8 *aAscii){ \n int i = 0; \n int iTbl = 0; \n while( i<128 ){ \n int bToken = aArray[ aFts5UnicodeData[iTbl] & 0x1F ]; \n int n = (aFts5UnicodeData[iTbl] >> 5) + i; \n for(; i<128 && i<n; i++){ \n aAscii[i] = (u8)bToken; \n } \n iTbl++; \n } \n }",
  "no_vul": "void sqlite3Fts5UnicodeAscii(u8 *aArray, u8 *aAscii){ \n int i = 0; \n int iTbl = 0; \n while( i<128 ){ \n int bToken = aArray[ aFts5UnicodeData[iTbl] & 0x1F ]; \n int n = (aFts5UnicodeData[iTbl] >> 5) + i; \n for(; i<128 && i<n; i++){ \n aAscii[i] = (u8)bToken; \n } \n iTbl++; \n } \n aAscii[0] = 0; \n }",
  "cwe": "CWE-787",
  "codeline": "aAscii[i] = (u8)bToken;"
}
{
  "idx": 402,
  "target": 1,
  "vul": "int32_t *enc_untrusted_create_wait_queue() { \n MessageWriter input; \n MessageReader output; \n input.Push<uint64_t>(sizeof(int32_t)); \n const auto status = NonSystemCallDispatcher( \n ::asylo::host_call::kLocalLifetimeAllocHandler, &input, &output); \n CheckStatusAndParamCount(status, output, \"enc_untrusted_create_wait_queue\", \n 2); \n int32_t *queue = reinterpret_cast<int32_t *>(output.next<uintptr_t>()); \n int klinux_errno = output.next<int>(); \n if (queue == nullptr) { \n errno = FromkLinuxErrorNumber(klinux_errno); \n } \n enc_untrusted_disable_waiting(queue); \n return queue; \n }",
  "no_vul": "int32_t *enc_untrusted_create_wait_queue() { \n MessageWriter input; \n MessageReader output; \n input.Push<uint64_t>(sizeof(int32_t)); \n const auto status = NonSystemCallDispatcher( \n ::asylo::host_call::kLocalLifetimeAllocHandler, &input, &output); \n CheckStatusAndParamCount(status, output, \"enc_untrusted_create_wait_queue\", \n 2); \n int32_t *queue = reinterpret_cast<int32_t *>(output.next<uintptr_t>()); \n if (!TrustedPrimitives::IsOutsideEnclave(queue, sizeof(int32_t))) { \n TrustedPrimitives::BestEffortAbort( \n \"enc_untrusted_create_wait_queue: queue should be in untrusted memory\"); \n } \n int klinux_errno = output.next<int>(); \n if (queue == nullptr) { \n errno = FromkLinuxErrorNumber(klinux_errno); \n } \n enc_untrusted_disable_waiting(queue); \n return queue; \n }",
  "cwe": "CWE-787",
  "codeline": "int32_t *queue = reinterpret_cast<int32_t *>(output.next<uintptr_t>());"
}
{
  "idx": 403,
  "target": 1,
  "vul": "NativeModule::NativeModule(const std::string& filename) : init(nullptr) { \n if (uv_dlopen(filename.c_str(), &lib) != 0) { \n throw RuntimeGenericError(\"Failed to load module\"); \n } \n if (uv_dlsym(&lib, \"InitForContext\", reinterpret_cast<void**>(&init)) != 0 || init == nullptr) { \n uv_dlclose(&lib); \n throw RuntimeGenericError(\"Module is not isolated-vm compatible\"); \n } \n }",
  "no_vul": "NativeModule::NativeModule(const std::string& filename) : init(nullptr) { \n if (!IsolateEnvironment::GetCurrent()->IsDefault()) { \n throw RuntimeGenericError(\"NativeModule may only be instantiated from default nodejs isolate\"); \n } \n if (uv_dlopen(filename.c_str(), &lib) != 0) { \n throw RuntimeGenericError(\"Failed to load module\"); \n } \n if (uv_dlsym(&lib, \"InitForContext\", reinterpret_cast<void**>(&init)) != 0 || init == nullptr) { \n uv_dlclose(&lib); \n throw RuntimeGenericError(\"Module is not isolated-vm compatible\"); \n } \n }",
  "cwe": "CWE-703",
  "codeline": "if (uv_dlopen(filename.c_str(), &lib) != 0) {"
}
{
  "idx": 404,
  "target": 1,
  "vul": "bool matches(const Http::RequestHeaderMap& headers) const override { \n if (BaseMatcherImpl::matchRoute(headers)) { \n const Http::HeaderString& path = headers.Path()->value(); \n const absl::string_view query_string = Http::Utility::findQueryStringStart(path); \n absl::string_view path_view = path.getStringView(); \n path_view.remove_suffix(query_string.length()); \n if (path_matcher_->match(path_view)) { \n ENVOY_LOG(debug, \"Regex requirement '{}' matched.\", regex_str_); \n return true; \n } \n } \n return false; \n }",
  "no_vul": "bool matches(const Http::RequestHeaderMap& headers) const override { \n if (BaseMatcherImpl::matchRoute(headers)) { \n if (headers.Path() == nullptr) { \n return false; \n } \n const Http::HeaderString& path = headers.Path()->value(); \n const absl::string_view query_string = Http::Utility::findQueryStringStart(path); \n absl::string_view path_view = path.getStringView(); \n path_view.remove_suffix(query_string.length()); \n if (path_matcher_->match(path_view)) { \n ENVOY_LOG(debug, \"Regex requirement '{}' matched.\", regex_str_); \n return true; \n } \n } \n return false; \n }",
  "cwe": "CWE-703",
  "codeline": "const Http::HeaderString& path = headers.Path()->value();"
}
{
  "idx": 405,
  "target": 1,
  "vul": "explicit ReverseSequenceOp(OpKernelConstruction* context) \n : OpKernel(context) { \n OP_REQUIRES_OK(context, context->GetAttr(\"batch_dim\", &batch_dim_)); \n OP_REQUIRES_OK(context, context->GetAttr(\"seq_dim\", &seq_dim_)); \n }",
  "no_vul": "explicit ReverseSequenceOp(OpKernelConstruction* context) \n : OpKernel(context) { \n OP_REQUIRES_OK(context, context->GetAttr(\"batch_dim\", &batch_dim_)); \n OP_REQUIRES_OK(context, context->GetAttr(\"seq_dim\", &seq_dim_)); \n OP_REQUIRES(context, batch_dim_ >= 0, \n errors::InvalidArgument(\"Invalid batch_dim \", batch_dim_)); \n OP_REQUIRES(context, seq_dim_ >= 0, \n errors::InvalidArgument(\"Invalid seq_dim \", seq_dim_)); \n }",
  "cwe": "CWE-787",
  "codeline": "OP_REQUIRES_OK(context, context->GetAttr(\"batch_dim\", &batch_dim_)); \nOP_REQUIRES_OK(context, context->GetAttr(\"seq_dim\", &seq_dim_));"
}
{
  "idx": 406,
  "target": 1,
  "vul": "void CleanWriters(GF_List *writers) \n { \n while (gf_list_count(writers)) { \n TrackWriter *writer = (TrackWriter*)gf_list_get(writers, 0); \n gf_isom_box_del(writer->stco); \n gf_isom_box_del((GF_Box *)writer->stsc); \n gf_free(writer); \n gf_list_rem(writers, 0); \n } \n }",
  "no_vul": "void CleanWriters(GF_List *writers) \n { \n while (gf_list_count(writers)) { \n TrackWriter *writer = (TrackWriter*)gf_list_get(writers, 0); \n gf_list_del_item(writer->stbl->child_boxes, writer->stco); \n gf_list_del_item(writer->stbl->child_boxes, writer->stsc); \n gf_isom_box_del(writer->stco); \n gf_isom_box_del((GF_Box *)writer->stsc); \n gf_free(writer); \n gf_list_rem(writers, 0); \n } \n }",
  "cwe": "CWE-416",
  "codeline": "gf_isom_box_del(writer->stco);"
}
{
  "idx": 407,
  "target": 1,
  "vul": "ImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* context) \n : OpKernel(context) { \n OP_REQUIRES_OK(context, \n context->GetAttr(kMemoryRegionNameAttr, &region_name_)); \n OP_REQUIRES_OK(context, context->GetAttr(kDTypeAttr, &dtype_)); \n OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_)); \n }",
  "no_vul": "ImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* context) \n : OpKernel(context) { \n OP_REQUIRES_OK(context, \n context->GetAttr(kMemoryRegionNameAttr, &region_name_)); \n OP_REQUIRES_OK(context, context->GetAttr(kDTypeAttr, &dtype_)); \n OP_REQUIRES(context, dtype_ != DT_RESOURCE && dtype_ != DT_VARIANT, \n errors::InvalidArgument( \n \"Resource and variant dtypes are invalid for this op.\")); \n OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_)); \n }",
  "cwe": "CWE-703",
  "codeline": "OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_));"
}
{
  "idx": 408,
  "target": 1,
  "vul": "CString CWebSock::GetSkinPath(const CString& sSkinName) { \n CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName; \n if (!CFile::IsDir(sRet)) { \n sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName; \n if (!CFile::IsDir(sRet)) { \n sRet = CString(_SKINDIR_) + \"/\" + sSkinName; \n } \n } \n return sRet + \"/\"; \n }",
  "no_vul": "CString CWebSock::GetSkinPath(const CString& sSkinName) { \n const CString sSkin = sSkinName.Replace_n(\"/\", \"_\").Replace_n(\".\", \"_\"); \n CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkin; \n if (!CFile::IsDir(sRet)) { \n sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkin; \n if (!CFile::IsDir(sRet)) { \n sRet = CString(_SKINDIR_) + \"/\" + sSkin; \n } \n } \n return sRet + \"/\"; \n }",
  "cwe": "CWE-22",
  "codeline": "CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;"
}
{
  "idx": 409,
  "target": 1,
  "vul": "inline int MatchingDim(const RuntimeShape& shape1, int index1, \n const RuntimeShape& shape2, int index2) { \n TFLITE_DCHECK_EQ(shape1.Dims(index1), shape2.Dims(index2)); \n return shape1.Dims(index1); \n }",
  "no_vul": "inline int MatchingDim(const RuntimeShape& shape1, int index1, \n const RuntimeShape& shape2, int index2) { \n TFLITE_DCHECK_EQ(shape1.Dims(index1), shape2.Dims(index2)); \n return std::min(shape1.Dims(index1), shape2.Dims(index2)); \n }",
  "cwe": "CWE-125",
  "codeline": "TFLITE_DCHECK_EQ(shape1.Dims(index1), shape2.Dims(index2));"
}
{
  "idx": 410,
  "target": 1,
  "vul": "Pong(const std::string& cookie, const std::string& server = \"\") \n : ClientProtocol::Message(\"PONG\", ServerInstance->Config->GetServerName()) \n { \n PushParamRef(ServerInstance->Config->GetServerName()); \n if (!server.empty()) \n PushParamRef(server); \n PushParamRef(cookie); \n }",
  "no_vul": "Pong(const std::string& cookie, const std::string& server = \"\") \n : ClientProtocol::Message(\"PONG\", ServerInstance->Config->GetServerName()) \n { \n if (server.empty()) \n PushParamRef(ServerInstance->Config->GetServerName()); \n else \n PushParam(server); \n PushParamRef(cookie); \n }",
  "cwe": "CWE-200",
  "codeline": "PushParamRef(ServerInstance->Config->GetServerName());"
}
{
  "idx": 411,
  "target": 1,
  "vul": "mrb_realloc(mrb_state *mrb, void *p, size_t len) \n { \n void *p2; \n p2 = mrb_realloc_simple(mrb, p, len); \n if (len == 0) return p2; \n if (p2 == NULL) { \n mrb_free(mrb, p); \n mrb->gc.out_of_memory = TRUE; \n mrb_raise_nomemory(mrb); \n } \n else { \n mrb->gc.out_of_memory = FALSE; \n } \n return p2; \n }",
  "no_vul": "mrb_realloc(mrb_state *mrb, void *p, size_t len) \n { \n void *p2; \n p2 = mrb_realloc_simple(mrb, p, len); \n if (len == 0) return p2; \n if (p2 == NULL) { \n mrb->gc.out_of_memory = TRUE; \n mrb_raise_nomemory(mrb); \n } \n else { \n mrb->gc.out_of_memory = FALSE; \n } \n return p2; \n }",
  "cwe": "CWE-415",
  "codeline": "mrb_free(mrb, p);"
}
{
  "idx": 412,
  "target": 1,
  "vul": "bool ItemStackMetadata::setString(const std::string &name, const std::string &var) \n { \n bool result = Metadata::setString(name, var); \n if (name == TOOLCAP_KEY) \n updateToolCapabilities(); \n return result; \n }",
  "no_vul": "bool ItemStackMetadata::setString(const std::string &name, const std::string &var) \n { \n std::string clean_name = name; \n std::string clean_var = var; \n sanitize_string(clean_name); \n sanitize_string(clean_var); \n bool result = Metadata::setString(clean_name, clean_var); \n if (clean_name == TOOLCAP_KEY) \n updateToolCapabilities(); \n return result; \n }",
  "cwe": "CWE-74",
  "codeline": "if (name == TOOLCAP_KEY) \nupdateToolCapabilities();"
}
{
  "idx": 413,
  "target": 1,
  "vul": "static void unzzip_cat_file(ZZIP_DIR* disk, char* name, FILE* out) \n { \n ZZIP_FILE* file = zzip_file_open (disk, name, 0); \n if (file) \n { \n char buffer[1024]; int len; \n while ((len = zzip_file_read (file, buffer, 1024))) \n { \n fwrite (buffer, 1, len, out); \n } \n zzip_file_close (file); \n } \n }",
  "no_vul": "static void unzzip_cat_file(ZZIP_DIR* disk, char* name, FILE* out) \n { \n ZZIP_FILE* file = zzip_file_open (disk, name, 0); \n if (file) \n { \n char buffer[1024]; int len; \n while (0 < (len = zzip_file_read (file, buffer, 1024))) \n { \n fwrite (buffer, 1, len, out); \n } \n zzip_file_close (file); \n } \n }",
  "cwe": "CWE-835",
  "codeline": "while ((len = zzip_file_read (file, buffer, 1024)))"
}
{
  "idx": 414,
  "target": 1,
  "vul": "static void set_error_response(h2_stream *stream, int http_status) \n { \n if (!h2_stream_is_ready(stream)) { \n stream->rtmp->http_status = http_status; \n } \n }",
  "no_vul": "static void set_error_response(h2_stream *stream, int http_status) \n { \n if (!h2_stream_is_ready(stream) && stream->rtmp) { \n stream->rtmp->http_status = http_status; \n } \n }",
  "cwe": "CWE-476",
  "codeline": "if (!h2_stream_is_ready(stream)) { \n stream->rtmp->http_status = http_status; \n }"
}
{
  "idx": 415,
  "target": 1,
  "vul": "UINT rdpgfx_read_rect16(wStream* s, RECTANGLE_16* rect16) \n { \n if (Stream_GetRemainingLength(s) < 8) \n { \n WLog_ERR(TAG, \"not enough data!\"); \n return ERROR_INVALID_DATA; \n } \n Stream_Read_UINT16(s, rect16->left); \n Stream_Read_UINT16(s, rect16->top); \n Stream_Read_UINT16(s, rect16->right); \n Stream_Read_UINT16(s, rect16->bottom); \n return CHANNEL_RC_OK; \n }",
  "no_vul": "UINT rdpgfx_read_rect16(wStream* s, RECTANGLE_16* rect16) \n { \n if (Stream_GetRemainingLength(s) < 8) \n { \n WLog_ERR(TAG, \"not enough data!\"); \n return ERROR_INVALID_DATA; \n } \n Stream_Read_UINT16(s, rect16->left); \n Stream_Read_UINT16(s, rect16->top); \n Stream_Read_UINT16(s, rect16->right); \n Stream_Read_UINT16(s, rect16->bottom); \n if (rect16->left >= rect16->right) \n return ERROR_INVALID_DATA; \n if (rect16->top >= rect16->bottom) \n return ERROR_INVALID_DATA; \n return CHANNEL_RC_OK; \n }",
  "cwe": "CWE-190",
  "codeline": "Stream_Read_UINT16(s, rect16->left);"
}
{
  "idx": 416,
  "target": 1,
  "vul": "static x3f_huffnode_t *new_node(x3f_hufftree_t *tree) \n { \n x3f_huffnode_t *t = &tree->nodes[tree->free_node_index]; \n t->branch[0] = NULL; \n t->branch[1] = NULL; \n t->leaf = UNDEFINED_LEAF; \n tree->free_node_index++; \n return t; \n }",
  "no_vul": "static x3f_huffnode_t *new_node(x3f_hufftree_t *tree) \n { \n if (tree->free_node_index >= tree->total_node_index) \n throw LIBRAW_EXCEPTION_IO_CORRUPT; \n x3f_huffnode_t *t = &tree->nodes[tree->free_node_index]; \n t->branch[0] = NULL; \n t->branch[1] = NULL; \n t->leaf = UNDEFINED_LEAF; \n tree->free_node_index++; \n return t; \n }",
  "cwe": "CWE-125",
  "codeline": "tree->free_node_index++;"
}
{
  "idx": 417,
  "target": 1,
  "vul": "static struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vpidx) \n { \n struct kvm_vcpu *vcpu; \n struct kvm_vcpu_hv_synic *synic; \n vcpu = get_vcpu_by_vpidx(kvm, vpidx); \n if (!vcpu) \n return NULL; \n synic = to_hv_synic(vcpu); \n return (synic->active) ? synic : NULL; \n }",
  "no_vul": "static struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vpidx) \n { \n struct kvm_vcpu *vcpu; \n struct kvm_vcpu_hv_synic *synic; \n vcpu = get_vcpu_by_vpidx(kvm, vpidx); \n if (!vcpu || !to_hv_vcpu(vcpu)) \n return NULL; \n synic = to_hv_synic(vcpu); \n return (synic->active) ? synic : NULL; \n }",
  "cwe": "CWE-476",
  "codeline": "synic = to_hv_synic(vcpu);"
}
{
  "idx": 418,
  "target": 1,
  "vul": "static inline void kvm_memslot_delete(struct kvm_memslots *slots, \n struct kvm_memory_slot *memslot) \n { \n struct kvm_memory_slot *mslots = slots->memslots; \n int i; \n if (WARN_ON(slots->id_to_index[memslot->id] == -1)) \n return; \n slots->used_slots--; \n for (i = slots->id_to_index[memslot->id]; i < slots->used_slots; i++) { \n mslots[i] = mslots[i + 1]; \n slots->id_to_index[mslots[i].id] = i; \n } \n mslots[i] = *memslot; \n slots->id_to_index[memslot->id] = -1; \n }",
  "no_vul": "static inline void kvm_memslot_delete(struct kvm_memslots *slots, \n struct kvm_memory_slot *memslot) \n { \n struct kvm_memory_slot *mslots = slots->memslots; \n int i; \n if (WARN_ON(slots->id_to_index[memslot->id] == -1)) \n return; \n slots->used_slots--; \n if (atomic_read(&slots->lru_slot) >= slots->used_slots) \n atomic_set(&slots->lru_slot, 0); \n for (i = slots->id_to_index[memslot->id]; i < slots->used_slots; i++) { \n mslots[i] = mslots[i + 1]; \n slots->id_to_index[mslots[i].id] = i; \n } \n mslots[i] = *memslot; \n slots->id_to_index[memslot->id] = -1; \n }",
  "cwe": "CWE-416",
  "codeline": "mslots[i] = *memslot;"
}
{
  "idx": 419,
  "target": 1,
  "vul": "int url_is_local_not_ssh(const char *url) \n { \n const char *colon = strchr(url, ':'); \n const char *slash = strchr(url, '/'); \n return !colon || (slash && slash < colon) || \n has_dos_drive_prefix(url); \n }",
  "no_vul": "int url_is_local_not_ssh(const char *url) \n { \n const char *colon = strchr(url, ':'); \n const char *slash = strchr(url, '/'); \n return !colon || (slash && slash < colon) || \n (has_dos_drive_prefix(url) && is_valid_path(url)); \n }",
  "cwe": "CWE-706",
  "codeline": "has_dos_drive_prefix(url);"
}
{
  "idx": 420,
  "target": 1,
  "vul": "static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){ \n assert( p->nOp>0 || p->aOp==0 ); \n assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed ); \n if( p->nOp ){ \n assert( p->aOp ); \n sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment); \n p->aOp[p->nOp-1].zComment = sqlite3VMPrintf(p->db, zFormat, ap); \n } \n }",
  "no_vul": "static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){ \n assert( p->nOp>0 || p->aOp==0 ); \n assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed \n || p->pParse->nErr>0 ); \n if( p->nOp ){ \n assert( p->aOp ); \n sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment); \n p->aOp[p->nOp-1].zComment = sqlite3VMPrintf(p->db, zFormat, ap); \n } \n }",
  "cwe": "CWE-755",
  "codeline": "assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );"
}
{
  "idx": 421,
  "target": 1,
  "vul": "static void umd_cleanup(struct subprocess_info *info) \n { \n struct umd_info *umd_info = info->data; \n if (info->retval) { \n fput(umd_info->pipe_to_umh); \n fput(umd_info->pipe_from_umh); \n put_pid(umd_info->tgid); \n umd_info->tgid = NULL; \n } \n }",
  "no_vul": "static void umd_cleanup(struct subprocess_info *info) \n { \n struct umd_info *umd_info = info->data; \n if (info->retval) \n umd_cleanup_helper(umd_info); \n }",
  "cwe": "CWE-401",
  "codeline": "fput(umd_info->pipe_to_umh);"
}
{
  "idx": 422,
  "target": 1,
  "vul": "static int identity_count(void *v, const char *key, const char *val) \n { \n int *count = v; \n *count += strlen(key) * 3 + strlen(val) * 3 + 1; \n return 1; \n }",
  "no_vul": "static int identity_count(void *v, const char *key, const char *val) \n { \n int *count = v; \n *count += strlen(key) * 3 + strlen(val) * 3 + 2; \n return 1; \n }",
  "cwe": "CWE-787",
  "codeline": "*count += strlen(key) * 3 + strlen(val) * 3 + 1;"
}
{
  "idx": 423,
  "target": 1,
  "vul": "static void gprinter_free(struct usb_function *f) \n { \n struct printer_dev *dev = func_to_printer(f); \n struct f_printer_opts *opts; \n opts = container_of(f->fi, struct f_printer_opts, func_inst); \n kfree(dev); \n mutex_lock(&opts->lock); \n --opts->refcnt; \n mutex_unlock(&opts->lock); \n }",
  "no_vul": "static void gprinter_free(struct usb_function *f) \n { \n struct printer_dev *dev = func_to_printer(f); \n struct f_printer_opts *opts; \n opts = container_of(f->fi, struct f_printer_opts, func_inst); \n kref_put(&dev->kref, printer_dev_free); \n mutex_lock(&opts->lock); \n --opts->refcnt; \n mutex_unlock(&opts->lock); \n }",
  "cwe": "CWE-416",
  "codeline": "kfree(dev);"
}
{
  "idx": 424,
  "target": 1,
  "vul": "static int xar_hash_check(int hash, const void * result, const void * expected) \n { \n int len; \n if (!result || !expected) \n return 1; \n switch (hash) { \n case XAR_CKSUM_SHA1: \n len = SHA1_HASH_SIZE; \n break; \n case XAR_CKSUM_MD5: \n len = CLI_HASH_MD5; \n break; \n case XAR_CKSUM_OTHER: \n case XAR_CKSUM_NONE: \n default: \n return 1; \n } \n return memcmp(result, expected, len); \n }",
  "no_vul": "static int xar_hash_check(int hash, const void * result, const void * expected) \n { \n int len; \n if (!result || !expected) \n return 1; \n switch (hash) { \n case XAR_CKSUM_SHA1: \n len = CLI_HASHLEN_SHA1; \n break; \n case XAR_CKSUM_MD5: \n len = CLI_HASHLEN_MD5; \n break; \n case XAR_CKSUM_OTHER: \n case XAR_CKSUM_NONE: \n default: \n return 1; \n } \n return memcmp(result, expected, len); \n }",
  "cwe": "CWE-125",
  "codeline": "len = CLI_HASH_MD5;"
}
{
  "idx": 425,
  "target": 1,
  "vul": "static void mcba_usb_disconnect(struct usb_interface *intf) \n { \n struct mcba_priv *priv = usb_get_intfdata(intf); \n usb_set_intfdata(intf, NULL); \n netdev_info(priv->netdev, \"device disconnected\\n\"); \n unregister_candev(priv->netdev); \n free_candev(priv->netdev); \n mcba_urb_unlink(priv); \n }",
  "no_vul": "static void mcba_usb_disconnect(struct usb_interface *intf) \n { \n struct mcba_priv *priv = usb_get_intfdata(intf); \n usb_set_intfdata(intf, NULL); \n netdev_info(priv->netdev, \"device disconnected\\n\"); \n unregister_candev(priv->netdev); \n mcba_urb_unlink(priv); \n free_candev(priv->netdev); \n }",
  "cwe": "CWE-416",
  "codeline": "free_candev(priv->netdev);"
}
{
  "idx": 426,
  "target": 1,
  "vul": "int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req, \n unsigned long opt), \n unsigned long opt, u32 timeout, u8 *hci_status) \n { \n int ret; \n if (!test_bit(HCI_UP, &hdev->flags)) \n return -ENETDOWN; \n hci_req_sync_lock(hdev); \n ret = __hci_req_sync(hdev, req, opt, timeout, hci_status); \n hci_req_sync_unlock(hdev); \n return ret; \n }",
  "no_vul": "int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req, \n unsigned long opt), \n unsigned long opt, u32 timeout, u8 *hci_status) \n { \n int ret; \n hci_req_sync_lock(hdev); \n if (test_bit(HCI_UP, &hdev->flags)) \n ret = __hci_req_sync(hdev, req, opt, timeout, hci_status); \n else \n ret = -ENETDOWN; \n hci_req_sync_unlock(hdev); \n return ret; \n }",
  "cwe": "CWE-362",
  "codeline": "if (!test_bit(HCI_UP, &hdev->flags)) \n return -ENETDOWN;"
}
{
  "idx": 427,
  "target": 1,
  "vul": "file_rlookup(const char *filename) \n { \n int i; \n cache_t *wc; \n for (i = web_files, wc = web_cache; i > 0; i --, wc ++) \n if (!strcmp(wc->name, filename)) \n return (wc->url); \n return (filename); \n }",
  "no_vul": "file_rlookup(const char *filename) \n { \n int i; \n cache_t *wc; \n for (i = web_files, wc = web_cache; i > 0; i --, wc ++) \n { \n if (!strcmp(wc->name, filename)) \n { \n if (!strncmp(wc->url, \"data:\", 5)) \n return (\"data URL\"); \n else \n return (wc->url); \n } \n } \n return (filename); \n }",
  "cwe": "CWE-415",
  "codeline": "return (wc->url);"
}
{
  "idx": 428,
  "target": 1,
  "vul": "static BOOL rdp_read_font_capability_set(wStream* s, UINT16 length, rdpSettings* settings) \n { \n WINPR_UNUSED(settings); \n if (length > 4) \n Stream_Seek_UINT16(s); \n if (length > 6) \n Stream_Seek_UINT16(s); \n return TRUE; \n }",
  "no_vul": "static BOOL rdp_read_font_capability_set(wStream* s, UINT16 length, rdpSettings* settings) \n { \n WINPR_UNUSED(settings); \n if (length > 5) \n Stream_Seek_UINT16(s); \n if (length > 7) \n Stream_Seek_UINT16(s); \n return TRUE; \n }",
  "cwe": "CWE-125",
  "codeline": "if (length > 4) \nStream_Seek_UINT16(s);"
}
{
  "idx": 429,
  "target": 1,
  "vul": "delete_buff_tail(buffheader_T *buf, int slen) \n { \n int len = (int)STRLEN(buf->bh_curr->b_str); \n if (len >= slen) \n { \n buf->bh_curr->b_str[len - slen] = NUL; \n buf->bh_space += slen; \n } \n }",
  "no_vul": "delete_buff_tail(buffheader_T *buf, int slen) \n { \n int len; \n if (buf->bh_curr == NULL || buf->bh_curr->b_str == NULL) \n return; \n len = (int)STRLEN(buf->bh_curr->b_str); \n if (len >= slen) \n { \n buf->bh_curr->b_str[len - slen] = NUL; \n buf->bh_space += slen; \n } \n }",
  "cwe": "CWE-125",
  "codeline": "if (len >= slen)"
}
{
  "idx": 430,
  "target": 1,
  "vul": "static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked) \n { \n if (sk->sk_send_head == skb_unlinked) \n sk->sk_send_head = NULL; \n }",
  "no_vul": "static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked) \n { \n if (sk->sk_send_head == skb_unlinked) \n sk->sk_send_head = NULL; \n if (tcp_sk(sk)->highest_sack == skb_unlinked) \n tcp_sk(sk)->highest_sack = NULL; \n }",
  "cwe": "CWE-269",
  "codeline": "if (sk->sk_send_head == skb_unlinked) \nsk->sk_send_head = NULL;"
}
{
  "idx": 431,
  "target": 1,
  "vul": "static INLINE BOOL ensure_capacity(const BYTE* start, const BYTE* end, size_t size, size_t base) \n { \n const size_t available = (uintptr_t)end - (uintptr_t)start; \n const BOOL rc = available >= size * base; \n return rc; \n }",
  "no_vul": "static INLINE BOOL ensure_capacity(const BYTE* start, const BYTE* end, size_t size, size_t base) \n { \n const size_t available = (uintptr_t)end - (uintptr_t)start; \n const BOOL rc = available >= size * base; \n return rc && (start <= end); \n }",
  "cwe": "CWE-787",
  "codeline": "const size_t available = (uintptr_t)end - (uintptr_t)start;"
}
{
  "idx": 432,
  "target": 1,
  "vul": "mt76_add_fragment(struct mt76_dev *dev, struct mt76_queue *q, void *data, \n int len, bool more) \n { \n struct page *page = virt_to_head_page(data); \n int offset = data - page_address(page); \n struct sk_buff *skb = q->rx_head; \n offset += q->buf_offset; \n skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page, offset, len, \n q->buf_size); \n if (more) \n return; \n q->rx_head = NULL; \n dev->drv->rx_skb(dev, q - dev->q_rx, skb); \n }",
  "no_vul": "mt76_add_fragment(struct mt76_dev *dev, struct mt76_queue *q, void *data, \n int len, bool more) \n { \n struct page *page = virt_to_head_page(data); \n int offset = data - page_address(page); \n struct sk_buff *skb = q->rx_head; \n struct skb_shared_info *shinfo = skb_shinfo(skb); \n if (shinfo->nr_frags < ARRAY_SIZE(shinfo->frags)) { \n offset += q->buf_offset; \n skb_add_rx_frag(skb, shinfo->nr_frags, page, offset, len, \n q->buf_size); \n } \n if (more) \n return; \n q->rx_head = NULL; \n dev->drv->rx_skb(dev, q - dev->q_rx, skb); \n }",
  "cwe": "CWE-787",
  "codeline": "skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page, offset, len, q->buf_size);"
}
{
  "idx": 433,
  "target": 1,
  "vul": "rndr_quote(struct buf *ob, const struct buf *text, void *opaque) \n { \n if (!text || !text->size) \n return 0; \n BUFPUTSL(ob, \"<q>\"); \n bufput(ob, text->data, text->size); \n BUFPUTSL(ob, \"</q>\"); \n return 1; \n }",
  "no_vul": "rndr_underline(struct buf *ob, const struct buf *text, void *opaque) \n { \n if (!text || !text->size) \n return 0; \n BUFPUTSL(ob, \"<u>\"); \n bufput(ob, text->data, text->size); \n BUFPUTSL(ob, \"</u>\"); \n return 1; \n }",
  "cwe": "CWE-79",
  "codeline": "BUFPUTSL(ob, \"<q>\");"
}
{
  "idx": 434,
  "target": 1,
  "vul": "static int changedline (const Proto *p, int oldpc, int newpc) { \n while (oldpc++ < newpc) { \n if (p->lineinfo[oldpc] != 0) \n return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc)); \n } \n return 0; \n }",
  "no_vul": "static int changedline (const Proto *p, int oldpc, int newpc) { \n if (p->lineinfo == NULL) \n return 0; \n while (oldpc++ < newpc) { \n if (p->lineinfo[oldpc] != 0) \n return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc)); \n } \n return 0; \n }",
  "cwe": "CWE-787",
  "codeline": "if (p->lineinfo[oldpc] != 0)"
}
{
  "idx": 435,
  "target": 1,
  "vul": "static struct kobject *cdev_get(struct cdev *p) \n { \n struct module *owner = p->owner; \n struct kobject *kobj; \n if (owner && !try_module_get(owner)) \n return NULL; \n kobj = kobject_get(&p->kobj); \n if (!kobj) \n module_put(owner); \n return kobj; \n }",
  "no_vul": "static struct kobject *cdev_get(struct cdev *p) \n { \n struct module *owner = p->owner; \n struct kobject *kobj; \n if (owner && !try_module_get(owner)) \n return NULL; \n kobj = kobject_get_unless_zero(&p->kobj); \n if (!kobj) \n module_put(owner); \n return kobj; \n }",
  "cwe": "CWE-362",
  "codeline": "kobj = kobject_get(&p->kobj);"
}
{
  "idx": 436,
  "target": 1,
  "vul": "void luaD_callnoyield (lua_State *L, StkId func, int nResults) { \n incXCcalls(L); \n if (getCcalls(L) <= CSTACKERR) \n luaE_freeCI(L); \n luaD_call(L, func, nResults); \n decXCcalls(L); \n }",
  "no_vul": "void luaD_callnoyield (lua_State *L, StkId func, int nResults) { \n incXCcalls(L); \n if (getCcalls(L) <= CSTACKERR) { \n luaE_exitCcall(L); \n luaE_enterCcall(L); \n } \n luaD_call(L, func, nResults); \n decXCcalls(L); \n }",
  "cwe": "CWE-787",
  "codeline": "if (getCcalls(L) <= CSTACKERR) \nluaE_freeCI(L);"
}
{
  "idx": 437,
  "target": 1,
  "vul": "Pl_Count::write(unsigned char* buf, size_t len) \n { \n if (len) \n { \n this->m->count += QIntC::to_offset(len); \n getNext()->write(buf, len); \n this->m->last_char = buf[len - 1]; \n } \n }",
  "no_vul": "Pl_Count::write(unsigned char* buf, size_t len) \n { \n if (len) \n { \n this->m->count += QIntC::to_offset(len); \n this->m->last_char = buf[len - 1]; \n getNext()->write(buf, len); \n } \n }",
  "cwe": "CWE-787",
  "codeline": "this->m->last_char = buf[len - 1];"
}
{
  "idx": 438,
  "target": 1,
  "vul": "void rsi_mac80211_detach(struct rsi_hw *adapter) \n { \n struct ieee80211_hw *hw = adapter->hw; \n enum nl80211_band band; \n if (hw) { \n ieee80211_stop_queues(hw); \n ieee80211_unregister_hw(hw); \n ieee80211_free_hw(hw); \n } \n for (band = 0; band < NUM_NL80211_BANDS; band++) { \n struct ieee80211_supported_band *sband = \n &adapter->sbands[band]; \n kfree(sband->channels); \n } \n #ifdef CONFIG_RSI_DEBUGFS \n rsi_remove_dbgfs(adapter); \n kfree(adapter->dfsentry); \n #endif \n }",
  "no_vul": "void rsi_mac80211_detach(struct rsi_hw *adapter) \n { \n struct ieee80211_hw *hw = adapter->hw; \n enum nl80211_band band; \n if (hw) { \n ieee80211_stop_queues(hw); \n ieee80211_unregister_hw(hw); \n ieee80211_free_hw(hw); \n adapter->hw = NULL; \n } \n for (band = 0; band < NUM_NL80211_BANDS; band++) { \n struct ieee80211_supported_band *sband = \n &adapter->sbands[band]; \n kfree(sband->channels); \n } \n #ifdef CONFIG_RSI_DEBUGFS \n rsi_remove_dbgfs(adapter); \n kfree(adapter->dfsentry); \n #endif \n }",
  "cwe": "CWE-416",
  "codeline": "ieee80211_free_hw(hw);"
}
{
  "idx": 439,
  "target": 1,
  "vul": "writepid (const char* pidfile, pid_t pid) \n { \n FILE* f; \n if ((f = fopen(pidfile, \"w\")) == NULL ) { \n log_err(\"cannot open pidfile %s: %s\", \n pidfile, strerror(errno)); \n return; \n } \n if(fprintf(f, \"%lu\\n\", (unsigned long)pid) < 0) { \n log_err(\"cannot write to pidfile %s: %s\", \n pidfile, strerror(errno)); \n } \n fclose(f); \n }",
  "no_vul": "writepid (const char* pidfile, pid_t pid) \n { \n int fd; \n char pidbuf[32]; \n size_t count = 0; \n snprintf(pidbuf, sizeof(pidbuf), \"%lu\\n\", (unsigned long)pid); \n if((fd = open(pidfile, O_WRONLY | O_CREAT | O_TRUNC \n #ifdef O_NOFOLLOW \n | O_NOFOLLOW \n #endif \n , 0644)) == -1) { \n log_err(\"cannot open pidfile %s: %s\", \n pidfile, strerror(errno)); \n return; \n } \n while(count < strlen(pidbuf)) { \n ssize_t r = write(fd, pidbuf+count, strlen(pidbuf)-count); \n if(r == -1) { \n if(errno == EAGAIN || errno == EINTR) \n continue; \n log_err(\"cannot write to pidfile %s: %s\", \n pidfile, strerror(errno)); \n break; \n } \n count += r; \n } \n close(fd); \n }",
  "cwe": "CWE-59",
  "codeline": "if(fprintf(f, \"%lu\\n\", (unsigned long)pid) < 0) {"
}
{
  "idx": 440,
  "target": 1,
  "vul": "INLINE void gdi_RectToCRgn(const HGDI_RECT rect, INT32* x, INT32* y, INT32* w, INT32* h) \n { \n *x = rect->left; \n *y = rect->top; \n *w = rect->right - rect->left + 1; \n *h = rect->bottom - rect->top + 1; \n }",
  "no_vul": "INLINE void gdi_RectToRgn(HGDI_RECT rect, HGDI_RGN rgn) \n { \n rgn->x = rect->left; \n rgn->y = rect->top; \n rgn->w = rect->right - rect->left + 1; \n rgn->h = rect->bottom - rect->top + 1; \n }",
  "cwe": "CWE-190",
  "codeline": "*w = rect->right - rect->left + 1;"
}
{
  "idx": 441,
  "target": 1,
  "vul": "table_regex_match(const char *string, const char *pattern) \n { \n regex_t preg; \n int cflags = REG_EXTENDED|REG_NOSUB; \n if (strncmp(pattern, \"(?i)\", 4) == 0) { \n cflags |= REG_ICASE; \n pattern += 4; \n } \n if (regcomp(&preg, pattern, cflags) != 0) \n return (0); \n if (regexec(&preg, string, 0, NULL, 0) != 0) \n return (0); \n return (1); \n }",
  "no_vul": "table_regex_match(const char *string, const char *pattern) \n { \n regex_t preg; \n int cflags = REG_EXTENDED|REG_NOSUB; \n int ret; \n if (strncmp(pattern, \"(?i)\", 4) == 0) { \n cflags |= REG_ICASE; \n pattern += 4; \n } \n if (regcomp(&preg, pattern, cflags) != 0) \n return (0); \n ret = regexec(&preg, string, 0, NULL, 0); \n regfree(&preg); \n if (ret != 0) \n return (0); \n return (1); \n }",
  "cwe": "CWE-401",
  "codeline": "if (regexec(&preg, string, 0, NULL, 0) != 0) \n return (0);"
}
{
  "idx": 442,
  "target": 1,
  "vul": "struct clock_source *dce100_clock_source_create( \n struct dc_context *ctx, \n struct dc_bios *bios, \n enum clock_source_id id, \n const struct dce110_clk_src_regs *regs, \n bool dp_clk_src) \n { \n struct dce110_clk_src *clk_src = \n kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL); \n if (!clk_src) \n return NULL; \n if (dce110_clk_src_construct(clk_src, ctx, bios, id, \n regs, &cs_shift, &cs_mask)) { \n clk_src->base.dp_clk_src = dp_clk_src; \n return &clk_src->base; \n } \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "no_vul": "struct clock_source *dce100_clock_source_create( \n struct dc_context *ctx, \n struct dc_bios *bios, \n enum clock_source_id id, \n const struct dce110_clk_src_regs *regs, \n bool dp_clk_src) \n { \n struct dce110_clk_src *clk_src = \n kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL); \n if (!clk_src) \n return NULL; \n if (dce110_clk_src_construct(clk_src, ctx, bios, id, \n regs, &cs_shift, &cs_mask)) { \n clk_src->base.dp_clk_src = dp_clk_src; \n return &clk_src->base; \n } \n kfree(clk_src); \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "cwe": "CWE-703",
  "codeline": "if (dce110_clk_src_construct(clk_src, ctx, bios, id, \n regs, &cs_shift, &cs_mask)) { \n clk_src->base.dp_clk_src = dp_clk_src; \n return &clk_src->base; \n } \n BREAK_TO_DEBUGGER(); \n return NULL;"
}
{
  "idx": 443,
  "target": 1,
  "vul": "struct clock_source *dce80_clock_source_create( \n struct dc_context *ctx, \n struct dc_bios *bios, \n enum clock_source_id id, \n const struct dce110_clk_src_regs *regs, \n bool dp_clk_src) \n { \n struct dce110_clk_src *clk_src = \n kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL); \n if (!clk_src) \n return NULL; \n if (dce110_clk_src_construct(clk_src, ctx, bios, id, \n regs, &cs_shift, &cs_mask)) { \n clk_src->base.dp_clk_src = dp_clk_src; \n return &clk_src->base; \n } \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "no_vul": "struct clock_source *dce100_clock_source_create( \n struct dc_context *ctx, \n struct dc_bios *bios, \n enum clock_source_id id, \n const struct dce110_clk_src_regs *regs, \n bool dp_clk_src) \n { \n struct dce110_clk_src *clk_src = \n kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL); \n if (!clk_src) \n return NULL; \n if (dce110_clk_src_construct(clk_src, ctx, bios, id, \n regs, &cs_shift, &cs_mask)) { \n clk_src->base.dp_clk_src = dp_clk_src; \n return &clk_src->base; \n } \n kfree(clk_src); \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "cwe": "CWE-703",
  "codeline": "BREAK_TO_DEBUGGER();"
}
{
  "idx": 444,
  "target": 1,
  "vul": "struct clock_source *dcn10_clock_source_create( \n struct dc_context *ctx, \n struct dc_bios *bios, \n enum clock_source_id id, \n const struct dce110_clk_src_regs *regs, \n bool dp_clk_src) \n { \n struct dce110_clk_src *clk_src = \n kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL); \n if (!clk_src) \n return NULL; \n if (dce112_clk_src_construct(clk_src, ctx, bios, id, \n regs, &cs_shift, &cs_mask)) { \n clk_src->base.dp_clk_src = dp_clk_src; \n return &clk_src->base; \n } \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "no_vul": "struct clock_source *dce100_clock_source_create( \n struct dc_context *ctx, \n struct dc_bios *bios, \n enum clock_source_id id, \n const struct dce110_clk_src_regs *regs, \n bool dp_clk_src) \n { \n struct dce110_clk_src *clk_src = \n kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL); \n if (!clk_src) \n return NULL; \n if (dce110_clk_src_construct(clk_src, ctx, bios, id, \n regs, &cs_shift, &cs_mask)) { \n clk_src->base.dp_clk_src = dp_clk_src; \n return &clk_src->base; \n } \n kfree(clk_src); \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "cwe": "CWE-703",
  "codeline": "if (dce112_clk_src_construct(clk_src, ctx, bios, id, \n regs, &cs_shift, &cs_mask)) {"
}
{
  "idx": 445,
  "target": 1,
  "vul": "struct clock_source *dce112_clock_source_create( \n struct dc_context *ctx, \n struct dc_bios *bios, \n enum clock_source_id id, \n const struct dce110_clk_src_regs *regs, \n bool dp_clk_src) \n { \n struct dce110_clk_src *clk_src = \n kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL); \n if (!clk_src) \n return NULL; \n if (dce112_clk_src_construct(clk_src, ctx, bios, id, \n regs, &cs_shift, &cs_mask)) { \n clk_src->base.dp_clk_src = dp_clk_src; \n return &clk_src->base; \n } \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "no_vul": "struct clock_source *dce100_clock_source_create( \n struct dc_context *ctx, \n struct dc_bios *bios, \n enum clock_source_id id, \n const struct dce110_clk_src_regs *regs, \n bool dp_clk_src) \n { \n struct dce110_clk_src *clk_src = \n kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL); \n if (!clk_src) \n return NULL; \n if (dce110_clk_src_construct(clk_src, ctx, bios, id, \n regs, &cs_shift, &cs_mask)) { \n clk_src->base.dp_clk_src = dp_clk_src; \n return &clk_src->base; \n } \n kfree(clk_src); \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "cwe": "CWE-703",
  "codeline": "if (dce112_clk_src_construct(clk_src, ctx, bios, id, \n regs, &cs_shift, &cs_mask)) { \n clk_src->base.dp_clk_src = dp_clk_src; \n return &clk_src->base; \n } \n BREAK_TO_DEBUGGER(); \n return NULL;"
}
{
  "idx": 446,
  "target": 1,
  "vul": "struct clock_source *dce110_clock_source_create( \n struct dc_context *ctx, \n struct dc_bios *bios, \n enum clock_source_id id, \n const struct dce110_clk_src_regs *regs, \n bool dp_clk_src) \n { \n struct dce110_clk_src *clk_src = \n kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL); \n if (!clk_src) \n return NULL; \n if (dce110_clk_src_construct(clk_src, ctx, bios, id, \n regs, &cs_shift, &cs_mask)) { \n clk_src->base.dp_clk_src = dp_clk_src; \n return &clk_src->base; \n } \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "no_vul": "struct clock_source *dce100_clock_source_create( \n struct dc_context *ctx, \n struct dc_bios *bios, \n enum clock_source_id id, \n const struct dce110_clk_src_regs *regs, \n bool dp_clk_src) \n { \n struct dce110_clk_src *clk_src = \n kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL); \n if (!clk_src) \n return NULL; \n if (dce110_clk_src_construct(clk_src, ctx, bios, id, \n regs, &cs_shift, &cs_mask)) { \n clk_src->base.dp_clk_src = dp_clk_src; \n return &clk_src->base; \n } \n kfree(clk_src); \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "cwe": "CWE-703",
  "codeline": "if (dce110_clk_src_construct(clk_src, ctx, bios, id, \n regs, &cs_shift, &cs_mask)) { \n clk_src->base.dp_clk_src = dp_clk_src; \n return &clk_src->base; \n } \n BREAK_TO_DEBUGGER(); \n return NULL;"
}
{
  "idx": 447,
  "target": 1,
  "vul": "struct clock_source *dcn20_clock_source_create( \n struct dc_context *ctx, \n struct dc_bios *bios, \n enum clock_source_id id, \n const struct dce110_clk_src_regs *regs, \n bool dp_clk_src) \n { \n struct dce110_clk_src *clk_src = \n kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL); \n if (!clk_src) \n return NULL; \n if (dcn20_clk_src_construct(clk_src, ctx, bios, id, \n regs, &cs_shift, &cs_mask)) { \n clk_src->base.dp_clk_src = dp_clk_src; \n return &clk_src->base; \n } \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "no_vul": "struct clock_source *dcn10_clock_source_create( \n struct dc_context *ctx, \n struct dc_bios *bios, \n enum clock_source_id id, \n const struct dce110_clk_src_regs *regs, \n bool dp_clk_src) \n { \n struct dce110_clk_src *clk_src = \n kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL); \n if (!clk_src) \n return NULL; \n if (dce112_clk_src_construct(clk_src, ctx, bios, id, \n regs, &cs_shift, &cs_mask)) { \n clk_src->base.dp_clk_src = dp_clk_src; \n return &clk_src->base; \n } \n kfree(clk_src); \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "cwe": "CWE-703",
  "codeline": "if (dcn20_clk_src_construct(clk_src, ctx, bios, id, \n regs, &cs_shift, &cs_mask)) {"
}
{
  "idx": 448,
  "target": 1,
  "vul": "static struct clock_source *dce120_clock_source_create( \n struct dc_context *ctx, \n struct dc_bios *bios, \n enum clock_source_id id, \n const struct dce110_clk_src_regs *regs, \n bool dp_clk_src) \n { \n struct dce110_clk_src *clk_src = \n kzalloc(sizeof(*clk_src), GFP_KERNEL); \n if (!clk_src) \n return NULL; \n if (dce112_clk_src_construct(clk_src, ctx, bios, id, \n regs, &cs_shift, &cs_mask)) { \n clk_src->base.dp_clk_src = dp_clk_src; \n return &clk_src->base; \n } \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "no_vul": "static struct clock_source *dce120_clock_source_create( \n struct dc_context *ctx, \n struct dc_bios *bios, \n enum clock_source_id id, \n const struct dce110_clk_src_regs *regs, \n bool dp_clk_src) \n { \n struct dce110_clk_src *clk_src = \n kzalloc(sizeof(*clk_src), GFP_KERNEL); \n if (!clk_src) \n return NULL; \n if (dce112_clk_src_construct(clk_src, ctx, bios, id, \n regs, &cs_shift, &cs_mask)) { \n clk_src->base.dp_clk_src = dp_clk_src; \n return &clk_src->base; \n } \n kfree(clk_src); \n BREAK_TO_DEBUGGER(); \n return NULL; \n }",
  "cwe": "CWE-703",
  "codeline": "if (dce112_clk_src_construct(clk_src, ctx, bios, id, \n regs, &cs_shift, &cs_mask)) { \n clk_src->base.dp_clk_src = dp_clk_src; \n return &clk_src->base; \n } \n BREAK_TO_DEBUGGER(); \n return NULL;"
}
{
  "idx": 449,
  "target": 1,
  "vul": "ecryptfs_write_metadata_to_contents(struct ecryptfs_crypt_stat *crypt_stat, \n struct dentry *ecryptfs_dentry, \n char *virt) \n { \n int rc; \n rc = ecryptfs_write_lower(ecryptfs_dentry->d_inode, virt, \n 0, crypt_stat->num_header_bytes_at_front); \n if (rc) \n printk(KERN_ERR \"%s: Error attempting to write header \" \n \"information to lower file; rc = [%d]\\n\", __func__, \n rc); \n return rc; \n }",
  "no_vul": "ecryptfs_write_metadata_to_contents(struct dentry *ecryptfs_dentry, \n char *virt, size_t virt_len) \n { \n int rc; \n rc = ecryptfs_write_lower(ecryptfs_dentry->d_inode, virt, \n 0, virt_len); \n if (rc) \n printk(KERN_ERR \"%s: Error attempting to write header \" \n \"information to lower file; rc = [%d]\\n\", __func__, \n rc); \n return rc; \n }",
  "cwe": "CWE-189",
  "codeline": "rc = ecryptfs_write_lower(ecryptfs_dentry->d_inode, virt, \n 0, crypt_stat->num_header_bytes_at_front);"
}
{
  "idx": 450,
  "target": 1,
  "vul": "void auth_client_request_abort(struct auth_client_request **_request) \n { \n struct auth_client_request *request = *_request; \n *_request = NULL; \n auth_client_send_cancel(request->conn->client, request->id); \n call_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL); \n pool_unref(&request->pool); \n }",
  "no_vul": "void auth_client_request_abort(struct auth_client_request **_request) \n { \n struct auth_client_request *request = *_request; \n *_request = NULL; \n auth_client_send_cancel(request->conn->client, request->id); \n call_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL); \n auth_server_connection_remove_request(request->conn, request->id); \n pool_unref(&request->pool); \n }",
  "cwe": "CWE-772",
  "codeline": "auth_client_send_cancel(request->conn->client, request->id);"
}
{
  "idx": 451,
  "target": 1,
  "vul": "Agraph_t *agroot(void* obj) \n { \n switch (AGTYPE(obj)) { \n case AGINEDGE: \n case AGOUTEDGE: \n return ((Agedge_t *) obj)->node->root; \n case AGNODE: \n return ((Agnode_t *) obj)->root; \n case AGRAPH: \n return ((Agraph_t *) obj)->root; \n default: \n agerr(AGERR, \"agroot of a bad object\"); \n return NILgraph; \n } \n }",
  "no_vul": "Agraph_t *agraphof(void *obj) \n { \n switch (AGTYPE(obj)) { \n case AGINEDGE: \n case AGOUTEDGE: \n return ((Agedge_t *) obj)->node->root; \n case AGNODE: \n return ((Agnode_t *) obj)->root; \n case AGRAPH: \n return (Agraph_t *) obj; \n default: \n agerr(AGERR, \"agraphof a bad object\"); \n return NILgraph; \n } \n }",
  "cwe": "CWE-476",
  "codeline": "return ((Agraph_t *) obj)->root;"
}
{
  "idx": 452,
  "target": 1,
  "vul": "String UTF16BEDecoder::to_utf8(const StringView& input) \n { \n StringBuilder builder(input.length() / 2); \n for (size_t i = 0; i < input.length(); i += 2) { \n u16 code_point = (input[i] << 8) | input[i + 1]; \n builder.append_code_point(code_point); \n } \n return builder.to_string(); \n }",
  "no_vul": "String UTF16BEDecoder::to_utf8(const StringView& input) \n { \n StringBuilder builder(input.length() / 2); \n size_t utf16_length = input.length() - (input.length() % 2); \n for (size_t i = 0; i < utf16_length; i += 2) { \n u16 code_point = (input[i] << 8) | input[i + 1]; \n builder.append_code_point(code_point); \n } \n return builder.to_string(); \n }",
  "cwe": "CWE-120",
  "codeline": "for (size_t i = 0; i < input.length(); i += 2) {"
}
{
  "idx": 453,
  "target": 1,
  "vul": "bool read(ReadonlyBytes buffer) \n { \n auto fields_size = sizeof(EndOfCentralDirectory) - sizeof(u8*); \n if (buffer.size() < fields_size) \n return false; \n if (memcmp(buffer.data(), end_of_central_directory_signature, sizeof(end_of_central_directory_signature)) != 0) \n return false; \n memcpy(reinterpret_cast<void*>(&disk_number), buffer.data() + sizeof(end_of_central_directory_signature), fields_size); \n comment = buffer.data() + sizeof(end_of_central_directory_signature) + fields_size; \n return true; \n }",
  "no_vul": "bool read(ReadonlyBytes buffer) \n { \n auto fields_size = sizeof(EndOfCentralDirectory) - sizeof(u8*); \n if (buffer.size() < sizeof(end_of_central_directory_signature) + fields_size) \n return false; \n if (memcmp(buffer.data(), end_of_central_directory_signature, sizeof(end_of_central_directory_signature)) != 0) \n return false; \n memcpy(reinterpret_cast<void*>(&disk_number), buffer.data() + sizeof(end_of_central_directory_signature), fields_size); \n if (buffer.size() < sizeof(end_of_central_directory_signature) + fields_size + comment_length) \n return false; \n comment = buffer.data() + sizeof(end_of_central_directory_signature) + fields_size; \n return true; \n }",
  "cwe": "CWE-120",
  "codeline": "memcpy(reinterpret_cast<void*>(&disk_number), buffer.data() + sizeof(end_of_central_directory_signature), fields_size);"
}
{
  "idx": 454,
  "target": 1,
  "vul": "u32 GetHintFormat(GF_TrackBox *trak) \n { \n GF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader; \n if (hmhd->type != GF_ISOM_BOX_TYPE_HMHD) \n return 0; \n if (!hmhd || !hmhd->subType) { \n GF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0); \n if (!hmhd) return a ? a->type : 0; \n if (a) hmhd->subType = a->type; \n return hmhd->subType; \n } \n return hmhd->subType; \n }",
  "no_vul": "u32 GetHintFormat(GF_TrackBox *trak) \n { \n GF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader; \n if (!hmhd || (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)) \n return 0; \n if (!hmhd || !hmhd->subType) { \n GF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0); \n if (!hmhd) return a ? a->type : 0; \n if (a) hmhd->subType = a->type; \n return hmhd->subType; \n } \n return hmhd->subType; \n }",
  "cwe": "CWE-476",
  "codeline": "if (hmhd->type != GF_ISOM_BOX_TYPE_HMHD) \n return 0;"
}
{
  "idx": 455,
  "target": 1,
  "vul": "Status SetUnknownShape(const NodeDef* node, int output_port) { \n shape_inference::ShapeHandle shape = \n GetUnknownOutputShape(node, output_port); \n InferenceContext* ctx = GetContext(node); \n if (ctx == nullptr) { \n return errors::InvalidArgument(\"Missing context\"); \n } \n ctx->set_output(output_port, shape); \n return Status::OK(); \n }",
  "no_vul": "Status SetUnknownShape(const NodeDef* node, int output_port) { \n shape_inference::ShapeHandle shape = \n GetUnknownOutputShape(node, output_port); \n InferenceContext* ctx = GetContext(node); \n if (ctx == nullptr) { \n return errors::InvalidArgument(\"SetUnknownShape: Missing context\"); \n } \n if (output_port < 0 || output_port >= ctx->num_outputs()) { \n return errors::InvalidArgument( \n \"SetUnknownShape: output_port must be in [0, \", ctx->num_outputs(), \n \") but was \", output_port); \n } \n ctx->set_output(output_port, shape); \n return Status::OK(); \n }",
  "cwe": "CWE-787",
  "codeline": "ctx->set_output(output_port, shape);"
}
{
  "idx": 456,
  "target": 1,
  "vul": "bool IsIdentityConsumingSwitch(const MutableGraphView& graph, \n const NodeDef& node) { \n if ((IsIdentity(node) || IsIdentityNSingleInput(node)) && \n node.input_size() > 0) { \n TensorId tensor_id = ParseTensorName(node.input(0)); \n if (IsTensorIdControlling(tensor_id)) { \n return false; \n } \n NodeDef* input_node = graph.GetNode(tensor_id.node()); \n return IsSwitch(*input_node); \n } \n return false; \n }",
  "no_vul": "bool IsIdentityConsumingSwitch(const MutableGraphView& graph, \n const NodeDef& node) { \n if ((IsIdentity(node) || IsIdentityNSingleInput(node)) && \n node.input_size() > 0) { \n TensorId tensor_id = ParseTensorName(node.input(0)); \n if (IsTensorIdControlling(tensor_id)) { \n return false; \n } \n NodeDef* input_node = graph.GetNode(tensor_id.node()); \n if (input_node == nullptr) { \n return false; \n } \n return IsSwitch(*input_node); \n } \n return false; \n }",
  "cwe": "CWE-476",
  "codeline": "NodeDef* input_node = graph.GetNode(tensor_id.node());"
}
{
  "idx": 457,
  "target": 1,
  "vul": "int TfLiteIntArrayGetSizeInBytes(int size) { \n static TfLiteIntArray dummy; \n int computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size; \n #if defined(_MSC_VER) \n computed_size -= sizeof(dummy.data[0]); \n #endif \n return computed_size; \n }",
  "no_vul": "size_t TfLiteIntArrayGetSizeInBytes(int size) { \n static TfLiteIntArray dummy; \n size_t computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size; \n #if defined(_MSC_VER) \n computed_size -= sizeof(dummy.data[0]); \n #endif \n return computed_size; \n }",
  "cwe": "CWE-190",
  "codeline": "int TfLiteIntArrayGetSizeInBytes(int size) { \n static TfLiteIntArray dummy; \n int computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size; \n #if defined(_MSC_VER) \n computed_size -= sizeof(dummy.data[0]); \n #endif \n return computed_size; \n }"
}
{
  "idx": 458,
  "target": 1,
  "vul": "TfLiteIntArray* TfLiteIntArrayCreate(int size) { \n int alloc_size = TfLiteIntArrayGetSizeInBytes(size); \n if (alloc_size <= 0) return NULL; \n TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size); \n if (!ret) return ret; \n ret->size = size; \n return ret; \n }",
  "no_vul": "TfLiteIntArray* TfLiteIntArrayCreate(int size) { \n size_t alloc_size = TfLiteIntArrayGetSizeInBytes(size); \n if (alloc_size <= 0) return NULL; \n TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size); \n if (!ret) return ret; \n ret->size = size; \n return ret; \n }",
  "cwe": "CWE-190",
  "codeline": "int alloc_size = TfLiteIntArrayGetSizeInBytes(size);"
}
{
  "idx": 459,
  "target": 1,
  "vul": "void gitn_box_del(GF_Box *s) \n { \n u32 i; \n GroupIdToNameBox *ptr = (GroupIdToNameBox *)s; \n if (ptr == NULL) return; \n for (i=0; i<ptr->nb_entries; i++) { \n if (ptr->entries[i].name) gf_free(ptr->entries[i].name); \n } \n if (ptr->entries) gf_free(ptr->entries); \n gf_free(ptr);",
  "no_vul": "void gitn_box_del(GF_Box *s) \n { \n u32 i; \n GroupIdToNameBox *ptr = (GroupIdToNameBox *)s; \n if (ptr == NULL) return; \n if (ptr->entries) { \n for (i=0; i<ptr->nb_entries; i++) { \n if (ptr->entries[i].name) gf_free(ptr->entries[i].name); \n } \n gf_free(ptr->entries); \n } \n gf_free(ptr);",
  "cwe": "CWE-476",
  "codeline": "if (ptr->entries) gf_free(ptr->entries);"
}
{
  "idx": 460,
  "target": 1,
  "vul": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len) \n { \n VirtQueueElement elem; \n VirtQueue *vq; \n vq = vser->c_ivq; \n if (!virtio_queue_ready(vq)) { \n return 0; \n } \n if (!virtqueue_pop(vq, &elem)) { \n return 0; \n } \n memcpy(elem.in_sg[0].iov_base, buf, len); \n virtqueue_push(vq, &elem, len); \n virtio_notify(VIRTIO_DEVICE(vser), vq); \n return len; \n }",
  "no_vul": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len) \n { \n VirtQueueElement elem; \n VirtQueue *vq; \n vq = vser->c_ivq; \n if (!virtio_queue_ready(vq)) { \n return 0; \n } \n if (!virtqueue_pop(vq, &elem)) { \n return 0; \n } \n iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len); \n virtqueue_push(vq, &elem, len); \n virtio_notify(VIRTIO_DEVICE(vser), vq); \n return len; \n }",
  "cwe": "CWE-787",
  "codeline": "memcpy(elem.in_sg[0].iov_base, buf, len);"
}
{
  "idx": 461,
  "target": 1,
  "vul": "GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs) \n { \n u32 i; \n char str[1024]; \n GF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s; \n i=0; \n str[0]=0; \n while (1) { \n str[i] = gf_bs_read_u8(bs); \n if (!str[i]) break; \n i++; \n } \n ISOM_DECREASE_SIZE(p, i); \n p->content_script_types = gf_strdup(str); \n return GF_OK; \n }",
  "no_vul": "GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs) \n { \n GF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s; \n p->content_script_types = gf_malloc(sizeof(char) * (s->size+1)); \n if (!p->content_script_types) return GF_OUT_OF_MEM; \n gf_bs_read_data(bs, p->content_script_types, s->size); \n p->content_script_types[s->size] = 0; \n return GF_OK; \n }",
  "cwe": "CWE-703",
  "codeline": "str[i] = gf_bs_read_u8(bs);"
}
{
  "idx": 462,
  "target": 1,
  "vul": "int digest_generic_verify(struct digest *d, const unsigned char *md) \n { \n int ret; \n int len = digest_length(d); \n unsigned char *tmp; \n tmp = xmalloc(len); \n ret = digest_final(d, tmp); \n if (ret) \n goto end; \n ret = memcmp(md, tmp, len); \n ret = ret ? -EINVAL : 0; \n end: \n free(tmp); \n return ret; \n }",
  "no_vul": "int digest_generic_verify(struct digest *d, const unsigned char *md) \n { \n int ret; \n int len = digest_length(d); \n unsigned char *tmp; \n tmp = xmalloc(len); \n ret = digest_final(d, tmp); \n if (ret) \n goto end; \n if (crypto_memneq(md, tmp, len)) \n ret = -EINVAL; \n else \n ret = 0; \n end: \n free(tmp); \n return ret; \n }",
  "cwe": "CWE-200",
  "codeline": "ret = memcmp(md, tmp, len);"
}
{
  "idx": 463,
  "target": 1,
  "vul": "mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid) \n { \n mt_tbl *h; \n MRB_CLASS_ORIGIN(c); \n h = c->mt; \n if (h && mt_del(mrb, h, mid)) return; \n mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c); \n }",
  "no_vul": "mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid) \n { \n mt_tbl *h; \n MRB_CLASS_ORIGIN(c); \n h = c->mt; \n if (h && mt_del(mrb, h, mid)) { \n mrb_mc_clear_by_class(mrb, c); \n return; \n } \n mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c); \n }",
  "cwe": "CWE-787",
  "codeline": "if (h && mt_del(mrb, h, mid)) return;"
}
{
  "idx": 464,
  "target": 1,
  "vul": "Status SparseCountSparseOutputShapeFn(InferenceContext *c) { \n auto rank = c->Dim(c->input(0), 1); \n auto nvals = c->UnknownDim(); \n c->set_output(0, c->Matrix(nvals, rank)); \n c->set_output(1, c->Vector(nvals)); \n c->set_output(2, c->Vector(rank)); \n return Status::OK(); \n }",
  "no_vul": "Status SparseCountSparseOutputShapeFn(InferenceContext *c) { \n ShapeHandle unused; \n TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused)); \n auto rank = c->Dim(c->input(0), 1); \n auto nvals = c->UnknownDim(); \n c->set_output(0, c->Matrix(nvals, rank)); \n c->set_output(1, c->Vector(nvals)); \n c->set_output(2, c->Vector(rank)); \n return Status::OK(); \n }",
  "cwe": "CWE-125",
  "codeline": "auto rank = c->Dim(c->input(0), 1);"
}
{
  "idx": 465,
  "target": 1,
  "vul": "void Compute(OpKernelContext* ctx) override { \n const Tensor& handle = ctx->input(0); \n const string& name = handle.scalar<tstring>()(); \n auto session_state = ctx->session_state(); \n OP_REQUIRES(ctx, session_state != nullptr, \n errors::FailedPrecondition( \n \"DeleteSessionTensor called on null session state\")); \n OP_REQUIRES_OK(ctx, session_state->DeleteTensor(name)); \n }",
  "no_vul": "void Compute(OpKernelContext* ctx) override { \n const Tensor& handle = ctx->input(0); \n OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(handle.shape()), \n errors::InvalidArgument(\"`handle` must be scalar\")); \n const string& name = handle.scalar<tstring>()(); \n auto session_state = ctx->session_state(); \n OP_REQUIRES(ctx, session_state != nullptr, \n errors::FailedPrecondition( \n \"DeleteSessionTensor called on null session state\")); \n OP_REQUIRES_OK(ctx, session_state->DeleteTensor(name)); \n }",
  "cwe": "CWE-703",
  "codeline": "const string& name = handle.scalar<tstring>()();"
}
{
  "idx": 466,
  "target": 1,
  "vul": "TfLiteStatus Gather(const TfLiteGatherParams& params, const TfLiteTensor* input, \n const TfLiteTensor* positions, TfLiteTensor* output) { \n tflite::GatherParams op_params; \n op_params.axis = params.axis; \n op_params.batch_dims = params.batch_dims; \n optimized_ops::Gather(op_params, GetTensorShape(input), \n GetTensorData<InputT>(input), GetTensorShape(positions), \n GetTensorData<PositionsT>(positions), \n GetTensorShape(output), GetTensorData<InputT>(output)); \n return kTfLiteOk; \n }",
  "no_vul": "TfLiteStatus Gather(TfLiteContext* context, const TfLiteGatherParams& params, \n const TfLiteTensor* input, const TfLiteTensor* positions, \n TfLiteTensor* output) { \n const PositionsT* indexes = GetTensorData<PositionsT>(positions); \n bool indices_has_only_positive_elements = true; \n const size_t num_indices = positions->bytes / sizeof(PositionsT); \n for (size_t i = 0; i < num_indices; i++) { \n if (indexes[i] < 0) { \n indices_has_only_positive_elements = false; \n break; \n } \n } \n TF_LITE_ENSURE(context, indices_has_only_positive_elements); \n tflite::GatherParams op_params; \n op_params.axis = params.axis; \n op_params.batch_dims = params.batch_dims; \n optimized_ops::Gather(op_params, GetTensorShape(input), \n GetTensorData<InputT>(input), GetTensorShape(positions), \n GetTensorData<PositionsT>(positions), \n GetTensorShape(output), GetTensorData<InputT>(output)); \n return kTfLiteOk; \n }",
  "cwe": "CWE-703",
  "codeline": "const PositionsT* indexes = GetTensorData<PositionsT>(positions);"
}
{
  "idx": 467,
  "target": 1,
  "vul": "TfLiteTensor* GetVariableInput(TfLiteContext* context, const TfLiteNode* node, \n int index) { \n TfLiteTensor* tensor = GetMutableInput(context, node, index); \n return tensor->is_variable ? tensor : nullptr; \n }",
  "no_vul": "TfLiteTensor* GetVariableInput(TfLiteContext* context, const TfLiteNode* node, \n int index) { \n TfLiteTensor* tensor = GetMutableInput(context, node, index); \n if (tensor == nullptr) return nullptr; \n return tensor->is_variable ? tensor : nullptr; \n }",
  "cwe": "CWE-369",
  "codeline": "TfLiteTensor* tensor = GetMutableInput(context, node, index);"
}
{
  "idx": 468,
  "target": 1,
  "vul": "static void rtrs_clt_dev_release(struct device *dev) \n { \n struct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess, \n dev); \n kfree(clt); \n }",
  "no_vul": "static void rtrs_clt_dev_release(struct device *dev) \n { \n struct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess, \n dev); \n mutex_destroy(&clt->paths_ev_mutex); \n mutex_destroy(&clt->paths_mutex); \n kfree(clt); \n }",
  "cwe": "CWE-415",
  "codeline": "kfree(clt);"
}
{
  "idx": 469,
  "target": 1,
  "vul": "PJ_DEF(int) pj_scan_get_char( pj_scanner *scanner ) \n { \n int chr = *scanner->curptr; \n if (!chr) { \n pj_scan_syntax_err(scanner); \n return 0; \n } \n ++scanner->curptr; \n if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && scanner->skip_ws) { \n pj_scan_skip_whitespace(scanner); \n } \n return chr; \n }",
  "no_vul": "PJ_DEF(int) pj_scan_get_char( pj_scanner *scanner ) \n { \n register char *s = scanner->curptr; \n int chr; \n if (s >= scanner->end || !*s) { \n pj_scan_syntax_err(scanner); \n return 0; \n } \n chr = *s; \n ++s; \n scanner->curptr = s; \n if (PJ_SCAN_CHECK_EOF(s) && PJ_SCAN_IS_PROBABLY_SPACE(*s) && \n scanner->skip_ws) \n { \n pj_scan_skip_whitespace(scanner); \n } \n return chr; \n }",
  "cwe": "CWE-125",
  "codeline": "++scanner->curptr;"
}
{
  "idx": 470,
  "target": 1,
  "vul": "static int selinux_ptrace_traceme(struct task_struct *parent) \n { \n return avc_has_perm(&selinux_state, \n task_sid_subj(parent), task_sid_obj(current), \n SECCLASS_PROCESS, PROCESS__PTRACE, NULL); \n }",
  "no_vul": "static int selinux_ptrace_traceme(struct task_struct *parent) \n { \n return avc_has_perm(&selinux_state, \n task_sid_obj(parent), task_sid_obj(current), \n SECCLASS_PROCESS, PROCESS__PTRACE, NULL); \n }",
  "cwe": "CWE-416",
  "codeline": "task_sid_subj(parent)"
}
{
  "idx": 471,
  "target": 1,
  "vul": "static Bigint * Balloc(int k) \n { \n int x; \n Bigint *rv; \n _THREAD_PRIVATE_MUTEX_LOCK(dtoa_mutex); \n if ((rv = freelist[k])) { \n freelist[k] = rv->next; \n } else { \n x = 1 << k; \n rv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(Long)); \n rv->k = k; \n rv->maxwds = x; \n } \n _THREAD_PRIVATE_MUTEX_UNLOCK(dtoa_mutex); \n rv->sign = rv->wds = 0; \n return rv; \n }",
  "no_vul": "static Bigint * Balloc(int k) \n { \n int x; \n Bigint *rv; \n if (k > Kmax) { \n zend_error(E_ERROR, \"Balloc() allocation exceeds list boundary\"); \n } \n _THREAD_PRIVATE_MUTEX_LOCK(dtoa_mutex); \n if ((rv = freelist[k])) { \n freelist[k] = rv->next; \n } else { \n x = 1 << k; \n rv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(Long)); \n if (!rv) { \n _THREAD_PRIVATE_MUTEX_UNLOCK(dtoa_mutex); \n zend_error(E_ERROR, \"Balloc() failed to allocate memory\"); \n } \n rv->k = k; \n rv->maxwds = x; \n } \n _THREAD_PRIVATE_MUTEX_UNLOCK(dtoa_mutex); \n rv->sign = rv->wds = 0; \n return rv; \n }",
  "cwe": "CWE-119",
  "codeline": "x = 1 << k;"
}
{
  "idx": 472,
  "target": 1,
  "vul": "static void virtbt_rx_handle(struct virtio_bluetooth *vbt, struct sk_buff *skb) \n { \n __u8 pkt_type; \n pkt_type = *((__u8 *) skb->data); \n skb_pull(skb, 1); \n switch (pkt_type) { \n case HCI_EVENT_PKT: \n case HCI_ACLDATA_PKT: \n case HCI_SCODATA_PKT: \n case HCI_ISODATA_PKT: \n hci_skb_pkt_type(skb) = pkt_type; \n hci_recv_frame(vbt->hdev, skb); \n break; \n } \n }",
  "no_vul": "static void virtbt_rx_handle(struct virtio_bluetooth *vbt, struct sk_buff *skb) \n { \n __u8 pkt_type; \n pkt_type = *((__u8 *) skb->data); \n skb_pull(skb, 1); \n switch (pkt_type) { \n case HCI_EVENT_PKT: \n case HCI_ACLDATA_PKT: \n case HCI_SCODATA_PKT: \n case HCI_ISODATA_PKT: \n hci_skb_pkt_type(skb) = pkt_type; \n hci_recv_frame(vbt->hdev, skb); \n break; \n default: \n kfree_skb(skb); \n break; \n } \n }",
  "cwe": "CWE-772",
  "codeline": "skb_pull(skb, 1);"
}
{
  "idx": 473,
  "target": 1,
  "vul": "struct vfsmount *clone_private_mount(const struct path *path) \n { \n struct mount *old_mnt = real_mount(path->mnt); \n struct mount *new_mnt; \n if (IS_MNT_UNBINDABLE(old_mnt)) \n return ERR_PTR(-EINVAL); \n new_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE); \n if (IS_ERR(new_mnt)) \n return ERR_CAST(new_mnt); \n new_mnt->mnt_ns = MNT_NS_INTERNAL; \n return &new_mnt->mnt; \n }",
  "no_vul": "struct vfsmount *clone_private_mount(const struct path *path) \n { \n struct mount *old_mnt = real_mount(path->mnt); \n struct mount *new_mnt; \n down_read(&namespace_sem); \n if (IS_MNT_UNBINDABLE(old_mnt)) \n goto invalid; \n if (!check_mnt(old_mnt)) \n goto invalid; \n if (has_locked_children(old_mnt, path->dentry)) \n goto invalid; \n new_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE); \n up_read(&namespace_sem); \n if (IS_ERR(new_mnt)) \n return ERR_CAST(new_mnt); \n new_mnt->mnt_ns = MNT_NS_INTERNAL; \n return &new_mnt->mnt; \n invalid: \n up_read(&namespace_sem); \n return ERR_PTR(-EINVAL); \n }",
  "cwe": "CWE-200",
  "codeline": "if (IS_MNT_UNBINDABLE(old_mnt)) \n return ERR_PTR(-EINVAL);"
}
{
  "idx": 474,
  "target": 1,
  "vul": "gpg_ctx_add_recipient (struct _GpgCtx *gpg, \n const gchar *keyid) \n { \n if (gpg->mode != GPG_CTX_MODE_ENCRYPT && gpg->mode != GPG_CTX_MODE_EXPORT) \n return; \n if (!gpg->recipients) \n gpg->recipients = g_ptr_array_new (); \n g_ptr_array_add (gpg->recipients, g_strdup (keyid)); \n }",
  "no_vul": "gpg_ctx_add_recipient (struct _GpgCtx *gpg, \n const gchar *keyid) \n { \n gchar *safe_keyid; \n if (gpg->mode != GPG_CTX_MODE_ENCRYPT && gpg->mode != GPG_CTX_MODE_EXPORT) \n return; \n if (!gpg->recipients) \n gpg->recipients = g_ptr_array_new (); \n g_return_if_fail (keyid != NULL); \n if (strchr (keyid, '@') != NULL) { \n safe_keyid = g_strdup_printf (\"<%s>\", keyid); \n } else { \n safe_keyid = g_strdup (keyid); \n } \n g_ptr_array_add (gpg->recipients, safe_keyid); \n }",
  "cwe": "CWE-200",
  "codeline": "g_ptr_array_add (gpg->recipients, g_strdup (keyid));"
}
{
  "idx": 475,
  "target": 1,
  "vul": "static SQInteger thread_call(HSQUIRRELVM v) \n { \n SQObjectPtr o = stack_get(v,1); \n if(sq_type(o) == OT_THREAD) { \n SQInteger nparams = sq_gettop(v); \n _thread(o)->Push(_thread(o)->_roottable); \n for(SQInteger i = 2; i<(nparams+1); i++) \n sq_move(_thread(o),v,i); \n if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) { \n sq_move(v,_thread(o),-1); \n sq_pop(_thread(o),1); \n return 1; \n } \n v->_lasterror = _thread(o)->_lasterror; \n return SQ_ERROR; \n } \n return sq_throwerror(v,_SC(\"wrong parameter\")); \n }",
  "no_vul": "static SQInteger thread_call(HSQUIRRELVM v) \n { \n SQObjectPtr o = stack_get(v,1); \n if(sq_type(o) == OT_THREAD) { \n SQInteger nparams = sq_gettop(v); \n sq_reservestack(_thread(o), nparams + 3); \n _thread(o)->Push(_thread(o)->_roottable); \n for(SQInteger i = 2; i<(nparams+1); i++) \n sq_move(_thread(o),v,i); \n if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) { \n sq_move(v,_thread(o),-1); \n sq_pop(_thread(o),1); \n return 1; \n } \n v->_lasterror = _thread(o)->_lasterror; \n return SQ_ERROR; \n } \n return sq_throwerror(v,_SC(\"wrong parameter\")); \n }",
  "cwe": "CWE-703",
  "codeline": "sq_reservestack(_thread(o), nparams + 3);"
}
{
  "idx": 476,
  "target": 1,
  "vul": "TerminalUserInfo UserTerminalRouter::getInfoForId(const string &id) { \n auto it = idInfoMap.find(id); \n if (it == idInfoMap.end()) { \n STFATAL << \" Tried to read from an id that no longer exists\"; \n } \n return it->second; \n }",
  "no_vul": "TerminalUserInfo UserTerminalRouter::getInfoForId(const string &id) { \n lock_guard<recursive_mutex> guard(routerMutex); \n auto it = idInfoMap.find(id); \n if (it == idInfoMap.end()) { \n STFATAL << \" Tried to read from an id that no longer exists\"; \n } \n return it->second; \n }",
  "cwe": "CWE-362",
  "codeline": "auto it = idInfoMap.find(id);"
}
{
  "idx": 477,
  "target": 1,
  "vul": "void update_process_times(int user_tick) \n { \n struct task_struct *p = current; \n account_process_tick(p, user_tick); \n run_local_timers(); \n rcu_sched_clock_irq(user_tick); \n #ifdef CONFIG_IRQ_WORK \n if (in_irq()) \n irq_work_tick(); \n #endif \n scheduler_tick(); \n if (IS_ENABLED(CONFIG_POSIX_TIMERS)) \n run_posix_cpu_timers(); \n }",
  "no_vul": "void update_process_times(int user_tick) \n { \n struct task_struct *p = current; \n account_process_tick(p, user_tick); \n run_local_timers(); \n rcu_sched_clock_irq(user_tick); \n #ifdef CONFIG_IRQ_WORK \n if (in_irq()) \n irq_work_tick(); \n #endif \n scheduler_tick(); \n if (IS_ENABLED(CONFIG_POSIX_TIMERS)) \n run_posix_cpu_timers(); \n this_cpu_add(net_rand_state.s1, rol32(jiffies, 24) + user_tick); \n }",
  "cwe": "CWE-200",
  "codeline": "this_cpu_add(net_rand_state.s1, rol32(jiffies, 24) + user_tick);"
}
{
  "idx": 478,
  "target": 1,
  "vul": "static RzList *relocs(RzBinFile *bf) { \n rz_return_val_if_fail(bf && bf->o, NULL); \n QnxObj *qo = bf->o->bin_obj; \n return rz_list_clone(qo->fixups); \n }",
  "no_vul": "static RzList *maps(RzBinFile *bf) { \n rz_return_val_if_fail(bf && bf->o, NULL); \n QnxObj *qo = bf->o->bin_obj; \n return rz_list_clone(qo->maps); \n }",
  "cwe": "CWE-415",
  "codeline": "return rz_list_clone(qo->fixups);"
}
{
  "idx": 479,
  "target": 1,
  "vul": "PlayerGeneric::~PlayerGeneric() \n { \n if (mixer) \n delete mixer; \n if (player) \n { \n if (mixer->isActive() && !mixer->isDeviceRemoved(player)) \n mixer->removeDevice(player); \n delete player; \n } \n delete[] audioDriverName; \n delete listener; \n }",
  "no_vul": "PlayerGeneric::~PlayerGeneric() \n { \n if (player) \n { \n if (mixer && mixer->isActive() && !mixer->isDeviceRemoved(player)) \n mixer->removeDevice(player); \n delete player; \n } \n if (mixer) \n delete mixer; \n delete[] audioDriverName; \n delete listener; \n }",
  "cwe": "CWE-416",
  "codeline": "if (mixer->isActive() && !mixer->isDeviceRemoved(player))"
}
{
  "idx": 480,
  "target": 1,
  "vul": "void jsP_dumpsyntax(js_State *J, js_Ast *prog, int dominify) \n { \n minify = dominify; \n if (prog->type == AST_LIST) \n pstmlist(-1, prog); \n else { \n pstm(0, prog); \n nl(); \n } \n if (minify > 1) \n putchar('\\n'); \n }",
  "no_vul": "void jsP_dumpsyntax(js_State *J, js_Ast *prog, int dominify) \n { \n minify = dominify; \n if (prog) { \n if (prog->type == AST_LIST) \n pstmlist(-1, prog); \n else { \n pstm(0, prog); \n nl(); \n } \n } \n if (minify > 1) \n putchar('\\n'); \n }",
  "cwe": "CWE-476",
  "codeline": "if (prog->type == AST_LIST) \npstmlist(-1, prog); \nelse { \npstm(0, prog); \nnl(); \n}"
}
{
  "idx": 481,
  "target": 1,
  "vul": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block) \n { \n if (!block) { \n return; \n } \n QLIST_REMOVE(block, next); \n uc->ram_list.mru_block = NULL; \n reclaim_ramblock(uc, block); \n }",
  "no_vul": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block) \n { \n if (!block) { \n return; \n } \n QLIST_REMOVE_RCU(block, next); \n uc->ram_list.mru_block = NULL; \n reclaim_ramblock(uc, block); \n }",
  "cwe": "CWE-476",
  "codeline": "QLIST_REMOVE(block, next);"
}
{
  "idx": 482,
  "target": 1,
  "vul": "static int i2c_ddc_rx(I2CSlave *i2c) \n { \n I2CDDCState *s = I2CDDC(i2c); \n int value; \n value = s->edid_blob[s->reg]; \n s->reg++; \n return value; \n }",
  "no_vul": "static int i2c_ddc_rx(I2CSlave *i2c) \n { \n I2CDDCState *s = I2CDDC(i2c); \n int value; \n value = s->edid_blob[s->reg % sizeof(s->edid_blob)]; \n s->reg++; \n return value; \n }",
  "cwe": "CWE-125",
  "codeline": "s->reg++;"
}
{
  "idx": 483,
  "target": 1,
  "vul": "e1000_send_packet(E1000State *s, const uint8_t *buf, int size) \n { \n static const int PTCregs[6] = { PTC64, PTC127, PTC255, PTC511, \n PTC1023, PTC1522 }; \n NetClientState *nc = qemu_get_queue(s->nic); \n if (s->phy_reg[PHY_CTRL] & MII_CR_LOOPBACK) { \n nc->info->receive(nc, buf, size); \n } else { \n qemu_send_packet(nc, buf, size); \n } \n inc_tx_bcast_or_mcast_count(s, buf); \n e1000x_increase_size_stats(s->mac_reg, PTCregs, size); \n }",
  "no_vul": "e1000_send_packet(E1000State *s, const uint8_t *buf, int size) \n { \n static const int PTCregs[6] = { PTC64, PTC127, PTC255, PTC511, \n PTC1023, PTC1522 }; \n NetClientState *nc = qemu_get_queue(s->nic); \n if (s->phy_reg[PHY_CTRL] & MII_CR_LOOPBACK) { \n qemu_receive_packet(nc, buf, size); \n } else { \n qemu_send_packet(nc, buf, size); \n } \n inc_tx_bcast_or_mcast_count(s, buf); \n e1000x_increase_size_stats(s->mac_reg, PTCregs, size); \n }",
  "cwe": "CWE-835",
  "codeline": "nc->info->receive(nc, buf, size);"
}
{
  "idx": 484,
  "target": 1,
  "vul": "static void atusb_disconnect(struct usb_interface *interface) \n { \n struct atusb *atusb = usb_get_intfdata(interface); \n dev_dbg(&atusb->usb_dev->dev, \"%s\\n\", __func__); \n atusb->shutdown = 1; \n cancel_delayed_work_sync(&atusb->work); \n usb_kill_anchored_urbs(&atusb->rx_urbs); \n atusb_free_urbs(atusb); \n usb_kill_urb(atusb->tx_urb); \n usb_free_urb(atusb->tx_urb); \n ieee802154_unregister_hw(atusb->hw); \n ieee802154_free_hw(atusb->hw); \n usb_set_intfdata(interface, NULL); \n usb_put_dev(atusb->usb_dev); \n pr_debug(\"%s done\\n\", __func__); \n }",
  "no_vul": "static void atusb_disconnect(struct usb_interface *interface) \n { \n struct atusb *atusb = usb_get_intfdata(interface); \n dev_dbg(&atusb->usb_dev->dev, \"%s\\n\", __func__); \n atusb->shutdown = 1; \n cancel_delayed_work_sync(&atusb->work); \n usb_kill_anchored_urbs(&atusb->rx_urbs); \n atusb_free_urbs(atusb); \n usb_kill_urb(atusb->tx_urb); \n usb_free_urb(atusb->tx_urb); \n ieee802154_unregister_hw(atusb->hw); \n usb_put_dev(atusb->usb_dev); \n ieee802154_free_hw(atusb->hw); \n usb_set_intfdata(interface, NULL); \n pr_debug(\"%s done\\n\", __func__); \n }",
  "cwe": "CWE-416",
  "codeline": "ieee802154_free_hw(atusb->hw);"
}
{
  "idx": 485,
  "target": 1,
  "vul": "http_isfiltered(const struct http *fm, unsigned u, unsigned how) \n { \n const char *e; \n const struct http_hdrflg *f; \n if (fm->hdf[u] & HDF_FILTER) \n return (1); \n e = strchr(fm->hd[u].b, ':'); \n if (e == NULL) \n return (0); \n f = http_hdr_flags(fm->hd[u].b, e); \n return (f != NULL && f->flag & how); \n }",
  "no_vul": "http_isfiltered(const struct http *fm, unsigned u, unsigned how) \n { \n const char *e; \n const struct http_hdrflg *f; \n if (fm->hdf[u] & HDF_FILTER) \n return (1); \n if (u < HTTP_HDR_FIRST) \n return (0); \n e = strchr(fm->hd[u].b, ':'); \n if (e == NULL) \n return (0); \n f = http_hdr_flags(fm->hd[u].b, e); \n return (f != NULL && f->flag & how); \n }",
  "cwe": "CWE-703",
  "codeline": "if (fm->hdf[u] & HDF_FILTER) \n return (1);"
}
{
  "idx": 486,
  "target": 1,
  "vul": "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap) \n { \n u32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size; \n int err; \n smap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries, \n smap->map.numa_node); \n if (!smap->elems) \n return -ENOMEM; \n err = pcpu_freelist_init(&smap->freelist); \n if (err) \n goto free_elems; \n pcpu_freelist_populate(&smap->freelist, smap->elems, elem_size, \n smap->map.max_entries); \n return 0; \n free_elems: \n bpf_map_area_free(smap->elems); \n return err; \n }",
  "no_vul": "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap) \n { \n u64 elem_size = sizeof(struct stack_map_bucket) + \n (u64)smap->map.value_size; \n int err; \n smap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries, \n smap->map.numa_node); \n if (!smap->elems) \n return -ENOMEM; \n err = pcpu_freelist_init(&smap->freelist); \n if (err) \n goto free_elems; \n pcpu_freelist_populate(&smap->freelist, smap->elems, elem_size, \n smap->map.max_entries); \n return 0; \n free_elems: \n bpf_map_area_free(smap->elems); \n return err; \n }",
  "cwe": "CWE-787",
  "codeline": "u32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size;"
}
{
  "idx": 487,
  "target": 1,
  "vul": "pcl_status_read(byte * data, uint max_data, pcl_state_t * pcs) \n { \n uint count = min(max_data, \n pcs->status.write_pos - pcs->status.read_pos); \n if (count) \n memcpy(data, pcs->status.buffer + pcs->status.read_pos, count); \n pcs->status.read_pos += count; \n if (pcs->status.read_pos == pcs->status.write_pos) { \n gs_free_object(pcs->memory, pcs->status.buffer, \"status buffer\"); \n pcs->status.write_pos = pcs->status.read_pos = 0; \n } \n return count; \n }",
  "no_vul": "pcl_status_read(byte * data, uint max_data, pcl_state_t * pcs) \n { \n uint count = min(max_data, \n pcs->status.write_pos - pcs->status.read_pos); \n if (count) \n memcpy(data, pcs->status.buffer + pcs->status.read_pos, count); \n pcs->status.read_pos += count; \n if (pcs->status.read_pos == pcs->status.write_pos) { \n gs_free_object(pcs->memory, pcs->status.buffer, \"status buffer\"); \n pcs->status.buffer = NULL; \n pcs->status.write_pos = pcs->status.read_pos = 0; \n } \n return count; \n }",
  "cwe": "CWE-787",
  "codeline": "pcs->status.buffer = NULL;"
}
{
  "idx": 488,
  "target": 1,
  "vul": "static void sungem_send_packet(SunGEMState *s, const uint8_t *buf, \n int size) \n { \n NetClientState *nc = qemu_get_queue(s->nic); \n if (s->macregs[MAC_XIFCFG >> 2] & MAC_XIFCFG_LBCK) { \n nc->info->receive(nc, buf, size); \n } else { \n qemu_send_packet(nc, buf, size); \n } \n }",
  "no_vul": "static void sungem_send_packet(SunGEMState *s, const uint8_t *buf, \n int size) \n { \n NetClientState *nc = qemu_get_queue(s->nic); \n if (s->macregs[MAC_XIFCFG >> 2] & MAC_XIFCFG_LBCK) { \n qemu_receive_packet(nc, buf, size); \n } else { \n qemu_send_packet(nc, buf, size); \n } \n }",
  "cwe": "CWE-835",
  "codeline": "nc->info->receive(nc, buf, size);"
}
{
  "idx": 489,
  "target": 1,
  "vul": "void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv) \n { \n struct nci_dev *ndev = priv->ndev; \n if (priv->ndev->nfc_dev->fw_download_in_progress) \n nfcmrvl_fw_dnld_abort(priv); \n nfcmrvl_fw_dnld_deinit(priv); \n if (gpio_is_valid(priv->config.reset_n_io)) \n gpio_free(priv->config.reset_n_io); \n nci_unregister_device(ndev); \n nci_free_device(ndev); \n kfree(priv); \n }",
  "no_vul": "void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv) \n { \n struct nci_dev *ndev = priv->ndev; \n nci_unregister_device(ndev); \n if (priv->ndev->nfc_dev->fw_download_in_progress) \n nfcmrvl_fw_dnld_abort(priv); \n nfcmrvl_fw_dnld_deinit(priv); \n if (gpio_is_valid(priv->config.reset_n_io)) \n gpio_free(priv->config.reset_n_io); \n nci_free_device(ndev); \n kfree(priv); \n }",
  "cwe": "CWE-416",
  "codeline": "nci_unregister_device(ndev);"
}
{
  "idx": 490,
  "target": 1,
  "vul": "FindEmptyObjectSlot( \n TPMI_DH_OBJECT *handle \n ) \n { \n UINT32 i; \n OBJECT *object; \n for(i = 0; i < MAX_LOADED_OBJECTS; i++) \n { \n object = &s_objects[i]; \n if(object->attributes.occupied == CLEAR) \n { \n if(handle) \n *handle = i + TRANSIENT_FIRST; \n MemorySet(&object->attributes, 0, sizeof(OBJECT_ATTRIBUTES)); \n return object; \n } \n } \n return NULL; \n }",
  "no_vul": "FindEmptyObjectSlot( \n TPMI_DH_OBJECT *handle \n ) \n { \n UINT32 i; \n OBJECT *object; \n for(i = 0; i < MAX_LOADED_OBJECTS; i++) \n { \n object = &s_objects[i]; \n if(object->attributes.occupied == CLEAR) \n { \n if(handle) \n *handle = i + TRANSIENT_FIRST; \n MemorySet(object, 0, sizeof(*object)); \n return object; \n } \n } \n return NULL; \n }",
  "cwe": "CWE-119",
  "codeline": "MemorySet(&object->attributes, 0, sizeof(OBJECT_ATTRIBUTES));"
}
{
  "idx": 491,
  "target": 1,
  "vul": "static ssize_t cgroup_release_agent_write(struct kernfs_open_file *of, \n char *buf, size_t nbytes, loff_t off) \n { \n struct cgroup *cgrp; \n BUILD_BUG_ON(sizeof(cgrp->root->release_agent_path) < PATH_MAX); \n cgrp = cgroup_kn_lock_live(of->kn, false); \n if (!cgrp) \n return -ENODEV; \n spin_lock(&release_agent_path_lock); \n strlcpy(cgrp->root->release_agent_path, strstrip(buf), \n sizeof(cgrp->root->release_agent_path)); \n spin_unlock(&release_agent_path_lock); \n cgroup_kn_unlock(of->kn); \n return nbytes; \n }",
  "no_vul": "static ssize_t cgroup_release_agent_write(struct kernfs_open_file *of, \n char *buf, size_t nbytes, loff_t off) \n { \n struct cgroup *cgrp; \n BUILD_BUG_ON(sizeof(cgrp->root->release_agent_path) < PATH_MAX); \n if ((of->file->f_cred->user_ns != &init_user_ns) || \n !capable(CAP_SYS_ADMIN)) \n return -EPERM; \n cgrp = cgroup_kn_lock_live(of->kn, false); \n if (!cgrp) \n return -ENODEV; \n spin_lock(&release_agent_path_lock); \n strlcpy(cgrp->root->release_agent_path, strstrip(buf), \n sizeof(cgrp->root->release_agent_path)); \n spin_unlock(&release_agent_path_lock); \n cgroup_kn_unlock(of->kn); \n return nbytes; \n }",
  "cwe": "CWE-269",
  "codeline": "if (!cgrp) \nreturn -ENODEV;"
}
{
  "idx": 492,
  "target": 1,
  "vul": "setup_secureChannel(void) { \n TestingPolicy(&dummyPolicy, dummyCertificate, &fCalled, &keySizes); \n UA_SecureChannel_init(&testChannel, &UA_ConnectionConfig_default); \n UA_SecureChannel_setSecurityPolicy(&testChannel, &dummyPolicy, &dummyCertificate); \n testingConnection = createDummyConnection(65535, &sentData); \n UA_Connection_attachSecureChannel(&testingConnection, &testChannel); \n testChannel.connection = &testingConnection; \n testChannel.state = UA_SECURECHANNELSTATE_OPEN; \n }",
  "no_vul": "setup_secureChannel(void) { \n TestingPolicy(&dummyPolicy, dummyCertificate, &fCalled, &keySizes); \n UA_SecureChannel_init(&testChannel, &UA_ConnectionConfig_default); \n UA_SecureChannel_setSecurityPolicy(&testChannel, &dummyPolicy, &dummyCertificate); \n testingConnection = \n createDummyConnection(UA_ConnectionConfig_default.sendBufferSize, &sentData); \n UA_Connection_attachSecureChannel(&testingConnection, &testChannel); \n testChannel.connection = &testingConnection; \n testChannel.state = UA_SECURECHANNELSTATE_OPEN; \n }",
  "cwe": "CWE-703",
  "codeline": "testingConnection = createDummyConnection(65535, &sentData);"
}
{
  "idx": 493,
  "target": 1,
  "vul": "static sctp_disposition_t sctp_sf_violation_paramlen( \n const struct sctp_endpoint *ep, \n const struct sctp_association *asoc, \n const sctp_subtype_t type, \n void *arg, \n sctp_cmd_seq_t *commands) { \n static const char err_str[] = \"The following parameter had invalid length:\"; \n return sctp_sf_abort_violation(ep, asoc, arg, commands, err_str, \n sizeof(err_str)); \n }",
  "no_vul": "static sctp_disposition_t sctp_sf_violation_chunklen( \n const struct sctp_endpoint *ep, \n const struct sctp_association *asoc, \n const sctp_subtype_t type, \n void *arg, \n sctp_cmd_seq_t *commands) \n { \n static const char err_str[]=\"The following chunk had invalid length:\"; \n return sctp_sf_abort_violation(ep, asoc, arg, commands, err_str, \n sizeof(err_str)); \n }",
  "cwe": "CWE-20",
  "codeline": "static const char err_str[] = \"The following parameter had invalid length:\";"
}
{
  "idx": 494,
  "target": 1,
  "vul": "int setup_tests(void) \n { \n ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_fns)); \n return 1; \n }",
  "no_vul": "int setup_tests(void) \n { \n ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_fns)); \n ADD_TEST(test_GENERAL_NAME_cmp); \n return 1; \n }",
  "cwe": "CWE-476",
  "codeline": "ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_fns));"
}
{
  "idx": 495,
  "target": 1,
  "vul": "void ha_maria::drop_table(const char *name) \n { \n DBUG_ASSERT(file->s->temporary); \n (void) ha_close(); \n (void) maria_delete_table_files(name, 1, MY_WME); \n }",
  "no_vul": "void ha_maria::drop_table(const char *name) \n { \n DBUG_ASSERT(!file || file->s->temporary); \n (void) ha_close(); \n (void) maria_delete_table_files(name, 1, MY_WME); \n }",
  "cwe": "CWE-400",
  "codeline": "DBUG_ASSERT(file->s->temporary);"
}
{
  "idx": 496,
  "target": 1,
  "vul": "static void fix_dl_name(MEM_ROOT *root, LEX_STRING *dl) \n { \n const size_t so_ext_len= sizeof(SO_EXT) - 1; \n if (my_strcasecmp(&my_charset_latin1, dl->str + dl->length - so_ext_len, \n SO_EXT)) \n { \n char *s= (char*)alloc_root(root, dl->length + so_ext_len + 1); \n memcpy(s, dl->str, dl->length); \n strcpy(s + dl->length, SO_EXT); \n dl->str= s; \n dl->length+= so_ext_len; \n } \n }",
  "no_vul": "static void fix_dl_name(MEM_ROOT *root, LEX_STRING *dl) \n { \n const size_t so_ext_len= sizeof(SO_EXT) - 1; \n if (dl->length < so_ext_len || \n my_strcasecmp(&my_charset_latin1, dl->str + dl->length - so_ext_len, \n SO_EXT)) \n { \n char *s= (char*)alloc_root(root, dl->length + so_ext_len + 1); \n memcpy(s, dl->str, dl->length); \n strcpy(s + dl->length, SO_EXT); \n dl->str= s; \n dl->length+= so_ext_len; \n } \n }",
  "cwe": "CWE-416",
  "codeline": "if (my_strcasecmp(&my_charset_latin1, dl->str + dl->length - so_ext_len, \n SO_EXT))"
}
